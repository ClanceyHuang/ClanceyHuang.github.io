<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>威胁情报-观测问题</title>
      <link href="/2021/08/08/tiObservationProblem/"/>
      <url>/2021/08/08/tiObservationProblem/</url>
      
        <content type="html"><![CDATA[<p>听到的一切都是一个观点，不是事实。看到的一切都是一个视角，不是真相。</p><span id="more"></span><h2 id="引子"><a class="markdownIt-Anchor" href="#引子"></a> 引子</h2><p>南城的人听北城的朋友说，雨从北边来，南城的朋友抬头感受着来自北面的清风，考虑着，出门要不要带把伞呢？</p><h2 id="预测不靠谱"><a class="markdownIt-Anchor" href="#预测不靠谱"></a> 预测不靠谱</h2><p>威胁情报本身没有预测的意义在其中，它只强调<strong>观测和专家式</strong>的推理，至少我是这么理解的。</p><p>而<strong>态势感知</strong>才是在进行着整个人类都难以颠覆的一个事实 —— 尝试去预测。</p><p>为什么说预测是难以颠覆的事实？因为一直到前几天我才知道，其实气象台对暴雨的预测准确率只有20%。</p><p>天气预报作为一项全世界人类最大的逆天预测活动，在持续了一个多世纪之后就是这种结果。说实话，一时间我还真有点接受不了，这个事实都快逼得我去信上帝了。</p><p>而现在，互联网普及到发展了不过二十几年，人类对庞大数据的积累和认识也只有几年的情况下，他们会说：因为我有庞大的数据，所以我可以预测未来。呵呵！！</p><h2 id="观测只是基础"><a class="markdownIt-Anchor" href="#观测只是基础"></a> 观测只是基础</h2><p>显而易见的是，观测这个动词本身就意味着“看到”而不是“想象到”。</p><p>看到就意味着事实 —— 当然，你要是较真跟我讲《黑客帝国》那一套我也肯定说不过你。</p><p>而观测却只是基础，最终我们想要的一定是，现有基于事实的观测，再有根据观测进行推理。</p><p>就好象IDS里看到了扫描，就意味着可能有入侵行为或病毒等事件正在发生（虽然更多情况下是因为误报）。</p><p>所以，此处应有专家出现。</p><p>多数观测并不是通过简单的推理和看似事实的事件组合在一起就能形成结论的 —— 好像IDS误报的扫描一样。</p><p>我查了一下关于天气局部预测的相关知识，虽然我完全没看明白，但我也知道了一个基本结论：北城下雨且有北风向南吹，但仍然有可能会出现南城整天滴雨未降的情况。所以引子里看似必然的结果，其实在气象专家眼里就未必是那么确定了。</p><p>因此，观测是专家系统的输入：<strong>观测结果 （输入）----&gt; 专家系统（专家）----&gt; 推理结果（输出）</strong>。</p><p>推理结果是否可作为情报，应该是和专家有相当大的关系的，所以这些年来，舆论里被调戏最多的也是砖家和叫兽们。</p><p>另一方面，正是因为专家这层神秘的过程，所以简单的观测+专家的输出看起来似乎变得神秘，神秘的好像是在预测未来一样。</p><p>但说的更直白一些，无非就是一些普通人没有注意到的事实和一些普通人不具备的知识组合在一起的结果摆了。</p><h2 id="现在的观测有什么不同"><a class="markdownIt-Anchor" href="#现在的观测有什么不同"></a> 现在的观测有什么不同？</h2><p>既然是“有扫描就意味着这是入侵前奏”这么简单的原理，那么，重新捡起一套IDS似乎观测数据源的问题就解决了。</p><p>但实际上并非如此，毕竟，距离最早一批 IDS至少已经过去17年了（SNORT诞生于1998年），很多形态和思路到现在已经不再适用。</p><p>现在形势下，<strong>观测的基本原则应是不以关注目标为核心点的事件发现、分析和处理能力，这种情况下需要考虑更多的维度</strong>。</p><p>而现形势下，最需要关注的就是观测的广度，因为现在攻击事件的内在关联已经变得极其复杂。有一些攻击是因为目标系统防御严格而使用曲线救国的方式（例如Stuxnet），而有一些则是攻击覆盖面过于宽广而被殃及池鱼（现在很多日志里能看到失败或是成功的一次性payload）。</p><p>当然，有广度就需要有深度，深度主要是自我认知的深度，说白了就是知道<strong>自己有什么东西、东西在哪、长什么样、变化情况如何等等</strong>。</p><h2 id="历史数据是否还重要"><a class="markdownIt-Anchor" href="#历史数据是否还重要"></a> 历史数据是否还重要？</h2><p>现在普遍的来说，安全圈子里无论是谈到推测、预测或是感知，都会想象基于历史数据而进行分析，从而形成对未来的预测或感知能力。</p><p>所以，现在就沦为了历史数据积累，积累到要吐的时候才发现，其实并没有什么卵用，于是只好画几张图飞来飞去来展现自己积累的这些不是垃圾。</p><p>那么，历史数据是否真的重要？</p><p>在以前的观点里我已经阐述过，<strong>对历史的分析不是意味着历史数据自身的有效性，而是因为人性从未改变，任何历史数据都是人产生的，如果将未来即将产生的事件也视为一种数据的话，那这份数据一定还是由于人所产生，那么人所产生的未来（数据）一定能在历史（数据）中得以挖掘和展现</strong> —— 但问题就在于，这只是臆想而已。整个过程其实忽略了很大的问题就是：<strong>“数据是结果，人性才是产生数据的驱动力”</strong>。</p><p>过分的关注结果而没有考虑结果到驱动力的逆推过程，这样的历史数据积累，除了最后拼存储单位意外，也难以找到更多价值。</p><h2 id="观测有什么好处"><a class="markdownIt-Anchor" href="#观测有什么好处"></a> 观测有什么好处？</h2><p>首先需要承认的就是，在自打安全风险的概念出现之初，我们所在讨论的就是“降低风险”而不是“消除风险”。</p><p>威胁情报为“观测”这件事赋予的意义其实也是类似的，也就是说，牺牲局部保全整体其实是一个不错的办法。利用局部地区观测到的问题将其通过专家系统放大转换到其他具有某种相关性的系统范围之内，然后进行预警、防御等决策的推进。而如果运气好的话，很多时候这些被牺牲掉的局部甚至可能与你无关 —— 也许你看见隔壁老王家被盗了，赶紧换了跟他家不一样的锁芯。</p><p>另外一方面，就是评价结果相对更为鲜明。</p><p><strong>因为观测得到的一个初步结果就是“已发生在局部的事实”，而对于这样一个事实是否会影响到其他区域，其评价指标是比较容易设计和衡量的。</strong></p><p>对于纯粹消耗资金的安全事业来说，这是一个伟大的创举。</p><h2 id="其他"><a class="markdownIt-Anchor" href="#其他"></a> 其他</h2><p>其他什么的，我也想不到了，就这样吧。</p>]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>一些比较有趣的代码片段</title>
      <link href="/2021/08/02/funCode/"/>
      <url>/2021/08/02/funCode/</url>
      
        <content type="html"><![CDATA[<p>平时应对业务需求时，自己会不知不觉看到或者写出有一些比较有趣的代码片段。</p><span id="more"></span><h2 id="识别文本里时间"><a class="markdownIt-Anchor" href="#识别文本里时间"></a> 识别文本里时间</h2><p>需求背景是用户记录会议纪要，然后程序从纪要中提取时间地点人物，用于创建待办事项。这里提供部分时间的匹配方法。这个正则真的是写到头秃。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> string $str 需要识别的文本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $default_year 默认的年，用于填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $default_month 默认的月，用于填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> int $default_day 默认的天，用于填充</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> mixed</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pickTimeFromStr</span>(<span class="params"><span class="variable">$str</span>,<span class="variable">$default_year</span>=<span class="number">2020</span>,<span class="variable">$default_month</span>=<span class="number">1</span>,<span class="variable">$default_day</span>=<span class="number">1</span></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// test:</span></span><br><span class="line"><span class="comment">//    $str = &#x27;发布时间 2/11 发布时间 2015-2-18 18:11 发布的 2015/2/14 测试 2021年12月8日 9:30 &#x27;;</span></span><br><span class="line"></span><br><span class="line">    <span class="variable">$regex_list</span> = [</span><br><span class="line">        <span class="string">&quot;/((?&lt;year&gt;\d&#123;4&#125;)[\/\-\.])?((?&lt;month&gt;\d&#123;1,2&#125;)[\/\-\.])(?&lt;day&gt;\d&#123;1,2&#125;)?(\s*(?&lt;amorpm&gt;(上午)|(下午)|(晚上))?((?&lt;hours&gt;\d&#123;1,2&#125;)|(?&lt;hours_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))[\x&#123;65f6&#125;|\x&#123;70b9&#125;|\:]((?&lt;mins&gt;\d&#123;1,2&#125;)|(?&lt;mins_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;)))?/u&quot;</span>,</span><br><span class="line">        <span class="string">&quot;/((?&lt;year&gt;\d&#123;2,4&#125;)年)?(((?&lt;month&gt;\d&#123;1,2&#125;)|(?&lt;month_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))月)?(((?&lt;day&gt;\d&#123;1,2&#125;)|(?&lt;day_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))日)?(\s*(?&lt;day_const&gt;(今天)|(明天)|(后天))?(?&lt;amorpm&gt;(上午)|(下午)|(晚上))?((?&lt;hours&gt;\d&#123;1,2&#125;)|(?&lt;hours_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))[\x&#123;65f6&#125;|\x&#123;70b9&#125;|\:]((?&lt;mins&gt;\d&#123;1,2&#125;)|(?&lt;mins_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))?)?/u&quot;</span>,</span><br><span class="line">    ];</span><br><span class="line">    <span class="variable">$matches</span> = [];</span><br><span class="line">    <span class="variable">$date_list</span> = [];</span><br><span class="line">    <span class="keyword">foreach</span>(<span class="variable">$regex_list</span> <span class="keyword">as</span> <span class="variable">$regex</span>)&#123;</span><br><span class="line">        preg_match_all(<span class="variable">$regex</span>, <span class="variable">$str</span>, <span class="variable">$matches</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$matches</span>[<span class="string">&#x27;year&#x27;</span>])&#123;</span><br><span class="line">            <span class="keyword">foreach</span> (<span class="variable">$matches</span>[<span class="string">&#x27;year&#x27;</span>] <span class="keyword">as</span> <span class="variable">$year_key</span> =&gt; <span class="variable">$year_val</span>)&#123;</span><br><span class="line">                <span class="comment">// TODO： 添加错误正则保护</span></span><br><span class="line">                <span class="keyword">if</span> (!<span class="variable">$year_val</span> &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;month_cn&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;month&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;day_cn&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;day&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;hours_cn&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;hours&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;mins_cn&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;mins&#x27;</span>][<span class="variable">$year_key</span>]) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$year_val</span> &amp;&amp; <span class="variable">$year_val</span>&lt;<span class="number">100</span>)&#123;<span class="variable">$year_val</span> = <span class="number">2000</span> +<span class="variable">$year_val</span>; &#125;</span><br><span class="line">                <span class="variable">$current_year</span> = <span class="variable">$year_val</span>?:<span class="variable">$default_year</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 月</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;month_cn&#x27;</span>][<span class="variable">$year_key</span>]) &#123;</span><br><span class="line">                    <span class="variable">$current_month</span> = checkNatInt(<span class="variable">$matches</span>[<span class="string">&#x27;month_cn&#x27;</span>][<span class="variable">$year_key</span>]);</span><br><span class="line">                    <span class="variable">$current_month</span> = <span class="variable">$current_month</span> ?: <span class="variable">$default_month</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$current_month</span> = <span class="variable">$matches</span>[<span class="string">&#x27;month&#x27;</span>][<span class="variable">$year_key</span>] ?: <span class="variable">$default_month</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 日</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;day_cn&#x27;</span>][<span class="variable">$year_key</span>]) &#123;</span><br><span class="line">                    <span class="variable">$current_day</span> = checkNatInt(<span class="variable">$matches</span>[<span class="string">&#x27;day_cn&#x27;</span>][<span class="variable">$year_key</span>]);</span><br><span class="line">                    <span class="variable">$current_day</span> = <span class="variable">$current_day</span> ?: <span class="variable">$default_day</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$current_day</span> = <span class="variable">$matches</span>[<span class="string">&#x27;day&#x27;</span>][<span class="variable">$year_key</span>] ?: <span class="variable">$default_day</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中文小时</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;hours_cn&#x27;</span>][<span class="variable">$year_key</span>]) &#123;</span><br><span class="line">                    <span class="variable">$hours</span> = checkNatInt(<span class="variable">$matches</span>[<span class="string">&#x27;hours_cn&#x27;</span>][<span class="variable">$year_key</span>]);</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;amorpm&#x27;</span>][<span class="variable">$year_key</span>] == <span class="string">&#x27;下午&#x27;</span> || <span class="variable">$matches</span>[<span class="string">&#x27;amorpm&#x27;</span>][<span class="variable">$year_key</span>] == <span class="string">&#x27;晚上&#x27;</span>) &#123;</span><br><span class="line">                        <span class="variable">$hours</span> += <span class="number">12</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="variable">$current_hours</span> = <span class="variable">$hours</span>?:<span class="string">&quot;00&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$current_hours</span> = <span class="variable">$matches</span>[<span class="string">&#x27;hours&#x27;</span>][<span class="variable">$year_key</span>]?:<span class="string">&quot;00&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 中文分钟</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;mins_cn&#x27;</span>][<span class="variable">$year_key</span>]) &#123;</span><br><span class="line">                    <span class="variable">$current_mins</span> = checkNatInt(<span class="variable">$matches</span>[<span class="string">&#x27;mins_cn&#x27;</span>][<span class="variable">$year_key</span>]);</span><br><span class="line">                    <span class="variable">$current_mins</span> = <span class="variable">$current_mins</span> ?: <span class="string">&quot;00&quot;</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="variable">$current_mins</span> = <span class="variable">$matches</span>[<span class="string">&#x27;mins&#x27;</span>][<span class="variable">$year_key</span>]?:<span class="string">&quot;00&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!checkdate(<span class="variable">$current_month</span>, <span class="variable">$current_day</span>, <span class="variable">$current_year</span>) || <span class="variable">$current_hours</span>&gt;<span class="number">23</span> || <span class="variable">$current_mins</span>&gt;<span class="number">59</span>) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="variable">$date_val</span> = <span class="variable">$current_year</span>.<span class="string">&quot;-&quot;</span>.<span class="variable">$current_month</span>.<span class="string">&quot;-&quot;</span>.<span class="variable">$current_day</span>.<span class="string">&quot; &quot;</span>.<span class="variable">$current_hours</span>.<span class="string">&quot;:&quot;</span>.<span class="variable">$current_mins</span>;</span><br><span class="line"></span><br><span class="line">                <span class="variable">$time</span> = strtotime(<span class="variable">$date_val</span>);</span><br><span class="line">                <span class="keyword">if</span> ((!<span class="variable">$matches</span>[<span class="string">&#x27;day_cn&#x27;</span>][<span class="variable">$year_key</span>] &amp;&amp; !<span class="variable">$matches</span>[<span class="string">&#x27;day&#x27;</span>][<span class="variable">$year_key</span>]) &amp;&amp; (<span class="variable">$matches</span>[<span class="string">&#x27;hours_cn&#x27;</span>][<span class="variable">$year_key</span>] || <span class="variable">$matches</span>[<span class="string">&#x27;hours&#x27;</span>][<span class="variable">$year_key</span>])) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;day_const&#x27;</span>] == <span class="string">&#x27;明天&#x27;</span>) &#123;</span><br><span class="line">                        <span class="variable">$time</span> += <span class="number">24</span> * <span class="number">3600</span> - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="variable">$matches</span>[<span class="string">&#x27;day_const&#x27;</span>] == <span class="string">&#x27;后天&#x27;</span>) &#123;</span><br><span class="line">                        <span class="variable">$time</span> += <span class="number">24</span> * <span class="number">3600</span> * <span class="number">2</span> - <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="variable">$date_list</span>[] = <span class="variable">$time</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">empty</span>(<span class="variable">$date_list</span>))&#123;</span><br><span class="line">        <span class="keyword">return</span> [];</span><br><span class="line">    &#125;<span class="keyword">elseif</span>(count(<span class="variable">$date_list</span>)==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> [<span class="string">&#x27;start_time&#x27;</span>=&gt;<span class="variable">$date_list</span>[<span class="number">0</span>],<span class="string">&#x27;end_time&#x27;</span>=&gt;strtotime(date(<span class="string">&#x27;Y-m-d 23:59&#x27;</span>,<span class="variable">$date_list</span>[<span class="number">0</span>]))];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="variable">$start_time</span> = min(<span class="variable">$date_list</span>);</span><br><span class="line">        <span class="variable">$end_time</span> = max(<span class="variable">$date_list</span>);</span><br><span class="line">        <span class="variable">$result</span> =  [<span class="string">&#x27;start_time&#x27;</span>=&gt;<span class="variable">$start_time</span>,<span class="string">&#x27;end_time&#x27;</span>=&gt;<span class="variable">$end_time</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="variable">$result</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkNatInt</span>(<span class="params"><span class="variable">$str</span></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$map</span> = [</span><br><span class="line">        <span class="string">&#x27;一&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;二&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;三&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;四&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;五&#x27;</span> =&gt; <span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;六&#x27;</span> =&gt; <span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;七&#x27;</span> =&gt; <span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;八&#x27;</span> =&gt; <span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;九&#x27;</span> =&gt; <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;壹&#x27;</span> =&gt; <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;贰&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;叁&#x27;</span> =&gt; <span class="string">&#x27;3&#x27;</span>,<span class="string">&#x27;肆&#x27;</span> =&gt; <span class="string">&#x27;4&#x27;</span>,<span class="string">&#x27;伍&#x27;</span> =&gt; <span class="string">&#x27;5&#x27;</span>,<span class="string">&#x27;陆&#x27;</span> =&gt; <span class="string">&#x27;6&#x27;</span>,<span class="string">&#x27;柒&#x27;</span> =&gt; <span class="string">&#x27;7&#x27;</span>,<span class="string">&#x27;捌&#x27;</span> =&gt; <span class="string">&#x27;8&#x27;</span>,<span class="string">&#x27;玖&#x27;</span> =&gt; <span class="string">&#x27;9&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;零&#x27;</span> =&gt; <span class="string">&#x27;0&#x27;</span>,<span class="string">&#x27;两&#x27;</span> =&gt; <span class="string">&#x27;2&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;仟&#x27;</span> =&gt; <span class="string">&#x27;千&#x27;</span>,<span class="string">&#x27;佰&#x27;</span> =&gt; <span class="string">&#x27;百&#x27;</span>,<span class="string">&#x27;拾&#x27;</span> =&gt; <span class="string">&#x27;十&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;万万&#x27;</span> =&gt; <span class="string">&#x27;亿&#x27;</span>,</span><br><span class="line">    ];</span><br><span class="line">    </span><br><span class="line">    <span class="variable">$str</span> = str_replace(array_keys(<span class="variable">$map</span>), array_values(<span class="variable">$map</span>), <span class="variable">$str</span>);</span><br><span class="line">    <span class="variable">$str</span> = checkString(<span class="variable">$str</span>, <span class="string">&#x27;/([\d亿万千百十]+)/u&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="variable">$func_c2i</span> = <span class="function"><span class="keyword">function</span> (<span class="params"><span class="variable">$str</span>, <span class="variable">$plus</span> = <span class="literal">false</span></span>) <span class="keyword">use</span>(<span class="params">&amp;<span class="variable">$func_c2i</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="literal">false</span> === <span class="variable">$plus</span>) &#123;</span><br><span class="line">        <span class="variable">$plus</span> = <span class="keyword">array</span>(<span class="string">&#x27;亿&#x27;</span> =&gt; <span class="number">100000000</span>,<span class="string">&#x27;万&#x27;</span> =&gt; <span class="number">10000</span>,<span class="string">&#x27;千&#x27;</span> =&gt; <span class="number">1000</span>,<span class="string">&#x27;百&#x27;</span> =&gt; <span class="number">100</span>,<span class="string">&#x27;十&#x27;</span> =&gt; <span class="number">10</span>,);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable">$i</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$plus</span>)</span><br><span class="line">        <span class="keyword">foreach</span>(<span class="variable">$plus</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>) &#123;</span><br><span class="line">            <span class="variable">$i</span>++;</span><br><span class="line">            <span class="keyword">if</span>(strpos(<span class="variable">$str</span>, <span class="variable">$k</span>) !== <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="variable">$ex</span> = explode(<span class="variable">$k</span>, <span class="variable">$str</span>, <span class="number">2</span>);</span><br><span class="line">                <span class="variable">$new_plus</span> = array_slice(<span class="variable">$plus</span>, <span class="variable">$i</span>, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">                <span class="variable">$l</span> = <span class="variable">$func_c2i</span>(<span class="variable">$ex</span>[<span class="number">0</span>], <span class="variable">$new_plus</span>);</span><br><span class="line">                <span class="variable">$r</span> = <span class="variable">$func_c2i</span>(<span class="variable">$ex</span>[<span class="number">1</span>], <span class="variable">$new_plus</span>);</span><br><span class="line">                <span class="keyword">if</span>(<span class="variable">$l</span> == <span class="number">0</span>) <span class="variable">$l</span> = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="variable">$l</span> * <span class="variable">$v</span> + <span class="variable">$r</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)<span class="variable">$str</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$func_c2i</span>(<span class="variable">$str</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkString</span>(<span class="params"><span class="variable">$var</span>, <span class="variable">$check</span> = <span class="string">&#x27;&#x27;</span>, <span class="variable">$default</span> = <span class="string">&#x27;&#x27;</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!is_string(<span class="variable">$var</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(is_numeric(<span class="variable">$var</span>)) &#123;</span><br><span class="line">            <span class="variable">$var</span> = (<span class="keyword">string</span>)<span class="variable">$var</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable">$default</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">$check</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (preg_match(<span class="variable">$check</span>, <span class="variable">$var</span>, <span class="variable">$ret</span>) ? <span class="variable">$ret</span>[<span class="number">1</span>] : <span class="variable">$default</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable">$var</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Life</title>
      <link href="/2021/07/04/hj/"/>
      <url>/2021/07/04/hj/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fe796579bee276607e463d8158595c6ee63327e6c7f3d4cff0571cff323d895e">6b696c7f1f43b69d9727ffa4130d5d4ade1c1b8d1f6c6e8bafa441fc9561c8cf2a65f45b2d23bc07032098151014bcb2bec5675c2f11ce99413d51ada58a06625a427f7700956e0ef4291ba85f7d923bce02a56735a28d1c9ad8bc711ae40d0f991bfb0461e28802493f2a0222bb9fb0c7fd2f25e5ce0caa1c2e431a6368a4c77b64a8702b1e809fa5bae11f2ab30519dfb0d24a36f7bffeb8afe63691e247c2ffa7d0fe81456ab0ff65ec1fa9c693fd425171e1ccaf39d7c69cea1be8c69acf21b1770b248d8a96759962e1f1d66c182098ad057bd10fb245b4a35a147e8170a4b531a45cd7fc7775d4c6b35cbf064ac53952a5dd01dc870e93b718ada061dd2174b3110bc05e041ac5db94307ca99ecb0b615c4284dafb7ea0ff094dc76224f60a737680662be37a63a0db3123961def47bc95d48fd7824ecb477738244ee31e9448cfdd5c0c016f02de84840ac84666ba4b98d8f48ea07446b330b35eda9165f24196388eb78076b639513fadc01c15b1bf1a333c64faf516cd8c41dbce699295e09b196193ea21a0b76f6d12ebbd2411a3cc20a1e586ae688b4f5c2235aa470b2fc71589d31b3e828087bd33b3b3628e7e17a4b6bff8b48de325c67ebe31016fd3b3df38cbfdcd7e27981f3da7a7857e828779610d7336495ab45aedcdb5bf4499848494e8a825d2e385f79f60fa9f5b4a1a5ecc81fd785856625c6d4580979009a95aa2d9689b42e7c8e02b39c1786bf0be1e4a63608c875dfac6ac7a0b33eab9cf56409e7eb7d4226238ae633e9517d998b1c951febbb3eab1a6595cf39fa0b086999a8e1038fa2a2aeec1a187f858e5fbca0576f0472139c9f3a5d44ff8d760fdb70ba40bb7553b5eb062b9f4a8323136e52ad2c3df49b306c20cc5b9a3a281dea9d07988209c3047e0b5eb77f5347b4b203ac5712d6cf37353343b2c789c9acbd79a5074b458d674c3ed32defac90ade4c4d337ad8def9c6e6a2c00124bb21e43a0f4fd2f455c04500d6654963e55a40c78e31da9bdfba3c6de30eac9a37e048b80774fed728e80a6746fc15939c1016d559f5260a4e9be73a09e6db3fac1570f08977713f559560960f674a660abe15ee49edc4fb06286386cc7fd0dee69fd321943a64a2f859bab729cb14b2ccec31225add9b244076a0baeee0ff9578ae4119f463691b1d1adc5d30c2865080f5bcce86557b1f0c7b55c3a3a13debb3d804f33dbf7c77015ecae38f567294aca241e2f11cec562892877dd70446e42172414312b3fefed0b6005204005f630489ce733746a888182142ba4c3f7fb92af3682132608b3cae663498d2346f17c5aa1963c46498eb26a60716796aa8072d0ae7b2a4a0f3677f41d3a6534280377d15ea7e70fcb191e7e53f52bdcb4c3e4226f8ba765025e691164776d1a11589e15f58613f757fe4f6ae7d884616774b1f42cfa1e3da6c85d6cb006e94dde2beb87a4b890fe97b5e2d1a78bc8d97ff3465d272a3a0d5d6ebb0e7e2f67d5466fc555af32cca5e5d5a9646a1f8d46b52138838db2078ed0bc63c609a007d6f06055e7bd39622bf23eaded7425e06161defe6a4760c37af87fe22c0fb0094170205e54d00eebc0ca8cc26b648280818d2077455c534e695dfcfb0ea41ade95ae4ba04467cc870e576e8f13432acb27bb5da2eef7ed9d3eb2e7a5753fd3ad139b0783a880d5885e4f98c8c14a698155043e7c61fc6c53bb45b247bd276e9cee9f3f7118092cd85991332784d477bc650feebdad8ef83a956e88d0849ade408ec09c23c847273cb771cf3284aba23c9750b56de0d027c8026dfc16c4a8d7c5f0ac284bce9d50c83238e059d77c833cf147a7cc3493885bce0c07b8e61bd4d5daaad9bcb60ed7fb4fa5b15469c2de18ba0fac183ef273c4299a1adf6d5180ecab92be8fc4f6854e0d21ffc2990c4e055bb584ff56887d49a20e7321f866380dc5d250891f87c02c0cdbde88029841cfad15adb1d225c9aff28ef48a49c163a5870a511e4a5b5632c8b49f36bf1f490b6d2dd02aaee95f5c0dec9f9846a9264b0f657de456a4d3c9f725c91fb231e00345a55c01b9620851a20269257c6df3589692633a5062ad7f54c11d823bb36453f4a35e7e09650a308b8ff6541c867070a107149b842ed2a9889a86ef35a8bb87db8f9c3ef2632cd655e74cbf7cc2f211d187a7204a80e15332b9958d6babaaf25a38805488306a2358ea4da7ef8d9455eadd8749a5ce44b7e0ae56910fc492093585737477de2aa10cbc086e208e4937b81d75591247d3a3ba04de3b6aa3f25ae2ffd746533413b9cf0171b4afda75f61a2ee648d76233867ade56011bfdca35a384c1434ce31ab8c4a13a58417f7d493430fde4eb25dd1820b356043dfe1e3c1b13d5512cfcfb1dc05bf0994b7eefa4bafc557a2642ba4aa5eea692a0b3b72d90c5b882f6b7c201acaa89029aa65f8b596d056792166de9d9b2cb23d7f5057432d65a894a8e2036a4c6d0fe869d72dc6520df737afd98f91e3418d17a0ebbbc199d0ee60a8491d6499cdf3072f3704d9181709e86534efc832dca0d908520d874adacbb0940afa8431c3b225abeb14c3c02d793de5533deb9f010ec16d66ba9be5f0993f773028d4ac7dc123129fb79fc2f3c53074a25ff35338cd9972298ebaa80a6421b7df88d16d1a38bc400a95660e38a9bf8f6ae0f3d7e4a88d84e09d33d863bd04716414bdc94b5872f1d8a1b4aead8b4947c6611aea028cd654441295dec09d4f46e5d317480b2881abe64a740603515a02ed6e34e0cd7c0bc0354adb8fa40cb8c3aa5293c1228a7c51c9704fc032e5e634878548d030d65baa0e65c9e03b1c118c8e222ecd245d1ab65183ba15b3b6e6c4e2b0669d94d7794ea35b7b586c9690848bd6c4d6871e3d66025c7fda832f6e81617c94515fc3925cf37c04a0d490aedeca26adaba495046084288caca787f36e940d79eb59356dbc4690b16b5dd7f50d81a486b27ac4dedb93d488888a4e46a66295dc13818ed1a0db2b96fd35581b4db2097dddc5de4c0b4ac7c885d5503d306bac6551ddbc56bbbf336819781762389179a629dfbc55131ae410abe0f2164f6c2bcd8ec07b93ae36bc30f075a0bbb5aee6dfbb57800596b03ce237239384134c1b73e140cacdb481f0c99c489bf8f729a1138d14a6c20e76b773420597bf08e419a46bf33b5a375c2075095628d46eb34e0b2599108d718f9f82ad8de3faaaf9d57630ffe8029e146cba1a5069d8131e6ddccebed4ec7291ac801de5d255eea2e87680194cd545cc0d263f3bdcce087aa0b9d3dad6bdeca321371a607fb77f0b7e37c02288d506963cfa6c416f384e7c4123bd5bece99d5d32a7fc43db639e7c082828e1b1271a81903f5bc692e930cf1f890f366ef173866f0e4cfab1c570624e41e0c830e7cee2d76e55e396f6a87ef360284983a4da2c2e3875138c4b0eb4c084024b6a731f2f2c7423ed9b58357466e62b667acf13952d51a0a2dd31e41586f7a299814a3636e4a5e88fca4039a0056f4e174fa70353eb1a9f3d2e7e204556b8d389eb2343ebd547081aebc0a0ed983eebf45ee711dd6a5731f0f0e81821544c6e5a57ea941ed186de459dfd3588c1682ae4db53f649f30c7f1cda8781c492910c28943b8e89f30452866c92cab7c63d3d32c414b1f5a56423bea51c4247d3ce7607cd5d28a424bc7528eea5c6a2add731383837ca775b1df2b503ea25aa6ae061fcf1e9449c968ec3bf0429b3950c02a8fe06cc4bafd8d2f5c556de5e14fbfc5321ca75f5fb920cd395af6417a66e442b8f25c0da7095b6234f3aa8be9a84e9ea1e049a702f8e61075f5061fdb157e7d9f32dfd978f20796e17b1b7633c078d16aa6978bec9437c3b637a0480b815d6a3e7202336eaf1e5c5da6ab0f6840ea9f54529c918b8c0559bac63888385289b8b983cf1c490be52f8bc36fe94bf30a01e5e2823a5d7521c8dcedc3ce975ae51e25a8266f03a010eab51967eff1bf10f1189a65eb7df9032cb76dbb68d0147cf1d2f60fad525f7406da362792d8355bccd1bb2d7809202cacffb59471e2bc515df36f3a848616a841c73845cc93bee2ec2e709547535756625c05836cbc6e74ddf64ccf40b985da3656994957eac8f793da012232b0556f273fbdc14e61ecef3598ef927984741d0781e0f652621e22dd331cfd3c46441ff890dd4015bb3345d73e635afaadd1feaa531be1d94cac42ae92ef838acdfce35ee1c36e4cabbf52617722fbf47938cf0f801450921ed274478666b27d7a451ae2a2d363680fde8f5965d348dc786e9d5ace89ba505fab33cbd1aab46a390c384322016d13c74923b3b0a83e78aa1190e41559b43f1d312d438b9fef666f709e264844a3ac47193fabe6c9d3def934da857350cfe76aa42edeffbddd5cd8bfc8278210a9f42e907bfdddec00821b5ebf684162a6600e7bfa38f795fdc6e12bdc4c02b320afccca4e110894018a06135e814f30dd2de52c69dfc2db8ac41cc11d85aaacd1dd00521d79fedf4f7bcfde93fcf8d325ca453145540170a9ac9ba43de9a9a7b1ee3e81d8eb222f3e2bba721c72fa3e90ffff8aa2377c52d194c0fb1d9453edb51dce54a9f8e544b972ae274787e1d7d81d5fd288e37675890a6191038bff90cb4682620e885c74677b2b3417da9220fa38f5107632c2f68378cd2e8fded57b11ca0295c1b07bd024565e5b3ea9c6e57e90e9150819c2088508b4484f96db28dba2d354b0460ebbd11d55dbc7fcb83705c7bc3addd9cd7703a2ec92e4675aeda841f034d634b4b1dc017e79ab5241854e7d8be887e70f5be5b4517ad7ef34cbfc3f7a6a2cee485628a70ca1af0aab6bd44a280446aaffd48b957230bcc3fa07cd40299026613193e7adb9be053c18f043f2c8165295ee0f6cd21c68922e9ff05745bb0e8ade71a9240baf812e199feaa09707dea39c246b05fbe116b57e0632df34c5636de92cb78516496d14de1a9ef8aa4a42dfe22a7a58febcd6f2c580be2ff6fe88a171d17d9258b4271605a1dbffaca1adfb7d0a5d433a3ff9260d51b323a95af3e23b680847c7342a0b1ff37976f237b7cd5bef35a25e6f84529849abaf6afc13581da12a7cc9c6519961342aeed46de30d679baf25166f1063d9e30c50f740452f1bee7eeb77e8d07599aeeaef506f637447558cf155baff384c11950cb70ed1a864b3da8d27b2cd44d13f67faa55e6a684711afe4b2a6556020eeb2b729623c267df2165b823f3ce6900bf5434a79a83727a9f66e3da1656baabc5a0035fd7ddcd004e6729e7caced1de339fc999635f4e4850e5400f1685a7f7a6fc3cce2756c88535e6e54a2b5e4372bfb19e365a0f5ad03bf0347ecad895a3356998d580d41d3f5e70425e380a9e6f4d1c73bf7f6a9c65a11234d2e72ed6e84ed1598116f22e260c1bc6391d4dffbaab7d6ae608e3a737c53fe1d82a3f094990013d67f60ad6e60a9f517ee8598edae9928b4e2bf4d40e0bafa80eb31a201c8749f51fc46564a11672aa4e6178c4b4ab730bae1f4e69a24142f6cb0ecaae1aa92855168f778f55b9be29ce3cd9b42d54c7100be5985f389f3c755ef70f38c0ebd4fdaa76e10bb1dddd53e7b5445a43515c0c07f60983af83ffb0190fae04df9d10e461b4781fb806c8a3f430b5cdafa6763a7ee8f428377f7fa01c1760ead3ec7095f94efc8840941e8ba844c9cd5c8c8df7c158ca00c6ade4f46a102ca78658680d89a44d02b2828a1be2846919166a8c3bd3a6ad6976d7cf3efdf8ef6608f7eb55ecec9e5b9f39b80e74e3ce1efbf0b8fc96faca5527470f552e8286fb4dc40a7024a995154009684065a205e7fd183ec886646901a2548e7969c1535a01e646975db665c6048cf18d2ecfb7e2b69c8709f210e97ddc8419cbb32c6a5d59fc0ffb51537bf22335e65aefd18831db44066e8d95605920b4e10eb27556c2597d40fa1d100c34fa1af3f22749d5d5118044e3da9969fcf5d877cae4de37423603d8ff1ffbd6047c79e6eb5fbba044a58d85a23cb8acd8f2da8ef239d3d91fc80a61eea4fb411e642ec8cec2d9b714b1c7293debff3811823f9afa1739fe7867bf54285b623c46fbd3dc56517569db1e04c186e4dfb30b986eae41d77d4e785aace0914a8628d683bcffd4504990c4be53ac8f147a868ab3b813e8f5b0d9acbb09988d86790335d9ca709749a0e2ea2042cb8783febbede5987550fe0287214525daa6ef53e121622d18a6d9de1e8e8d35b50d59f83ed529f96e80a8eeb140995ec76a3534f827c6b8e15131a54d255ba1a44d7585e76cedd931cd6032129cb2d37ac84e5520efecb957ca14ee03db173c624780048c1925a99b0af7c6fcc134dff69e6c08872fb6e2bd779eea353d8e87b9eb3b7a5d5c4aaa33e7065bf66b3b07975aecf66a214d82af3c0f50c892c15caa21248223f6008bd8fba9649a700ce2b0a605ed5cf5d6b04756b4bda002ad991640656a714c1bab5653d6dfd231e4d3758dfeb09f23b3e1a4ddbbef0ac68405b062e0a078a066ffa8a83037cd08f0ee7cc3962e75d4a12525893556c506272acae2e78512533533c6ac5839bc2f5270a52b2a515e0baf5d52e9bdee9298eefe1f3aa9a4f9464a9e0f6197a31d35b93dd67c833c33a5c2f2dd0a298d0c2bd8ec9bbf47cd8cbc5b93f5846240b9863637071de98462a2f93b141e49241caf04f2c4256980566f424879308a6ca1bad19b1c473e849b824c4927d995b5b352a94603530744bc517b7040e9009e2718e7beabe9a5c8d35789950806a35f4bfa553c02b374e647c77e9b729c3c657de7e6294fcd3332bbe6ced1597d0d002d5694ad2108f679ebb5db53e9015ba3f43a9b9c50a99335faa59ae7e858b5e4c5924c8aaab28d2fe9af848f0c95f2d54757b7a1d06e867da474514518c8c83415497693798e892f96d86b1725cb8aae1125f7a5b0e5e4ecb2c3471902d32d5260de4b52ea2ad1462f134cd727465c7bfb867c206230ac733cb0cba495caf7992a3388a560fedf2b2e31ef338a19854ba85bba86d7b500f4354bdd6999e22e5e4bae9d1368aa0b65271b0f909b6ee200da269d5e9053d91b0ddd6d2bea3d69bd03b09452e67ffad3c14e60c3b0ffb9485103acbde2e0edbeeeb5ed163526dad363a265638da73f33ed506e9ff5ddbe6efe073647e76218e5b81f8b7042af119a04df8cbad78170a9c58a50069fa56a84716a38a0fd59a276949e4642e3484fec52a73da0851192f1ae1df437997a07ba39a4f1fbadb7b5a5af0216c55f26437e4d8b0d109dd2268d54c60526663a69dc274d977d982535359449d16439b98c9c69f1222f9111483e62855fd4cd337e87ca3f43b7269d778fff7c79ea798496bb63d5e702037653d8be7611cdd12fb77508b2b09051e49abfab9f4603458e8e8563bb344dbecdcda4e204584b819b9130844aa6bae36a0a89e3938a0f3c2a70724f73c48281964f0a6fb9dfb3eee359cabc026e23307d84ad89763f860ae1c469c6a222a3ec5674141022e5896a066f07f74efb496c0c906d705181527f337d7fc864da9c186856e5b1b99ce7327b5256aa1fbe81dc11dab96d315e77c835f6eda86a6b47024dd32a758c18a8af9ab7b8d6095d9b8b92576ff4bda91e74678b671df4e8ae48b6606ed76311fe6156dce89296000e550ba1ba2bd5f3aaaf7fa0c33fbeba8062c8ccc38b49c9f0328dfd25716064918a08afdaa479fca8881d59623e6e7e6a1d9637deda549114740fa0b8181a2253baa8a8f77747f24ab8c93282b39bbb1b76ef5b80d13f9d649ff963a7a55c0d1b54fe33ac14504bd982870c408e071d02e851a40036a38eb46822a7cf8260bca195db99c2472fa8e5b336d543e8572871</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>2021HVV漏洞公布</title>
      <link href="/2021/04/23/hvv2021/"/>
      <url>/2021/04/23/hvv2021/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="7f1a2065713e57653f6a0bb66bc3a7350861173a418e4b7d1ec36badcda3d508">c6499caab5bf0a89de423ff0eaf2d54369e9196b9671fb8670e26ea30d8c2d09fd691ef68749ad0c7f3cf09d2c046ecdd68a2b9ec48cdb77caecfc614263d506fafb21973b3b7113bd50159aee710c093771734dfba06a4767d1e49220447305936235bc8d38c43588b7dfed0c857b2a534ee38a8d54f549b49cafefdecb5212f3953e0fedf4dbf5e006df135bfe2b25a86c91c6fdba8fb74a931152adcb05c2df99882e9e93d01de543618e1bc4e9d928b8e1f295b55f9fa7ad99ac8d41745d7df94cce2d3eaec91031e43a741eac86476199d4b7dfd93c199eeffec7cc68c77922f8e0f44416d79ff3cb393560ca00f093bcfe870c404434b62f0c0f6341303c6b1bd75b13b90f349cfee95001242fb6cf8f7e2f769691fcb83e69b023b1f9b83c3eb4803195cc36b857c4f9179dfd17b6232d92351d0b60a154aa55ef1f03f9dd4dbcc6b836284bd65dca0b82552a1ddb902801dbc9facad9bf602479bd4d19c3b4147bb68d4aa85953ad4e0bf03e2b3c39e9f36ee08b5498ac6117fc967251228d10e6f9248c3f8c52250d90e08149c44d64ade080b3646c98dd4783dde0952664dc034de0149ddd425168349496a265876bddf43acf3481ccf055f8b077d3ea1b9a2cf2f8d456ce41a9815931ee2e3c33516907cd69adb8e802fdc5fbd2348c228977f989bf9bbea134edd405cdc9853c63bcf63a5ef71606f3764ca19613ea1b518828fafe799b7e74acde3bc1bbad4a9c2b5fc7ce3060dcb3c17cb192645729b2b1fa9145de815bfacbbbd1beedeccadda529a414e93ea241c104564dca06653bc6c7ee833770d4742f15cde6761c3fea2d7f20cd75d5487e2a7ade534cae211c86717410b575270141afa2055eb01f5bebb79d318a4d279ebf4149690283ab7ed5c2cd3a8bfc6840062ec76bce46af30fa6f1029cc82b5bd9132a6e754f86b87c5bccf47949b03e015896d639e81dc2a3f6f5ae2091a60e570602ad432276278a5d2c8a31ec04a421681a52fc2830387dca641ff0059206ab100604859386e53b2a45abf3533f25e61df12b26277f465c06f18bf16579a6bacecbe88ee3b491aacbb01919506108d70f0e70e60f45a40d3ef471d0dee03d468cf2a4976d3170cd0c43cbffcde7f6b41b5942df2463bd7266620e2f4e4868f9e2f5c8115986c7d0fafc3ddc9e12aaaa3de1ffd5daa08c628d1ce5dbe38303cba44b89c2fc916bf5e403f750c1899fac1b64630da85321075167ff09808547406fc1d809ba4b4b8093aa97b4397761b7111a47c62a4ed927a18aecb31b02232ddeb3f9c42334e16243cc74f180e77ba44158e666ae61f1f8931593dcdb7f8574e872494f2b3084b939a4e5dee352e7d62e6c4213fdaa6e7d0ccf767a5b5eaf8ed94192719ee7d16145fca8256d8982fd60a87de52ab0baca661a9a29c39c5cd4c7cc4c287dfcd5462474353684cbe799b2f721809850981edcaf05d49f48d05c6c06784e8eb91c911d85a39926ce0d6b1c4be62640b1d70a9fd354e37d750a9b9d666cf7a35711f7041cad597cd99035d95d1ebecadc0916adf680234a489013bd6fd1e0ad9a92fdde07ff819e5ac004def4dd9488d8cc7521d5ac2888883624180e51dbbaf1a6a83cc8564f3e5498c8f3a5b90420b5eaa151861042070addabf1dcd90b033f6148a3cdd8b40fbfce1cc715df01cd77be1d8c012e0078f6b1f1c7381d140e67b02389f1cbf06fba2165010077e2b0d314c31ae5800cc0a38b8e288c15c6ff67d12886abe8d129f4302f12c9dec57a9a7387e6c62d3dcfdab7093095e52f134c1c0f836a1357c64a34700360c04f2fea53a221b8ec43e6cc61065134965ef643755b46a1f67ef28c395ef32f1c489748606a2de069fe767740ffcf1bde29450b1b065c56481fc06cee20e72e6a4f2a4be51fa3664d47bc05710787c32144a0749d27a5dbcd4af92983245352f22b93ca13a0bd4663748bc87c9474993eb23baf055bfa25ed25b9f9e18768274a459b9f4733e09404ac44bffe00b011a6aeb42aa07bd346231aa88dde5de8687e9d83e40989b938d3abbb11435b8b7fdee7dba58c12e1b7875c4def404bc4f5cd928e3586a8f1939a79360af05edda340e551ccf6e1ffa318975738afa17260fc2a2451e03d54997ad57b92428c4940a6ca0e1f6a66e3d2b03e060b710183650db8975dbd63d480ee7a0e3c9f62dae58dd7cf7fa78d733aa23559a774a23c3974283ccae77ab59d897631c0bf4a2ce83935745cf01a1717be0ec744377567cc0cb0605d9510cbdd230bc9fa4435e99df6a77fc5c7714843b4ee87f9eb1cc001d4befbc799257a09ebb6c49efd1c7dc1811e3890e0118644d272499916d57a57676929b7c778a98787680b95be73ca377894f17377f28796f55b0badfe1ba7a4d7fa0fc4c0b54c61012cb83a7fa54d18849048e3019631cb59dcf3d08e22ea5d3f3b6ecdc59ff0ff9bcae7b55d585f44c8a02dec8cb56ef1048657db41568d537295683febb35f1e1b4300eaebde088660a4edc1578cbc974bca9da680175724aa3c6aa6551ddfe300bf98c3844422485513d2f2a2d79046e797b3cf7feb2e7fb0db67a340a7ae14a8442f46a17c94ddb731071c04d01dee57b30e02968db5d46eed776813a2abd240c07ceb0397af2b92092cc16b951d00e4dffbe9d4cab41c6948452c36ab9429f178681177c31de1221bffb7d5cbfcfa3f8b2d1a8bd42dd3f25358691489945d1e4eb836fe84b9e80e7240a8594c7970656ca3c5051dea5cfe8665f180134cf1d94b702e117dc2188168425e2171efe6401640c6fe12adac395d818638d79b6dacd63925341a7d7a7136bb6fdc75dbe67adcbf9f93c2c55fbd5f01899accd2f7c4c8bdebcc8ff15fbcd3edd31e7791d196bacda2f150a9564e4631449313d2aae24b57dbfdc4a941feb2ee8d07fd0e2579448c60c68d63a4012df5ec345910638f6cf77bab6488596515ef1a401970a9da8acbb1381f18b5b4b5d6046405d1212543eb1873f9c6ab98eed9ac0fc34f572e54ad40c97f629faa48b664993100eec1ced88581439e1c6cda725debc71608d9cccc7f02d3de1853e04a729e739e5ded92d26fb7bf9a6aa442ca03bdc02cc3837e8709b4eaab91307108cc9e2c5da4028e51e20770a256a206dfe44eabded7fda87bab92b3ec499df9c6b344503933825b3c5e12444322bccb2a65594ff74b48b5061ff80d81b7473bfca10f4e656381f24e5ce9121d29d94c3f171f78edb57912137eef651743c8ce0d1a509929ed70b6bced56249bc585bd34775de3c0ff28e1cbd136a24f63a891e66773a2c44f59d285fde746afb54069456716fefa5ae10d76d36e2b850668c69fea228a604f095f3ad5b39b41ece202bc4e5c99bc5bb2d423548e639c1cb81e5a0b9344370f8890b8f209faa3453e7a660c4eb26f401496d01398db3177dd803017f6730fa0a2d533ebcad29ef77d96316f5bab65638b299c1cb8b05179195ec7d5f35eebdfa77ce23e9a614aa82eb3536dcd68267b32d770d70848838988c8d764729c7a96d050829d857139790291aacff3b3fdc09b671be10d1be92fce06844e905b0543d01b06393b579b6721c6eec6978f4e316c41f7594490cf7e3e1f715ceed1a3d766a1c00ea83e2be8e3caae98a3480ec3ce3be8347e0efb3f24f4be0ed2e740ed2d400dd36fe81f3921d6321073d0e0eced273eff1ad57e9650e2f434b2c9c368335df30600d15b95ab0d2cd4a311cefc10b6b7da8ae00213f88d81def1add5496b44d45f79aa40b64945c25058aee3eaf94e92aebeb43e382b0044015bc4bf1b261535550807f813eb4ebcf4421943cdf71f7eb094969ef08145550439f5d03bb8853f2a5ac39a50b0e746e9b7ab1d171838706ce1a651185b5f9ddfe338a2ae376695493499643705e12fb670a08185415295ea15b6327e75c8aebd688fa89a1ebbda00638a9a169c006bd9f8179d888dc8c62a1f4e3ec113f676714230205aa06c232981ddf08a2b293685eb81f6ab9b8ff249f65fd87ebf08b4bd4829452263bdb0e23cdda1ffab0a592487a81dd15dca6a2ee1df6a31d302dcc52c39f859400219d327626afe67f4b74fcee490719d71f66b13f9d9b9ececab313e8bc8285bd93d39a2d2b798b73052ad6e71e73af6762cce5109193d720f5ba768073baa8fb086b5263a833fa419d6081a6dccd4ed31602c14c4b6851eaa491d39fc4ac5bde6c95906bb2e5192621b3b29da4b92b74df2b82a7298831f3801990a5aa7b96cabd949d792cb2605d41021f8daf8ef3988320963242df88be68ccd387a39fd927cc609988caad629b01a8744790e45e41d261d80fc202145c73a42ed806677252f484ff514df82648169f6cb581631cbd7b3abd193cba73abd038f6b0b81910e03435903552f3874a12be1a85178221853fd7559f3922e46a1b08d4d9ca1467ecef53571c4f530987d90e7df7d97f97c2bcf188f442c0babdcb1c48b9d4b8fb56ebd75d49fc27103907d1b632a6ea9996c6b2a75fc16e714ef6c4c7b1e44e6ba50782c31b473df17337c36e39e8b273847b7a5b52e1f2889d94c41b14a0de43571fabbc4d686ccc284838dab1ce72cc8f95c9ca5709af8862d7315975d76a678f8f92d237218fae4d3f7f9a45cf2f0a06bb6787613d5ea58c01fc35d87a8add5742e69aceae976cfb74a53aa01ca984afdd104162a935766b9f9168d5bc94dd7317ced8e1128bcb580fb2fecaaafed579479f2fb964f6f9499dc7bedcb58ce047858c98333579ac9be12c9ce288a396c56f74e4f958caabea42da1843ff18a723863257fc19a0cc178ac72aad8c5bd201c8b43c8bcc0086a5b4f47f5e7b3cc6eb915923dcf6150678600e10d29305a165390514c5579f33d0940b708282ca48ecd1d94a85905641a5c9a697cdc48033d7ceccd818fd6684dc54b5ac62b00e6db00b8f9b2396006d7c614d1ffffd8a2fe0f5953b86be1b68062483cd611cd3e43562a059546cc386d78aa9b1f12d53c4c75b93e6a549693a7913f89a376e8337efe517ac4562da80ce61b9fa517832f2a5a2bbf72d27979a5d9a559842889c6e5504b569ce4b3d4ee045bdb3dc806c684b6818e2c748a32a7ad928bc851e068bf29e624f702d72ad9766bb142b682332f680f0e520d37e9a3a457c70c1539dc808e1f5093705cc7d772da914410ab3a55e6ac1a0d4d618a24dfe350889b3cd44cdeb7d19c74bf50e2e84e60bd4044149412408f3ad7a5f572e9248304dda16bf43c9d1d6af0d7dafdcb7aec4a5f9f3ce523924a0696ca2b03c653f15dfd635a25d1278c01091f20d8f71994c31abc03510a558f77f6f74fa215828eaa5724e007ee101161d125317c8403d8a9027537ad9f055addb3197ed566e20a9ed985c3238fbbad603de91f3bf6c656d1f4a6be3832cbab37e72e870502da000f635d23dca774b9220d49aa4f9d09e9e643cd9f34363965795188c7e670f7dfe7182bb582531afc0033a8546f9e7358c6a52d42475a16440feeef1d633945dd86ac31df12ac2ac304b0b5a1ed8d036560bd86114a6515d142611c4a1bb50df9f131d0e8274ce762d83b5cf3793e0ee21ec8c5062591136cb36a800fcee9f8280a8fb95fb690022eacd97e0c7b37d6d4212cf42c93d31f16b36ad3b1ca4cba3308c6719b3194216f1d35caa248b40393b76705aaf78098703c862f430cb93484e2e422d3afb609ef7bb38970c1ce53829464052e5827a45ce307d831389107f6760f4dbaa2b4334ee257da82093cf35d0f1ad375020d9271ea81e42108d43ff5dabc01370222086e2321bc5cdda4cbcc783f64a8eee6ac17af069b3dd723d31f324221280545702cbeffdc0f1bd291c49a0d2dc53fcd87d5c9e805097a29e5ce8ecf98123ac53041cb975d166b0fdded5240ad074f8fedaca7e7eb0e6f03583320b447a8548611c1623a03a0426d7d2e55191fc9d1695ad912760d09d170654b050336ae32e03dc7d3a00e7545d7322dd8500211e43cfe973e1d8e22e7f15d0a45de7356810914f19612276af5af71eb1c40cc87dad651b5c538ca0c81b6cff1572967ea1919c4cfe33e2b2dc60ac4e23a363517283bfc4ffcef6d1abbd63e43217e2489d76c92cc102bf93d6d5d2f6d256d45ebed08656f89fb833e4abd77ce66f46b7aee485e01fb53f4828df7e86f7fed9e09d190bb18d284a6e518e75c4f625ad4efc164430953036d1e67d2d77fb3407db1863859e3a38a4ecdbb65b1d975323ef3a1e965cff72f5221ebe0166074d7b89fc0d3aa90b6773a768994a9fad21d6056be5dbf589e02ef9901e631a6ea623b0a5f650f68b380ec2f0525abe9a2331395fef8ad03af316f92618be946fe6ccf0ba9567bc2e8a06b00138a416a20b6db747d3d973d96a07d10713a5dfe317bfee7f29f11482cf508e41e2f00ade509529c3052673a68f9b705e7216deb91d6d145b07bd14015dc615b5919fe0e463fe335a7b4296980c0dec87320c2f82d5a83a499f4ad4ddf7aabff4647c923ac5f3e0f1de90370fe2e4e3c9c9456e9cb3c351a23ec85cb16b13efc85741e89ba9009d4a97f89674dbea22618489ef3a5042cb55840cc55feded0986d7fd7fcc133a5b0b16e71e48c4c729c277adc9b87b767ad7c8d17aff1da76a42e5f321d08d5f1ed51131c0eb0099d4cfb6239db7d74428b635e6084a05dbf08853ce032e0dc97aba703319aa91f9f3b0b82b33c76ed07ae02b41169423cb80b3a8e968cddd99b65eec125dff5c0c6b69e98d668dcb904fad6445c17f8a1a0653d6b63e9dc316f0cc0619d2b84f139226e3273404f0671732b2f60c3f67e868bbd431a52597c8b479dd129f92660bca8b52cd7ddc1d3d73baf26ca1347713a6d0c2962071f876b7c066a96a7e0ea2ccd77ca5805cc2978149bc7de79cfcc5a71c942a650d8ea7ff3a288db12db9ae9841352a241dd8cd19443d5cbf5a9ddd69078f3f44d1d04498079892fce2227e886a6b39a8a7463c847f6981f79d05b204ddd0051ffb0bb5e3be5db4bfae7e4d081cad6977086ef0aef1ca4471f6a1f60cfbfcd055d09b35c28867dd160cf4795a6b4f2b5972760e5b85b0267dc1733a7c8ce695526a8da6173fc77f22a83352996d9fa53ad3aba365bf7d4ec75c887ad55aa2fb4969da94a04a67407e589acb962b6b9aa4e27ab6e165139840db73b5268f8d4e8b180bade215721a1f7187c45e469b21e662c389e6f8aaadd7ed512f866149d53ba4587387e15cde36a7eea5346b5c66b0b670f8e49605ddde8c22ec82aa1a4fb417cd45ccc47d666d67e18d82223dfca037075acfc4571e3313ec2307e66e6e297134769109e1874c585558f2a3b37773bfa0cb72cfeb107c53975d17a4e8c932b8071684a20e70602a058ad418d3e802fe9b692c3dfe2542b4244dc8c99e0a794b41c7420035afedfa6202b34d8caf31e2f04a3d476871d55cd78c45714de8741249e736634fa994ac9af96aea66aaad61b11ddf429d70387cb9079dc54802c4938d3f6fa8fb97d7bd709dc8638e330a8d86cb8e39e1557bdd4874f8532d20ce888fd58c16454380115f9c2856f3eac7a06fa384945f98d87bef9d9b9e514ee120d7591025f473738cb40cae3ff7867ea8e0fff80070d40e0a55efdba24fdf888d4c23f9cf442bb338884d765f39be17444b9858c6236b47f26d95c0c9cceaf7be8d60a733019eb2c7a22c77aeff61e326fd01fbfab2298830060a286580c76ad28db276357fa3a03095c82527dd88277bd9e4eb46cd47816fc7a0461095c1db70cafb90e81509f649cb55d612d371eed53b02df774c3a74524528f31085db554e9e3790d2b1b0834e43aef58f7aed77c89bb46eacb08e3700d199a395a08304f09f74224b0beed199003d237381d7b549a4d3357dab076b26401b395338cfea7b38774a39f8916a3235060a20dabd0a7872da97315b4c8ca51a30566c0ff2d9a9f6d3f927f16cb0afcf9ba1cb46bd54277eac06ec69dbb2a5c3a26d79192a3e7d310865492eae565e669f491b5146f7ea4ca4f89ec0b0145b0e908c641ee792d08478db21fee103287b09eb79b7fdeed28cf58dfc7815890adbd5219f9df209a93edeb5441b528766f9c871190cdb116792d82d1af533a48b9d19a6c32fc12746acbc9dfb473a99e2a39b797c986bd9f0bd5503ace6aa88a851f852aa35b8315863e27d5ab89d02d6d11914d54a3baeb94961d42b95841a6da49c5f2f77acb607e3ec450e7af7e25137f98ab7db53c748cf4ef07fb79e7c3328f4a847a663f96f95b6e998c49b3228762fb004646802a9dbbcff8370d12552e8907442f617552bc89ba676473ca09ba199668777b92975bf4f43dd0d9e395961512df50f12dd2d70c4bdf44d589e4f719ab38bfc42ce6045e9138fa2557c493c6999019f0c31fa95606347216de0f9ad2e43aaf3eabd3489909f0862dac831fdca3426418d612dd4c4b8a7f2320563bc936ccd592f14051c4b8a9f203fdb70432aefd621ea9fd7911631ac9e4d3de4a63bb2a543cbc5f97c2125bafeac99cd5b02671be7bd48aea389398e6b4ccc14e1d248d7b5c7ef5eb549e6b025a61561cb521613b5956d44c4d99cc6c4d30b76ed563518bb1164503c8e234fc826c75a19cdbbfe348306c58e37d292238825ffb026a442df8f795beb84609f441a27c222ff0f7d32bf0345ee6f15754b30cf441f7e3cd9437713f67853d496a22adbdbbcd38ba2e2d004f482b40c2dbed2ac13c2da64096a0fb573545bfaf0006ffb186abdfb41e186c198c7998e7f648d9e1ffc4ea9e139ef17aaba71647a9db6f9ae26d412a59dad9b407cfe721c39b0e2063939dfdff976dc34bce430fdedb5fb454de3953cf53334e473360287b1f0effeb85d739aec9d0fdf411a2e50429778c6cb283647507ac69e76f4368ceefe2b52626bfbad7dc94654b2884f49369e39037d199820d8d95375081612077165cab365daf77a03702a52db1ffcb40273ba71e24b72f62a7b15b553666ce041cf853c460f718300259b02995019386c20c436ffd044d5238db836db66095ba48068a9aea23cab380d1dc97598048cb9f718d83eeddb6ac4e490b4cf48c750038a3461865d9bf1dcc9cad0f842e3be0d8f4608bd15c609b3a4fc5bdf69f787bfb6bf54ecad5869a5fe7ae44d207509d1884e1a53dfa9aa82396c963c31ff2201efb249b6021c94b035d3f66dba3a233543428b9bea5464c3f52abc910796f20dae2ed215b708a725c74ca8f52a1abbaeeb77299e66f0773c03f76e7b277c4002517cd8e20f3fb3c83bf3df9599fdddac6ca13a66869bb8d47ef361e09f79a3a8eb100e00c1d3430861e138242a831b79ca8b647e9327814e2ca88346b2707b7515324432913e09c711426f886d377521a7009197b968026dc56878395a6406f1ffc619b0663713475701f8b29878f9236e6fe4da6691b7431e0d6d57359e8afd21ac13dca3763724720285d7096b36e0f8e5803dabbdbf66749d4d439a4c166d2d881870b6aa285ed5e56822b7ba50fda503221cbbc71192c4de07c614ef4dabcf1cb7ceaa82da9333bd6556c8bac05a8590182caf69ef1e0eb6cfcce9363f521ecc6f1b6370770d8fa693fa1e60d1c617d9556a84b51b6dc207882490dd3c8e1075f1a18c9c5098011f5205691bd8800b12b72b9a19129ea351a48b73dc7152b7f52ca817a7bf3df4a31b06108cedb05b734e4cdfdd5eeba592b3d5235fcd08f631bcc6c901874023aa8508a540d361353c13d0891c06ee18d1df3265edffde945d858bca737a8cf58536c4c612b4de355e41fb3f82f64d485a8d6393da43184af23c88de084a38b541769bf7541f3726066c3eb9e7cc40504ca64037407e88330873f139a40739051e34aedfacfbcf6de103e87aca98cc832b30a5abe3e57f0d8d1f0c1e507c622520816a013e5bfe5e558b011eccdbf2ca89b22079692c6d812289eaf73ebfedf45eed52d11df0b90ed62131bf038d5373764cae54e7d9da148a4d2c7b10f7377b0c53145c975483ef107287d5f9bfce4f58ab52c74d3e0be54bc13a2be7eee2d573486a521e091c61dea2bfcf62ecaede00cd38e9119131cbd010e2c92eb57720f80e794f44f2ce2ebc5e3e03894ba3fa228c17e8e165fe07c4e01b92599dfed06a844449b5caffffa7c4f17886edbd22e2345fc0b474a4b6e9142f43855623e3ca24f858604167e0201c2aadbc8a95b70c173aa7c2363d2d83b72e247e8783edc9ed9c5c977fd69f2f74b0e77e4a41c6d60e5b74a189c85ba33feb377a55b7a9320d222c561881e6722fb36ce7041e050e596a236a3d5cab739c0499aec6b41cfd97e05a7bfb55377329c217df528991d642c9f0ad70995026afb9a3234562220261c1bed71ea5d4cd827435f85af72d4c42af689fb258178890c8fb303f28bf5ef676546741ddb61fb7a49306957e88d2e43da558d3242c7fae889030bd8a4b2bedd2c7375873fb9ad63f2460b3583bd2b9ccf710574f95cf6562314907700f3d9ad89767aaf326d14cc87bc002793db25d44e5acd85095d18404c77e4d06e5ec718c75cab64d8355099d42ec5ae8336f9115cd940449f2f94a5b61e5f779148b8a0aab0197ae28a58ffd58b78085930159ece3f2dd2040b8c44545dde87a3306f2a620d4e7e1398feba033c97774f9252652a9e30f25507babb68fb33acf3d2927fb9f5022aa5ec62bf58072ed078ffd9039227a0c06f458c6370b2a410f683688adbc4a41e3f6437bdbb1c8ae9fbbb80426a2f2228ace052fbc16c0377c23e68d6184a0393303b49eace3ca1a776c237580041bbc98c089f7cabaa7029c350d02116fe3085bc6918460a1106a9cc2da5bb913a4f7d0d0ad15b319bcfd602d7bba476629b3a0e205ecfc32312c68584e0b3de57a7d6548d814783f37d4bc290dd0f7a68a2635d00362c07d3a62a77c37c09c3a0e7fed12c31de419d3925c1dc2afc5662208c05f48c1d2da6f5726543a824d96f3c9487c6660b1d8e38ee4f1e9198df8b76f83db273f85609ccba38889cb73b30deba68a9f4d8ceadc6dfc3479ce3627b9bef04c39a83172887c6f2ed143ca88b1e3f0e492ef4ed308bce762fec1fb4731845d3280620eaa62dc40c3b27cf1799089d0df8b929f808dda0e316d9b3999490ff7eb7fb2f8054e424a20371f975761c98d3a4cc247127d082fdd088b69eeb4251e2792ee04b4d12e8d4e8523f80ed081bd1913b558b93a91691a63c1c1b9f44eaa25e5c221139f8c476050a5c3f606f926f5265c475ef64507626fa5fda471b6e7b72c8e2f39de96c8a2ac7859a6fe361e7860842610791622de233223d5a473c1f9bc144eee4752e36ded71a24320e99148756827d67444f7388fc46e15d898863c9719555b9024ccfcd3edabbf8cc6c2839d9756ebe36d452062e503382088353ad3e58f97bb29e8511f1369814707e65f60f35605c65152b58eac0eab47e09d7005a82afd3a2843572dcbc50add45eea0b79ea1836034bc1364db89fa99ff009f6d121cb61f61fead3d0ede2d70e24d3e7190e2d2d41d39b07b8a01f6197e323d412a30c1087bebfe0de05c8f0f60ba4a81b35954dd33b606847db012149a90aae479c30397911c2b0a4e0c2b0fd4c88738baa4d5b4452ac7f774ac0aec27fdbdcb08337d6668365b16a696a594071af44a88a285bf584f453b925c99e84338b61db50937916f8bc46f5fd9496b53c1b18a6d34138f1fb9f6c1e53cdcea221d8a1941c506bbb0627f22f3cee937596e97a79f85f777d7ef6289eadd0d55bcbaf69c1f02bdde226d9a16a67739f4edd23b98d6a87328c2cb2dcde9837d42a33c05d670b7319d8607656dc6c9c6a7c3ee87fd900fae87c22a83f2ea6bc8f9150783d6130a0c3c7847f407a10535beeaf2b8537b3808fde3ea9b7d1b74bcf3174348c5e4b7aaf4c5c45d21b441cc32e71ad3d411ec7399d8ed31d86a70d7fd90e8d53d982e4009602bcf3d93a91627fd1b5e2926a5c02af47334e1a7b9e70291b399e208371c8869e8397d91b03cf9df4fae7bf8c227270c09faaf8376af6e33123e573c378769e205fd78b21cb2d7780c3b57f1da4f280b34cc219e4c632a0c6626a1b9d20e323cc4efd259597737f043944b5aeebcb98b90345d4d8cc6188a66bcf99bdc0ed7769391c99c399122b6ada42cf217960ae4ce155d49f028302846f01617d9026f0df56d6f33fa4c2b4fe025fc509e46c76770ea1f5380a4ea1e7933ecea109431828902afd4f8107bee1ce9f0e373fd7442dfd50de74f71d4790efd3eba522b63873915203b9668b8ff4610708009d8e894e9faca7141f242be75663c2dcaadffe4d158fd6b0f89c9fa245d9f71f7c9ec4771ffa09a231df7a90a1ec36c713aaff7492bf0e35b7d651936cf2a9f476650ec356caeb5c4525827f7f46a6e308d3053e200cb02e4527e0295eab7409cb77c3efafe54ffb830490a65d74b7bcd515bf15cff38a3913d9ca7e1ed80e89470bd0803b0490d942c6bc6da3e1f36933f78b64f5e94e2000550adddb5e4e3eb434cc10abb80eb2252f159fca401e35946304b0c614f7511bfd4c26534e9a5e6d5a8e2002551193a8f65e51bcff77dfc945979d4227b9221c23191c733a5b2b3ca539f817a726ea31c4056c9794e95bab82d475061c43b8cf6a3a4c62c23249b98cb8d3bc5f1417244ca49510df2e975bd71da31eaf4fac90a9e695b0db68169dfa5ca33</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> sec </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Windows10下WSL开发环境搭建</title>
      <link href="/2021/01/20/tipsWSL/"/>
      <url>/2021/01/20/tipsWSL/</url>
      
        <content type="html"><![CDATA[<p>工作环境的一架台式机是<code>Windows10</code>系统，<code>Windows</code>系统对开发者来说并不是很友好（<code>.net</code>及<code>Windows</code>内核开发者除外，比如一些扩展包，例如<code>PHP</code>的<code>swoole</code>，在<code>Windows</code>上现在没有直接安装的解决方案）。</p><span id="more"></span><p>刚开始一段时间(<code>WSL</code>没有出来那会，也不想用虚拟机和<code>Docker</code>)把台式机改成<code>Linux</code>系统，但是呢，各种办公软件在<code>Linux</code>平台就很糟心了，比如微信、QQ 这些软件，在<code>Linux</code>没有官方版本，通过黑科技进行移植的版本会出现各种故障，比如发送文档都得做磁盘空间共享，简直让人崩溃。</p><p>如果是纯粹只负责写代码的工作场景倒无所谓了，但是需要和客户、同事进行沟通，涉及到视频、音频、文件传输，简直炸毛。。。</p><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>某天装备升级强化了下，内存有<code>16G</code>，试着安装了<code>Windows</code>的<code>WSL</code>，这是微软自研的架构，为了兼容<code>Linux</code>内核。简单来讲就是<code>Windows</code>系统内置了一套<code>Linux</code>内核，直接做了系统间的映射。</p><h2 id="准备"><a class="markdownIt-Anchor" href="#准备"></a> 准备</h2><h3 id="材料"><a class="markdownIt-Anchor" href="#材料"></a> 材料</h3><ul><li>Windows10</li><li>wsl</li><li>Ubuntu18.appx</li></ul><h3 id="wsl-环境初始化"><a class="markdownIt-Anchor" href="#wsl-环境初始化"></a> WSL 环境初始化</h3><p>打开<code>Windows</code>自带的<code>power shell</code>终端，执行<code>Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux</code>命令，就在<code>Windows</code>上安装好了<code>wsl</code>环境。</p><p>接着下载一份<code>Ubuntu18.04</code>镜像，同样是在<code>power shell</code>终端执行命令<code>Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing</code>，当前目录路径下就会出现一个<code>Ubuntu</code>的<code>appx</code>软件，点击安装即可。</p><h3 id="ubuntu-配置"><a class="markdownIt-Anchor" href="#ubuntu-配置"></a> Ubuntu 配置</h3><p>点击安装<code>Ubuntu.appx</code>后，系统会弹出一个黑色窗口，提示你输入<code>unix</code>系统的用户名及密码，正常配置即可。</p><h4 id="修改镜像源"><a class="markdownIt-Anchor" href="#修改镜像源"></a> 修改镜像源</h4><p>我们需要把<code>Linux</code>系统的软件镜像地址改成国内的镜像地址，否则安装软件包会卡到你怀疑人生，我们先到网上搜索一下<code>Ubuntu18</code>国内镜像源（这里选用了阿里的镜像源），源链接如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># alibaba source list</span></span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiverse</span><br><span class="line">deb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse</span><br></pre></td></tr></table></figure><p>得到需要的源链接后，再到<code>Ubuntu</code>系统里更改源文件即可，命令操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先备份原文件</span></span><br><span class="line">sudo cp /etc/apt/source.list /etc/apt/source.list-back</span><br><span class="line"><span class="comment"># 再更改原文件</span></span><br><span class="line">sudo vim /etc/apt/source.list</span><br><span class="line"><span class="comment"># 将上面的源链接拷贝进来，再保存退出</span></span><br><span class="line"><span class="comment"># 更新系统的源包管理</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get upgrade -y</span><br></pre></td></tr></table></figure><p>这样，我们就配置好了国内镜像源。</p><h4 id="部署-nginx"><a class="markdownIt-Anchor" href="#部署-nginx"></a> 部署 nginx</h4><p><code>web</code>开发，一般<code>web</code>代理服务器选择<code>apache</code>或者<code>nginx</code>，这里讲<code>nginx</code>的部署，相应的操作命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装nginx，等待一段时间即可。</span></span><br><span class="line">sudo apt-get install nginx</span><br><span class="line"><span class="comment"># 创建我们的vhost文件夹</span></span><br><span class="line">mkdir ~/vhost</span><br><span class="line"><span class="comment"># 更改nginx配置</span></span><br><span class="line">sudo vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure><ul><li>在 include /etc/nginx/site-avaliable 下引入我们的 vhost 文件夹：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include /home/kirk/vhost/*.conf;</span><br></pre></td></tr></table></figure><ul><li>本地 hosts 配置下开发域名</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/hosts</span><br><span class="line"><span class="comment"># 增加一条指向记录</span></span><br><span class="line">127.0.0.1 api.kirk.com</span><br></pre></td></tr></table></figure><ul><li>编写 vhost 文件,如 vim ~/vhost/Kirk.conf</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># API 解析</span></span><br><span class="line">server &#123;</span><br><span class="line">    listen        80;</span><br><span class="line">    server_name  api.kirk.com;</span><br><span class="line">    <span class="comment"># 这里的项目地址是宿主机的项目地址，因为在Windows内置的Linux系统中，读取宿主机Windows文件的方式是使用挂载的模式，</span></span><br><span class="line">    <span class="comment"># 把Windows系统盘当成挂在盘进行处理，例如/mnt/d表示Windows的D盘，我们在D盘github/kirk文件夹下写了一个php文件，里面打印一个phpinfo();</span></span><br><span class="line">    root   <span class="string">&quot;/mnt/d/github/kirk&quot;</span>;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php index.html error/index.html;</span><br><span class="line">        <span class="keyword">if</span> (!-e <span class="variable">$request_filename</span>) &#123;</span><br><span class="line">            rewrite  ^(.*)$  /index.php?s=/<span class="variable">$1</span>  last;</span><br><span class="line">            <span class="built_in">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        autoindex  off;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    location ~ \.php(.*)$ &#123;</span><br><span class="line">        <span class="comment"># 记住这里fastcgi监听的是9004端口，后面配置php-fpm的时候会用到，因为fastcgi要和php-fpm端口保持统一</span></span><br><span class="line">        fastcgi_pass   127.0.0.1:9004;</span><br><span class="line">        fastcgi_index  index.php;</span><br><span class="line">        fastcgi_split_path_info  ^((?U).+\.php)(/?.+)$;</span><br><span class="line">        fastcgi_param  SCRIPT_FILENAME  $document_root<span class="variable">$fastcgi_script_name</span>;</span><br><span class="line">        fastcgi_param  PATH_INFO  <span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        fastcgi_param  PATH_TRANSLATED  $document_root<span class="variable">$fastcgi_path_info</span>;</span><br><span class="line">        include        fastcgi_params;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>保存完<code>conf</code>文件后，再执行<code>sudo service nginx reload</code>进行重载<code>nginx</code>的配置。</p><h4 id="安装-php"><a class="markdownIt-Anchor" href="#安装-php"></a> 安装 php</h4><p>这里选用了<code>php74</code>版本，具体命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先安装一个软件中心组件</span></span><br><span class="line">sudo apt-get install software-properties-common</span><br><span class="line"><span class="comment"># 再添加一个php的第三方源（因为官方源的php版本不大适用，一个是版本少，另一个是扩展包比较少）</span></span><br><span class="line">sudo add-apt-repository ppa:ondrej/php</span><br><span class="line"><span class="comment"># 再刷新一下包管理器</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 安装对应版本的php及扩展包，扩展包自行按需添加</span></span><br><span class="line">sudo apt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring php7.4-redis</span><br></pre></td></tr></table></figure><p>处理<code>php-fpm</code>，操作如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 修改php-fpm监听的端口，与nginx的fastcgi保持一致</span></span><br><span class="line">sudo vim /etc/php/74/fpm/pool.d/www.conf</span><br><span class="line"><span class="comment"># 找到listen = /run/php/php7.4-fpm.sock ,并改成下面的监听配置</span></span><br><span class="line">listen = 127.0.0.1:9004</span><br><span class="line"><span class="comment"># 修改保存成功后，重启php-fpm即可</span></span><br><span class="line">sudo service php7.4-fpm restart</span><br></pre></td></tr></table></figure><p>这样打开<code>Windows</code>的浏览器，访问我们刚刚配置的站点<code>http://api.kirk.com</code>，出现<code>php</code>版本信息即表示配置成功。</p><p>然后，看了下性能损耗，<code>Windows</code>基本的应用加上<code>wsl</code>共消耗<code>3G</code>内存，还是比集成软件<code>PHPstudy</code>节省了一丢丢内存，最主要的是以前<code>Windows</code>不能安装的扩展现在可以随意安装了~</p><p>再试着打开微信、企业微信、开发软件 IDE，好家伙，直接达到<code>8G</code>内存，平时半天没有回复你们信息不是故意不回，是电脑卡死了在等待。</p><h4 id="安装-python-环境"><a class="markdownIt-Anchor" href="#安装-python-环境"></a> 安装 python 环境</h4><p>单单只有一个<code>php</code>怎么玩数据呢，需要部署下<code>python</code>，<code>Ubuntu</code>自带了<code>python3</code>，但是我们需要按照不同项目做环境隔离，所以需要特殊处理下隔离软件的配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先看看Ubuntu有没有自带python3，执行如下命令</span></span><br><span class="line">python3</span><br><span class="line"><span class="comment"># 如果进入了python3操作界面，表示系统已安装，反之需要我们自己安装.</span></span><br><span class="line"><span class="comment"># 安装命令</span></span><br><span class="line">sudo apt-get install python3</span><br><span class="line"><span class="comment"># 验证是否安装pip 包管理器</span></span><br><span class="line">pip3 -V</span><br><span class="line"><span class="comment"># 如果没有出现pip3的版本信息，代表系统没有安装，需要我们手动安装</span></span><br><span class="line">sudo apt-get install pip3</span><br><span class="line"><span class="comment"># 安装好了之后，开始安装python虚拟环境</span></span><br><span class="line">sudo pip3 install virtualenv</span><br><span class="line">sudo pip3 install virtualenvwrapper</span><br><span class="line"><span class="comment"># 配置包引导</span></span><br><span class="line">sudo vim ~/.bashrc</span><br><span class="line"><span class="comment"># 在最后加上这几条命令，分别表示1.虚拟环境的工作目录。2.虚拟包用python3进行驱动。3.加载虚拟包执行脚本。</span></span><br><span class="line"><span class="built_in">export</span> WORKON_HOME=<span class="variable">$HOME</span>/.virtualenvs</span><br><span class="line"><span class="built_in">export</span> VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3</span><br><span class="line"><span class="built_in">source</span> ~/.<span class="built_in">local</span>/bin/virtualenvwrapper.sh</span><br><span class="line"><span class="comment"># 保存退出后</span></span><br><span class="line"><span class="built_in">source</span> ~/.bashrc</span><br><span class="line"><span class="comment"># 这样python虚拟环境管理包就配置好了，我们可以用如下命令创建对应的虚拟环境</span></span><br><span class="line">mkvirtualenv -p python3 Kirk</span><br><span class="line"><span class="comment"># 退出python虚拟环境</span></span><br><span class="line">deactive</span><br><span class="line"><span class="comment"># 删除对应虚拟环境</span></span><br><span class="line">rmvirtualenv Kirk</span><br></pre></td></tr></table></figure><p>这样通过<code>virtualenvwrapper</code>进行管理<code>python</code>的虚拟环境，从而实现不同的项目使用不同的<code>python</code>包管理。</p><p>其他的环境配置会陆续更新，to be continue…</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>DiyExpress - 自定义表达式计算引擎</title>
      <link href="/2020/12/09/devDiyExpress/"/>
      <url>/2020/12/09/devDiyExpress/</url>
      
        <content type="html"><![CDATA[<p>我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。</p><p>比如有个场景，当我们将数据分析的”自主权“交给用户。</p><span id="more"></span><p>由用户来决定自己需要计算分析什么维度的数据，这个需求确实是一个痛点，能解决这个需求，不就是为用户创造了价值么。</p><p>因此，花了点时间写了一套自定义表达式计算引擎。<br />已知用户是有一定<code>Excel</code>公式基础的，需要提供一个交互界面让他输入他定义的类似<code>Excel</code>公式的一段简单公式，其中的各个参数是自定义表单中各个字段所填充的数据。如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;销售返现&#125;&#125;=if ( &#123;&#123;数量&#125;&#125; &gt;= 100 AND (&#123;&#123;产品类型&#125;&#125; == &#x27;产品A&#x27; OR &#123;&#123;产品类型&#125;&#125; == &#x27;产品B&#x27;), &#123;&#123;成单金额&#125;&#125; <span class="emphasis">* 0.7, &#123;&#123;成单金额&#125;&#125;*</span>0.5) + 100</span><br></pre></td></tr></table></figure><p>双花括号里面的是指定的字段（用来代表该字段的取值 <code>data</code>），单引号或者双引号是指定的取值。</p><p>我们的目标是程序根据用户定义的公式计算对应的数据，那么核心点在于如何识别用户定义的公式。</p><p>依旧是被“自定义”给坑了，需要识别用户定义的公式只能上一个词法分析器了，根据大三学的编译原理，徒手撸个状态机。。</p><p>考虑到能用脚本语言就用脚本语言，技术选型用的<code>PHP</code>,源码放在 <code>github</code> 上，<a href="https://github.com/ClanceyHuang/DiyExpress" title="https://github.com/ClanceyHuang/DiyExpress">DiyExpress</a>。</p><h2 id="贮备知识点"><a class="markdownIt-Anchor" href="#贮备知识点"></a> 贮备知识点</h2><h3 id="ast-节点树"><a class="markdownIt-Anchor" href="#ast-节点树"></a> AST 节点树</h3><p><code>AST (Abstract Syntax Tree(抽象语法树))</code> 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（<code>Node</code>）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： <code>Identifier(标识符)</code>，<code>BinaryExpression(二元表达式)</code>，<code>VariableDeclaration(变量定义)</code>，<code>FunctionDeclaration(函数定义)</code>等。</p><p><code>AST</code> 是编译器看的。编译器会将源码转化成 <code>AST</code>。如下源码:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addA</span>(<span class="params">d</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> c = addA(<span class="number">2</span>) + b;</span><br></pre></td></tr></table></figure><p>会换转化成这样的 <code>AST</code>:</p><p><img src="/images/diyRule01.png" alt="ast" title="ast" /></p><h3 id="ast-的使用场景"><a class="markdownIt-Anchor" href="#ast-的使用场景"></a> AST 的使用场景？</h3><p><code>TypeScript</code>、<code>babel</code>、<code>webpack</code>、<code>vue-cli</code>等都是依赖<code>AST</code>进行开发的。</p><p>通过<code>AST</code>，可以将代码转化后，再输出。比如：</p><ul><li>代码压缩。删除没用的空格，未使用的语句，变量名替换等。</li><li>代码高亮。</li><li>将 <code>ES6</code> 代码转换成 <code>ES5</code> 代码。</li><li>给 <code>CSS</code> 中的某些属性加浏览器前缀<code>-webkit-</code>。</li><li>将 <code>CSS</code> 中的<code>px</code>转化成<code>rem</code>。</li><li>生成代码。最近用了<code>ANT DESIGN PRO</code>。 <code>ANT DESIGN PRO</code> 中的 <code>umi</code> 可以在生成页面的代码和路由时，修改路由配置的<code>js</code>。<code>umi</code> 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过 <code>AST</code> 来转换代码。</li></ul><h3 id="需要学习-ast-的哪些知识"><a class="markdownIt-Anchor" href="#需要学习-ast-的哪些知识"></a> 需要学习 <code>AST</code> 的哪些知识？</h3><ol><li><p>了解 <code>AST</code> 常见节点的结构</p><p>了解 <code>AST</code> 常见节点的结构推荐通读下<code>AST node</code> 规范。</p></li><li><p>源码解析</p><p>将源码转化为<code>AST</code>。该步骤分为词法分析（<code>Lexical Analysis</code>）和 语法分析（<code>Syntactic Analysis</code>）。<br />解析 <code>JavaScript</code> 可以用<code>@babel/parser</code>(以前叫 <code>Babylon</code>)。</p></li><li><p>转换</p><p>在遍历<code>AST</code>时，对指定的<code>AST</code>节点做新增，修改或删除操作。<br />转换可以用<code>@babel/traverse</code>。<br />创建和验证节点可以用<code>@babel/types</code>。创建<code>AST</code>节点代码示例见这里。</p></li><li><p>生成目标代码</p></li></ol><p>将上一步转换过的<code>AST</code>，转化为目标代码，并生成源码映射（<code>source maps</code>）。<br />生成目标代码可以用<code>@babel/generator</code></p><p>To be continue…</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Window10下双系统grub修复</title>
      <link href="/2020/03/15/tipsDoubleSystem/"/>
      <url>/2020/03/15/tipsDoubleSystem/</url>
      
        <content type="html"><![CDATA[<p>起因是我的笔记本<code>window10</code>在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入<code>Linux</code>系统时提示<code>Unknown filesystem</code>。</p><span id="more"></span><p>首先能确定的是<code>Linux</code>的引导读取出了问题，才进入到了<code>grub rescue</code>模式。如果记得自己的<code>Linux</code>引导安装在哪个区块可以直接重新读取引导（这个得看你安装双系统的时候，把<code>Linux</code>的引导装在哪个分区），如果不记得，就执行下面的命令输出<code>gpt</code>分区</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls</span><br></pre></td></tr></table></figure><p>这样会显示出你所有的分区，再一个一个试试下面的命令（我的引导安装在<code>gpt7</code>区块上）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls (hd0,gpt7)\boot\grub</span><br></pre></td></tr></table></figure><p>其他不是引导所在的分区都是提示<code>error: unknown filesystem</code>。找到了所在的分区会提示该目录下的文件目录。<br />假定你们也是<code>(hd0,gpt7)</code>分区，依次执行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> root=(hd0,gpt7),</span><br><span class="line"><span class="built_in">set</span> prefix=(hd0,gpt7)/boot/grub</span><br><span class="line">insmod normal,</span><br><span class="line">normal</span><br></pre></td></tr></table></figure><p>执行完毕会进入<code>Linux</code>启动的图形界面。<br />进入<code>Linux</code>系统后，打开终端执行以下命令重新安装<code>grub</code>引导：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo update-grub</span><br><span class="line">sudo grub-install /dev/sda</span><br></pre></td></tr></table></figure><p>再重启，就能恢复到正常<code>Linux</code>的启动引导了。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>自定义表单设计及实现方案</title>
      <link href="/2020/02/03/devDiyForm/"/>
      <url>/2020/02/03/devDiyForm/</url>
      
        <content type="html"><![CDATA[<p>如何设计一款高度自定义的表单系统？<br /><code>自定义</code>意味着<code>表单数量不确定</code>，每个表单<code>字段数量不确定</code>，每个字段<code>类型不确定</code>，<code>存储量不确定</code>，等等一切都是<code>未知</code>的。</p><span id="more"></span><p>以及之后如何建立索引，如何搜索定位指定的数据？这些问题都将在下面的方案中进行解答。</p><h3 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h3><p>为了实现某个比较<code>脑洞大开</code>的需求，建立自定义表单，而且，还限定了前置条件—技术选型不许复杂，数据存储只能基于<code>mysql</code>, So…</p><h3 id="所谓的自定义表设计"><a class="markdownIt-Anchor" href="#所谓的自定义表设计"></a> 所谓的“自定义”（表设计）</h3><p>我们会定义这么几张表，用来实现自定义模板的大致框架。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">diy<span class="emphasis">_field_</span>pool      字段池（我们定义好的字段类型）</span><br><span class="line">diy<span class="emphasis">_form            表单表（记录用户自定义的表单）</span></span><br><span class="line"><span class="emphasis">diy_</span>form<span class="emphasis">_field      表单字段表（记录某张表单中有哪些字段）</span></span><br><span class="line"><span class="emphasis">diy_</span>form<span class="emphasis">_entity     表单实例表（记录某张表单中的某条数据实例）</span></span><br><span class="line"><span class="emphasis">diy_</span>form<span class="emphasis">_data       表单数据表（记录某张表单在某条实例下，哪些字段对应的数据）</span></span><br></pre></td></tr></table></figure><h4 id="系统初始化字段池"><a class="markdownIt-Anchor" href="#系统初始化字段池"></a> 系统初始化字段池</h4><p>我们提供一批预定义的字段类型，初始化数据到<code>diy_field_pool</code>表中，用户也能自己定义自己的字段池。</p><h4 id="用户创建自定义表单"><a class="markdownIt-Anchor" href="#用户创建自定义表单"></a> 用户创建自定义表单</h4><p>用户通过选用字段池（<code>diy_field_pool</code>表）中提供的字段，创建一张自定义表单，表单的属性信息记录在<code>diy_form</code>表中，表单包含的字段（从字段池中选好的字段）记录在<code>diy_form_field</code>表中。这样用户就创建了一张自定义表单。</p><h4 id="用户填写表单"><a class="markdownIt-Anchor" href="#用户填写表单"></a> 用户填写表单</h4><p>用户使用创建好的表单填写数据，每新增一条数据，在<code>diy_form_entity</code>表就会新增一条记录，该表单中有几个<code>field</code>，就会同时在<code>diy_form_data</code>表中新增几条 <code>data</code> 数据。数据结构关系如下图所示：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">diy<span class="emphasis">_form    ------ diy_</span>enity</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|---diy<span class="emphasis">_field       |---diy_</span>data</span><br><span class="line">|                   |</span><br><span class="line">|...</span><br></pre></td></tr></table></figure><h3 id="如何进行数据搜索"><a class="markdownIt-Anchor" href="#如何进行数据搜索"></a> 如何进行数据搜索</h3><p>数据存储结构中，最终保存数据的地方其实是<code>data表</code>，但是，<code>data表</code>的辅助字段有<code>form表id</code>，<code>field表id</code>，<code>entity表id</code>，只有一个<code>content</code>字段是记录真实信息的，那么，如何搭建索引体系呢？</p><h4 id="采用-sphinx"><a class="markdownIt-Anchor" href="#采用-sphinx"></a> 采用 Sphinx</h4><p>构建<code>Sphinx</code>的<code>sql</code>语句时，将<code>data表</code>的<code>id</code>作为文档<code>id</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"># 公共的自定义模板的数据源</span><br><span class="line">source diyCommonSource</span><br><span class="line">&#123;</span><br><span class="line">    type            = mysql</span><br><span class="line">    sql_db          = diy</span><br><span class="line">    sql_host        = 127.0.0.1</span><br><span class="line">    sql_port        = 3306</span><br><span class="line">    sql_user        = root</span><br><span class="line">    sql_pass        = root</span><br><span class="line">    sql_query_pre   = SET NAMES utf8</span><br><span class="line"></span><br><span class="line">    sql_query   = \</span><br><span class="line">        select \</span><br><span class="line">        dfd.id, \</span><br><span class="line">        dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \</span><br><span class="line">        dff.id as field_id,dff.sys_id,dff.field, \</span><br><span class="line">        df.id as form_id \</span><br><span class="line">    from diy_form_data as dfd \</span><br><span class="line">        inner join diy_form_field as dff on dff.form_id=dfd.form_id and dff.is_delete=0 \</span><br><span class="line">        inner join diy_form as df on df.id=dff.form_id and df.is_delete=0 \</span><br><span class="line">    where dfd.is_delete=0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 公共的自定义模板的索引</span><br><span class="line">index diyCommonIndex</span><br><span class="line">&#123;</span><br><span class="line">    source          = diyCommonSource</span><br><span class="line">    path            = /var/local/diy/sphinx/data/diyCommonIndex</span><br><span class="line">    docinfo         = extern</span><br><span class="line">    #charset_type   = zh_cn.utf-8</span><br><span class="line">    charset_type    = utf-8</span><br><span class="line">    min_word_len    = 1</span><br><span class="line">    ngram_len       = 1</span><br><span class="line">    ngram_chars     = U+3000..U+2FA1F</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 范围：新闻模板（假定form_type为1）</span><br><span class="line">source news:diyCommonSource</span><br><span class="line">&#123;</span><br><span class="line">    sql_query    = \</span><br><span class="line">        select \</span><br><span class="line">            dfd.id, \</span><br><span class="line">            dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \</span><br><span class="line">            dff.id as field_id,dff.sys_id,dff.field, \</span><br><span class="line">            df.id as form_id \</span><br><span class="line">        from pre_diy_form_data as dfd \</span><br><span class="line">            inner join pre_diy_form_field as dff \</span><br><span class="line">                and dff.form_id=dfd.form_id \</span><br><span class="line">                and dff.sys_id&gt;0 and dff.is_delete=0 \</span><br><span class="line">            inner join pre_diy_form as df \</span><br><span class="line">                and df.id=dff.form_id \</span><br><span class="line">                and df.is_delete=0 \</span><br><span class="line">                and df.form_type=1 \</span><br><span class="line">        where dfd.is_delete=0</span><br><span class="line"></span><br><span class="line">    # 使用sql_attr设置的字段(搜索条件)，只能作为属性，使用SphinxClient::SetFilter()进行过滤；</span><br><span class="line">    # 未被设置的字段，自动作为全文检索的字段，使用SphinxClient::Query(&quot;搜索字符串&quot;)进行全文搜索</span><br><span class="line">    # sql_query第一列id需为整数，且被系统使用，无需再设置sql_attr_uint</span><br><span class="line">    sql_attr_uint       = form_id</span><br><span class="line">    sql_attr_uint       = field_id</span><br><span class="line">    sql_attr_uint       = field</span><br><span class="line">    sql_attr_uint       = entity_id</span><br><span class="line">    sql_attr_timestamp  = createat</span><br><span class="line">    sql_attr_timestamp  = updateat</span><br><span class="line">&#125;</span><br><span class="line"># 构造商品模板的数据索引</span><br><span class="line">index news:diyCommonIndex</span><br><span class="line">&#123;</span><br><span class="line">    source  = news</span><br><span class="line">    path    = /var/local/diy/sphinx/data/news</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>其中，如果需要指定查找某些字段的数据，那么，以上面的数据源再重新定义数据源，<code>sql</code> 语句进一步指定 <code>field</code> 表的某个标志字段即可。</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>验证码识别</title>
      <link href="/2019/05/10/devCrack/"/>
      <url>/2019/05/10/devCrack/</url>
      
        <content type="html"><![CDATA[<p>通过训练卷积模型，让程序自动识别验证码。</p><span id="more"></span><h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2><p>运营人员审核某些用户提交的资质证书的时候，需要到规定的公示网站上去查询证书，大致操作是这些：</p><ol><li>到公示网站填写对应信息（证书编号等）</li><li>填写验证码（每次查询都会有校验码或者短信验证等等）</li><li>查看查询结果并比对证书<br />这一套流程下来，无疑是加大了审核员的工作量，而且每天审核的不止一张证书。一个比较迫切的需求就诞生了，<strong>根据不同证书种类，分别去自动获取公示网站上该证书的信</strong>。</li></ol><p>假定以教师资质证书为例，该公示站点查询信息时，需要输入证书编号，图片验证码，即可返回该证书所对应的信息，运营人员比对用户上传的证书和站点公示的证书即可。</p><h2 id="方案一"><a class="markdownIt-Anchor" href="#方案一"></a> 方案一</h2><p>现在方案一是在我们自己的审核后台，将所有的数据（查询时需要的证书编号、姓名等等）都提取出来，封装成一个 <code>post</code> 请求数据，并将公示网站的验证码获取过来，在审核后台只留一个验证码的输入框给审核人员，输入正确的验证码，追加到 <code>post</code> 请求中，即可进行查询（该过程中会话交互验证的破解思路请自行摸索），将返回的数据结果进行切割处理，以比较好的交互方式呈现给运营人员。运营人员剩下的工作只要 <code>check</code> 一下信息即可。</p><p>ps：方案一的背后其实还进行了另一步操作，只要查询成功，就将这张验证码图片保存到本地服务器，运营人员输入的验证码作为图片名（这一步是关键，因为需要大量的训练样本进行模型训练，为方案二做铺垫）。</p><h2 id="方案二"><a class="markdownIt-Anchor" href="#方案二"></a> 方案二</h2><p>等一段时间后，将方案一保存下来的这批图片数据作为训练样本，去训练模型，也就是方案二，当模型的准确率达到了 <code>0.9</code> 以上，就可以实际拿过来使用了。（可能会说为什么不自动生成相似的验证码来进行训练，这也是一个思路，但准确率没有拿目标样本作为训练样本来的高，因为我们是不知道对方验证码的生成规则的，只能仿出一个大概相似的验证码。）</p><p>方案二部署上线的时候，只要用户提交了相关的证书信息，我们的系统就自动去公示网站上查询数据并将结果保存到数据库，这样运营人员只要在审核后台核对查询结果即可，也不用再输入验证码了。</p><p>为了更好的兼容，之前方案一预留的手动填写验证码功能也不会删减掉，防止出现系统无法自动识别验证码、获取不到查询数据的情况。这样如果系统自动查询到了数据运营人员就能直接审核，没有查询到数据，运营人员还能手动查一遍进行确认，同时还收集了验证码的训练样本。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>方案二是在方案一使用一段时间后才能进行的，因为我们需要大量的训练样本，如果特意通过人工去获取数据（验证码图片）并打标签（每张图片所代表的验证码），无疑是会浪费很大的人力资源。<br />这样在方案一阶段，审核人员还是进行常规的审核操作，就顺便收集了对应的训练数据。等到执行案案二，就将审核员彻底解放出来，在需求（审核功能、上线时间）、成本（时间、人力）、技术实现（样本获取）上目前应该是最优解了。</p><h2 id="补充"><a class="markdownIt-Anchor" href="#补充"></a> 补充</h2><p>其实同时还是做了高仿目标站点的验证码，争取做到大致相同。然后<code>tensorflow</code>训练后的识别率达到<code>0.9</code>左右估计就差不多了。</p><p><a href="https://github.com/ClanceyHuang/AutoCraw" title="github.com/ClanceyHuang/AutoCraw">源码</a></p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python封装Kafka客户端</title>
      <link href="/2019/04/20/devKafka/"/>
      <url>/2019/04/20/devKafka/</url>
      
        <content type="html"><![CDATA[<p>业务上处理<code>Kafka</code>主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在<code>Python</code>中封装一个比较好用的<code>Kafka</code>客户端。</p><span id="more"></span><p>no bb, show code.直接上代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># encoding: utf-8</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> pykafka <span class="keyword">import</span> KafkaClient</span><br><span class="line">reload(sys)</span><br><span class="line">sys.setdefaultencoding(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaTaskException</span>(<span class="params">Exception</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    在这里自定义KafkaTask类的异常</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ParameterError</span>(<span class="params">KafkaTaskException</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数异常错误</span></span><br><span class="line"><span class="string">    _ParameterError_Key: 当 key 类型错误的时的抛错.</span></span><br><span class="line"><span class="string">    _ParameterError_Topic: 当 topic 类型错误的时的抛错.</span></span><br><span class="line"><span class="string">    _ParameterError_Consumer: 当初始化init_consumer 使用了错误的参数时抛错.</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    _ParameterError_Key = <span class="string">&quot;ParameterError- type(s) for &#x27;Key&#x27;: must be bytes&quot;</span></span><br><span class="line">    _ParameterError_Topic = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes&quot;</span></span><br><span class="line">    _ParameterError_pykafka_Consumer = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes; &quot;</span> \</span><br><span class="line">                                       <span class="string">&quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot;</span> \</span><br><span class="line">                                       <span class="string">&quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot;</span></span><br><span class="line">    _ParameterError_kafka_Consumer = <span class="string">&quot;ParameterError- type(s) for &#x27;topic&#x27;: must be str; &quot;</span> \</span><br><span class="line">                                     <span class="string">&quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot;</span> \</span><br><span class="line">                                     <span class="string">&quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KafkaTask</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    封装一个pykafka的客户端方法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, server</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        :param server: str类型</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.server = server</span><br><span class="line">        self.client = KafkaClient(hosts=server)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_producer</span>(<span class="params">self, topic</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        初始化Kafka生产者</span></span><br><span class="line"><span class="string">        :param topic:Type --&gt; bytes `Produce msg what topic You want`.</span></span><br><span class="line"><span class="string">        :raises ParameterError: 当topic不是bytes类型时抛错.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_Topic)</span><br><span class="line">        topic = self.client.topics[topic]</span><br><span class="line">        self.producer = topic.get_producer(sync=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_consumer_pykafka</span>(<span class="params">self, topic, group_id, offset_type</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Init Kafka Consumer by pykafka</span></span><br><span class="line"><span class="string">        :param topic:Type --&gt; bytes `Consumer msg what topic You want`.</span></span><br><span class="line"><span class="string">        :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`.</span></span><br><span class="line"><span class="string">        :param offset_type:Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic`</span></span><br><span class="line"><span class="string">        :raises ParameterError: When use error Parameter to init init_consumer.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">bytes</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(group_id, <span class="built_in">str</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(offset_type, <span class="built_in">str</span>) <span class="keyword">or</span> offset_type <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;LATEST&quot;</span>, <span class="string">&quot;EARLIEST&quot;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_pykafka_Consumer)</span><br><span class="line">        <span class="keyword">from</span> pykafka.simpleconsumer <span class="keyword">import</span> OffsetType</span><br><span class="line">        _OffsetType = &#123;<span class="string">&quot;LATEST&quot;</span>: OffsetType.LATEST, <span class="string">&quot;EARLIEST&quot;</span>: OffsetType.EARLIEST&#125;</span><br><span class="line">        topic = self.client.topics[topic]</span><br><span class="line">        self.consumer = topic.get_simple_consumer(auto_commit_enable=<span class="literal">True</span>, auto_commit_interval_ms=<span class="number">1</span>,</span><br><span class="line">                                                  consumer_id=group_id, auto_offset_reset=_OffsetType[offset_type],</span><br><span class="line">                                                  reset_offset_on_start=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">init_consumer_kafka</span>(<span class="params">self, topic, group_id, offset_type</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Init Kafka Consumer by kafka-python</span></span><br><span class="line"><span class="string">        :param topic: Type --&gt; str `Consumer msg what topic You want`.</span></span><br><span class="line"><span class="string">        :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`.</span></span><br><span class="line"><span class="string">        :param offset_type: Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic`</span></span><br><span class="line"><span class="string">        :raises ParameterError: When use error Parameter to init init_consumer.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">from</span> kafka <span class="keyword">import</span> KafkaConsumer</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(topic, <span class="built_in">str</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(group_id, <span class="built_in">str</span>) \</span><br><span class="line">                <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(offset_type, <span class="built_in">str</span>) <span class="keyword">or</span> offset_type <span class="keyword">not</span> <span class="keyword">in</span> [<span class="string">&quot;LATEST&quot;</span>, <span class="string">&quot;EARLIEST&quot;</span>]:</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_kafka_Consumer)</span><br><span class="line"></span><br><span class="line">        self.consumer = KafkaConsumer(bootstrap_servers=self.server,</span><br><span class="line">                                      auto_offset_reset=offset_type,</span><br><span class="line">                                      group_id=group_id,</span><br><span class="line">                                      )</span><br><span class="line">        self.consumer.subscribe(topics=topic.split(<span class="string">&#x27;,&#x27;</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pull</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Get info from Kafka Consumer by kafka-python</span></span><br><span class="line"><span class="string">        Poll Parameters:</span></span><br><span class="line"><span class="string">            timeout_ms: Type --&gt; int `Interval between each piece of data`.</span></span><br><span class="line"><span class="string">            max_records: Type --&gt; int `The amount of data per batch of data`</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">return</span> self.consumer.poll(timeout_ms=<span class="number">0</span>, max_records=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">send_message</span>(<span class="params">self, msg, key</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        Send MSG by this func</span></span><br><span class="line"><span class="string">        :param msg: Type --&gt; bytes or str `Message to broker`.</span></span><br><span class="line"><span class="string">        :param key: Type --&gt; bytes `Producer msg what key You want,You can see the key when you receiving data`.</span></span><br><span class="line"><span class="string">        :raises ParameterError: when error type for key.</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(key, <span class="built_in">bytes</span>):</span><br><span class="line">            <span class="keyword">raise</span> ParameterError(ParameterError._ParameterError_Key)</span><br><span class="line">        produce_msg = msg.encode() <span class="keyword">if</span> <span class="built_in">isinstance</span>(msg, <span class="built_in">str</span>) <span class="keyword">else</span> msg</span><br><span class="line">        self.producer.produce(produce_msg, partition_key=key)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>任务分配算法</title>
      <link href="/2019/01/27/devTaskAssign/"/>
      <url>/2019/01/27/devTaskAssign/</url>
      
        <content type="html"><![CDATA[<p>在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。</p><span id="more"></span><p>ps：需求变了，所有的都平均分了，因为运营人员不需要根据审核量进行绩效考核了，多劳多得变成大锅饭了。也白设计了这套算法，无所谓了，就当周末刷了会数独游戏吧，反正闲着也是闲着。</p><p>假设现在有 <code>n</code> 个任务需要分配给 <code>m</code> 个审核员去完成，但是每个审核员手头上还有未完成的任务，且未完成的任务数不同。那么如何均匀的把这些任务分配给各个审核员？这里我想出了一种基于平均思想的任务分配算法。</p><p>该算法的主要思想是：首先找出所有的审核员中手头未完成任务数量最大的审核员，然后其他审核员以该审核员的未完成任务数为参考数，计算自己可容纳的任务数，最后所有审核员可容纳的任务数之和即为总的可容纳任务数。</p><p>这里存在两种情况，第一种是：总的可容纳任务数小于或等于 <code>n</code> 个待分配的任务数，此时所有的审核员以最大未完成任务数 <code>max_task</code> 为参考数，接收待分配的任务。如果刚好分配完，那么算法结束；如果还有剩余任务未分配，那么将剩下的任务抽取 <code>m</code> 个任务分配给每一位审核员，以此类推，直到剩下的未分配任务数小于 <code>m</code> 位置，然后将这小于 m 的任务随机分配相应数量的审核员。<br />第二种情况是：总的可容纳任务数大于 <code>n</code> 个待分配的任务数，此时降低一个单位的参考数(<code>max_task-1</code>)，然后循环计算可容纳的任务数，知道退出循环（循环终止条件为：<code>ava_task - task_num &lt;= lower_List.size()</code>,<code>lower_List.size()</code>表示的是低于当前参考数的审核员数）。</p><p>接下来，我们将通过一个简单的例子来说明算法的流程，由于第一种情况比较简单，因此，该例子是基于第二种情况的，如图 1 所示.<br /><img src="/images/task-assign-01.png" alt="图1" title="图1" /></p><p>假设有 <code>20</code> 个任务需要分配给 <code>8</code> 个审核员(对应 <code>8</code> 个条形图，蓝色条形图对应的数字代表该审核员手头未完成的任务数)。<br />首先找出者八个审核员收中未完成任务书的最大值 <code>max_task=7</code>，然后个审核员已 <code>max_task</code> 为参考数计算各自可容纳的任务数(绿色条形图对应的数字)，总的可容纳任务数为所有审核员可容纳的任务数之和，及 <code>ava_task=6+3+4+2+5+0+5+6</code>,有图 1 可知，<code>lower_List.size()=7</code>,由 <code>31-20&gt;7</code>，因此，可降低一个单位的参数数，即 <code>max_task=max_task-1=6</code>，如图 2 所示。<br /><img src="/images/task-assign-02.png" alt="图2" title="图2" /></p><p>那么，<code>ava_task=5+2+3+1+4+0+4+5=24</code>，<code>lower_List.size()=7</code>，由于 <code>24-20&lt;7</code>，因此循环终止。<br />由于可容纳的任务数仍然大于待分配的任务数，因此需要再降低一个单位的参考数(一定要考虑这种情况)，<code>max_task=max_task-1=5</code>，此时 <code>ava_task=4+1+2+0+3+0+3+4=17</code>，<code>lower_List.size()=6</code>，剩余待分配任务数为 <code>20-17=3</code>，然后将这 <code>3</code> 个任务随机分配给低于当前参考数的 <code>6</code> 个审核员中的 <code>3</code> 个，每个审核员分配一个。<br />当然算法中还考虑了很多种情况，具体请参见如下代码。由于任务一般按审核员 <code>ID</code> 来分配，且 <code>ID</code> 一般为字符串。为了存储方便，我定义了一个二维字符串类型的数组 <code>rev_task[i][j]</code>来存储数据，<code>i</code> 表示第 <code>i</code> 个审核员，<code>rev_task[i][0]</code>存放的是第 i 个审核员的 <code>ID</code>，<code>rev_task[i][1]</code>存放的是第 <code>i</code> 个审核员当前未完成的任务数，<code>rev_task[i][2]</code>存放的是第 <code>i</code> 个审核员应当被分配的任务数。</p><h2 id="算法工具类-algorithmutilsjava"><a class="markdownIt-Anchor" href="#算法工具类-algorithmutilsjava"></a> 算法工具类-AlgorithmUtils.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.audit.allocationAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgorithmUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">taskAllocation</span><span class="params">(<span class="keyword">int</span> task_num, <span class="keyword">int</span> rev_num, String[][] rev_task)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; rdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获得审核人员中的最大未完成任务数</span></span><br><span class="line">        <span class="keyword">int</span> max_task = Integer.parseInt(rev_task[<span class="number">0</span>][<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rev_num; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(max_task &lt; Integer.parseInt(rev_task[i][<span class="number">1</span>]))</span><br><span class="line">                max_task = Integer.parseInt(rev_task[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//以最大待审核任务数为参考数，判断第一轮可容纳的任务数</span></span><br><span class="line">        <span class="keyword">int</span> ava_task = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; lower_List = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ava_task += (max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                lower_List.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> task_rest;</span><br><span class="line">        <span class="keyword">int</span> task_avg;</span><br><span class="line">        <span class="comment">//第一种情况：第一轮可容纳的任务数小于待分配的任务数</span></span><br><span class="line">        <span class="keyword">if</span>(ava_task - task_num &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rev_num; i++) &#123;</span><br><span class="line">                rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">            task_rest = task_num-ava_task;</span><br><span class="line">            task_avg = task_rest/rev_num;</span><br><span class="line">            <span class="keyword">if</span>(task_rest != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(task_avg &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rev_num; i++) &#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[i][<span class="number">2</span>])+task_avg);</span><br><span class="line">                    &#125;</span><br><span class="line">                    task_rest -= rev_num*task_avg;</span><br><span class="line">                    task_avg = task_rest/rev_num;</span><br><span class="line">                &#125;</span><br><span class="line">                rdList.removeAll(rdList);</span><br><span class="line">                <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                    temp = rd.nextInt(rev_num);</span><br><span class="line">                    <span class="keyword">if</span>(!rdList.contains(temp))&#123;</span><br><span class="line">                        rdList.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                    rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//第二种情况：第一轮可容纳的任务数大于待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，直到退出循环</span></span><br><span class="line">            <span class="keyword">while</span>(ava_task - task_num &gt; lower_List.size()) &#123;</span><br><span class="line">                max_task--;</span><br><span class="line">                ava_task = <span class="number">0</span>;</span><br><span class="line">                lower_List.removeAll(lower_List);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">                    rev_task[i][<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">                    <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                        ava_task += Integer.parseInt(rev_task[i][<span class="number">2</span>]);</span><br><span class="line">                        lower_List.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ava_task - task_num &gt; <span class="number">0</span>) &#123;<span class="comment">//如果可容纳的任务数大于待分配的任务数，那么需要再再降低一个单位的参考数</span></span><br><span class="line">                max_task--;</span><br><span class="line">                ava_task = <span class="number">0</span>;</span><br><span class="line">                lower_List.removeAll(lower_List);</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>((max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>])) &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        rev_task[i][<span class="number">2</span>] = String.valueOf(max_task-Integer.parseInt(rev_task[i][<span class="number">1</span>]));</span><br><span class="line">                        ava_task += Integer.parseInt(rev_task[i][<span class="number">2</span>]);</span><br><span class="line">                        lower_List.add(i);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                task_rest = task_num - ava_task;</span><br><span class="line">                rdList.removeAll(rdList);</span><br><span class="line">                <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                    temp = rd.nextInt(rev_num);</span><br><span class="line">                    <span class="keyword">if</span>((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123;</span><br><span class="line">                        rdList.add(temp);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                    rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                task_rest = task_num-ava_task;</span><br><span class="line">                <span class="keyword">if</span>(task_rest != <span class="number">0</span>) &#123;</span><br><span class="line">                    rdList.removeAll(rdList);</span><br><span class="line">                    <span class="keyword">while</span>(rdList.size() &lt; (task_rest+<span class="number">1</span>))&#123;</span><br><span class="line">                        temp = rd.nextInt(rev_num);</span><br><span class="line">                        <span class="keyword">if</span>((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123;</span><br><span class="line">                            rdList.add(temp);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; task_rest; i++) &#123;</span><br><span class="line">                        rev_task[rdList.get(i)][<span class="number">2</span>] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][<span class="number">2</span>])+<span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录被分配的任务数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            rev_task[i][<span class="number">1</span>] = String.valueOf(Integer.parseInt(rev_task[i][<span class="number">1</span>])+Integer.parseInt(rev_task[i][<span class="number">2</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="算法测试类-testalgorithmjava"><a class="markdownIt-Anchor" href="#算法测试类-testalgorithmjava"></a> 算法测试类-TestAlgorithm.java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.audit.allocationAlgorithm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Random;</span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAlgorithm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入任务数：&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> task_num = sc.nextInt();</span><br><span class="line">        System.out.println(<span class="string">&quot;请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：&quot;</span>);</span><br><span class="line">        String inputString=sc.next().toString();</span><br><span class="line">        String stringArray[]=inputString.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> rev_num = stringArray.length;<span class="comment">//审核人员总数</span></span><br><span class="line">        String[][] rev_task =<span class="keyword">new</span> String[rev_num][<span class="number">3</span>];</span><br><span class="line">        Random rd = <span class="keyword">new</span> Random();</span><br><span class="line">        List&lt;Integer&gt; rdList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        rdList.removeAll(rdList);</span><br><span class="line">        <span class="keyword">int</span> temp;</span><br><span class="line">        <span class="keyword">while</span>(rdList.size() &lt; (rev_num+<span class="number">1</span>))&#123;</span><br><span class="line">            temp = rd.nextInt(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">if</span>(!rdList.contains(temp))&#123;</span><br><span class="line">                rdList.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;算法前的任务分配：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            rev_task[i][<span class="number">0</span>] = String.valueOf(rdList.get(i) + <span class="number">1</span>);</span><br><span class="line">            rev_task[i][<span class="number">1</span>]= stringArray[i];</span><br><span class="line">            rev_task[i][<span class="number">2</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">            System.out.print(rev_task[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+rev_task[i][<span class="number">1</span>]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line"></span><br><span class="line">        AlgorithmUtils.taskAllocation(task_num, rev_num, rev_task);<span class="comment">//调用算法工具类</span></span><br><span class="line">        System.out.println(<span class="string">&quot;算法后的任务分配：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;rev_num;i++)&#123;</span><br><span class="line">            System.out.print(rev_task[i][<span class="number">0</span>]+<span class="string">&quot;,&quot;</span>+rev_task[i][<span class="number">1</span>]+<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">请输入任务数：</span><br><span class="line">20</span><br><span class="line">请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：</span><br><span class="line">1,4,3,5,2,7,2,1</span><br><span class="line">算法前的任务分配：</span><br><span class="line">72,1 63,4 73,3 49,5 74,2 43,7 100,2 20,1</span><br><span class="line">算法后的任务分配：</span><br><span class="line">72,5 63,5 73,5 49,6 74,5 43,7 100,6 20,6</span><br></pre></td></tr></table></figure><p>由运行结果可知，20 个任务均衡的分配给了每个审核人员，达到了平均分配的目的！</p>]]></content>
      
      
      <categories>
          
          <category> dev </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python可视化绘图</title>
      <link href="/2019/01/25/tipsPythonMatplotlib/"/>
      <url>/2019/01/25/tipsPythonMatplotlib/</url>
      
        <content type="html"><![CDATA[<p><code>Matplotlib</code>是一个<code>Python</code>的绘图库，粗略理解为<code>py</code>集成<code>MATLAB</code>的功能包。以前学数学建模的时候很讨厌<code>MATLAB</code>，情愿用<code>C</code>来写算法都不想学<code>MATLAB</code>，现在没得法，工作需要分析一些数据，还好<code>Python</code>有这些相关的库，要不然真的要去研究下<code>MATLAB</code>了。</p><span id="more"></span><h3 id="简单图形绘制"><a class="markdownIt-Anchor" href="#简单图形绘制"></a> 简单图形绘制</h3><p>根据坐标点绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">10</span>,<span class="number">15</span>])</span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;r&#x27;</span>)<span class="comment"># 折线 1 x 2 y 3 color</span></span><br><span class="line">plt.plot(x,y,<span class="string">&#x27;g&#x27;</span>,lw=<span class="number">10</span>)<span class="comment"># 4 line w</span></span><br><span class="line"><span class="comment"># 折线 饼状 柱状</span></span><br><span class="line">x = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">y = np.array([<span class="number">13</span>,<span class="number">25</span>,<span class="number">17</span>,<span class="number">36</span>,<span class="number">21</span>,<span class="number">16</span>,<span class="number">10</span>,<span class="number">15</span>])</span><br><span class="line">plt.bar(x,y,<span class="number">0.2</span>,alpha=<span class="number">1</span>,color=<span class="string">&#x27;b&#x27;</span>)<span class="comment"># 5 color 4 透明度 3 0.9</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-1.png" alt="根据坐标点绘制" title="根据坐标点绘制" /></p><p>传入参数是 numpy 数组时的效果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">15</span>):</span><br><span class="line">    <span class="comment"># 1 柱状图</span></span><br><span class="line">    dateOne = np.zeros([<span class="number">2</span>])</span><br><span class="line">    dateOne[<span class="number">0</span>] = i;</span><br><span class="line">    dateOne[<span class="number">1</span>] = i;</span><br><span class="line">    y = np.zeros([<span class="number">2</span>])</span><br><span class="line">    y[<span class="number">0</span>] = <span class="number">10</span></span><br><span class="line">    y[<span class="number">1</span>] = <span class="number">20</span></span><br><span class="line">    plt.plot(dateOne,y,<span class="string">&#x27;r&#x27;</span>,lw=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-2.png" alt="传入参数是numpy数组时的效果" title="传入参数是numpy数组时的效果" /></p><p>根据函数图像绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从-1-----1之间等间隔采66个数.也就是说所画出来的图形是66个点连接得来的</span></span><br><span class="line"><span class="comment"># 注意：如果点数过小的话会导致画出来二次函数图像不平滑</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>,<span class="number">66</span>)</span><br><span class="line"><span class="comment"># 绘制y=2x+1函数的图像</span></span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制x^2函数的图像</span></span><br><span class="line">y = x**<span class="number">2</span></span><br><span class="line">plt.plot(x, y)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><img src="/images/matlab01-3-1.png" alt="根据函数图像绘制" title="根据函数图像绘制" /></p><p><img src="/images/matlab01-3-2.png" alt="根据函数图像绘制" title="根据函数图像绘制" /></p><h3 id="figure-的简单使用"><a class="markdownIt-Anchor" href="#figure-的简单使用"></a> figure 的简单使用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 1</span></span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 2</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># figure 3，指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型</span></span><br><span class="line"><span class="comment">#一个坐标轴上画了两个图形</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line">plt.figure(num = <span class="number">5</span>, figsize = (<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>一共会画出三张图，前两张和上面的简单案例画出来的两张一样。<br /><img src="/images/matlab02-1-1.png" alt="figure的简单使用" title="figure的简单使用" /><br /><img src="/images/matlab02-1-2.png" alt="figure的简单使用" title="figure的简单使用" /><br /><img src="/images/matlab02-1-3.png" alt="figure的简单使用" title="figure的简单使用" /></p><h3 id="设置坐标轴"><a class="markdownIt-Anchor" href="#设置坐标轴"></a> 设置坐标轴</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的lable</span></span><br><span class="line"><span class="comment">#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码</span></span><br><span class="line">plt.xlabel(<span class="string">u&#x27;这是x轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">u&#x27;这是y轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x坐标轴刻度, 之前为0.25, 修改后为0.5</span></span><br><span class="line"><span class="comment">#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了</span></span><br><span class="line">plt.xticks(np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-1.png" alt="设置坐标轴" title="设置坐标轴" /></p><p>上面代码的基础上加上下面代码（直接加载最后一句代码前面即可）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-2.png" alt="设置坐标轴" title="设置坐标轴" /></p><p>如果在上面代码的最后一句之前加上下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设置坐标轴label的大小，背景色等信息</span></span><br><span class="line"><span class="keyword">for</span> label <span class="keyword">in</span> ax.get_xticklabels() + ax.get_yticklabels():</span><br><span class="line">    label.set_fontsize(<span class="number">12</span>)</span><br><span class="line">    label.set_bbox(<span class="built_in">dict</span>(facecolor = <span class="string">&#x27;green&#x27;</span>, edgecolor = <span class="string">&#x27;None&#x27;</span>, alpha = <span class="number">0.7</span>))</span><br></pre></td></tr></table></figure><p><img src="/images/matlab03-3.png" alt="设置坐标轴" title="设置坐标轴" /></p><h3 id="设置-legend-图例"><a class="markdownIt-Anchor" href="#设置-legend-图例"></a> 设置 legend 图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">设置坐标轴</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">50</span>)</span><br><span class="line">y1 = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y1)</span><br><span class="line">plt.plot(x, y2, color = <span class="string">&#x27;red&#x27;</span>, linewidth = <span class="number">1.0</span>, linestyle = <span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的取值范围</span></span><br><span class="line">plt.xlim((-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.ylim((<span class="number">0</span>, <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴的lable</span></span><br><span class="line"><span class="comment">#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码</span></span><br><span class="line">plt.xlabel(<span class="string">u&#x27;这是x轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(<span class="string">u&#x27;这是y轴&#x27;</span>,fontproperties=<span class="string">&#x27;SimHei&#x27;</span>,fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x坐标轴刻度, 之前为0.25, 修改后为0.5</span></span><br><span class="line"><span class="comment">#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了</span></span><br><span class="line">plt.xticks(np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># 获取当前的坐标轴, gca = get current axis</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line"><span class="comment"># 设置右边框和上边框</span></span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x坐标轴为下边框</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置y坐标轴为左边框</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line"><span class="comment"># 设置x轴, y周在(0, 0)的位置</span></span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab04-1.png" alt="设置legend图例" title="设置legend图例" /></p><h3 id="添加注解和绘制点以及在图形上绘制线或点"><a class="markdownIt-Anchor" href="#添加注解和绘制点以及在图形上绘制线或点"></a> 添加注解和绘制点以及在图形上绘制线或点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">添加注解和绘制点以及在图形上绘制线或点</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制普通图像</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, <span class="number">50</span>)</span><br><span class="line">y = <span class="number">2</span> * x + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将上、右边框去掉</span></span><br><span class="line">ax = plt.gca()</span><br><span class="line">ax.spines[<span class="string">&#x27;right&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;top&#x27;</span>].set_color(<span class="string">&#x27;none&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置x轴的位置及数据在坐标轴上的位置</span></span><br><span class="line">ax.xaxis.set_ticks_position(<span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;bottom&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"><span class="comment"># 设置y轴的位置及数据在坐标轴上的位置</span></span><br><span class="line">ax.yaxis.set_ticks_position(<span class="string">&#x27;left&#x27;</span>)</span><br><span class="line">ax.spines[<span class="string">&#x27;left&#x27;</span>].set_position((<span class="string">&#x27;data&#x27;</span>, <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义(x0, y0)点</span></span><br><span class="line">x0 = <span class="number">1</span></span><br><span class="line">y0 = <span class="number">2</span> * x0 + <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制(x0, y0)点</span></span><br><span class="line">plt.scatter(x0, y0, s = <span class="number">50</span>, color = <span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制虚线</span></span><br><span class="line">plt.plot([x0, x0], [y0, <span class="number">0</span>], <span class="string">&#x27;k--&#x27;</span>, lw = <span class="number">2.5</span>)</span><br><span class="line"><span class="comment"># 绘制注解一</span></span><br><span class="line">plt.annotate(<span class="string">r&#x27;$2 * x + 1 = %s$&#x27;</span> % y0, xy = (x0, y0), xycoords = <span class="string">&#x27;data&#x27;</span>, xytext = (+<span class="number">30</span>, -<span class="number">30</span>), \</span><br><span class="line">             textcoords = <span class="string">&#x27;offset points&#x27;</span>, fontsize = <span class="number">16</span>, arrowprops = <span class="built_in">dict</span>(arrowstyle = <span class="string">&#x27;-&gt;&#x27;</span>, connectionstyle = <span class="string">&#x27;arc3, rad = .2&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制注解二</span></span><br><span class="line">plt.text(-<span class="number">3</span>, <span class="number">3</span>, <span class="string">r&#x27;$Test\ text. \mu \sigma_i, \alpha_i$&#x27;</span>, fontdict = &#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">16</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;red&#x27;</span>&#125;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab05-1.png" alt="添加注解和绘制点以及在图形上绘制线或点" title="添加注解和绘制点以及在图形上绘制线或点" /></p><h3 id="绘制散点图"><a class="markdownIt-Anchor" href="#绘制散点图"></a> 绘制散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制散点图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据个数</span></span><br><span class="line">n = <span class="number">1024</span></span><br><span class="line"><span class="comment"># 均值为0, 方差为1的随机数</span></span><br><span class="line">x = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line">y = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算颜色值</span></span><br><span class="line">color = np.arctan2(y, x)</span><br><span class="line"><span class="comment"># 绘制散点图</span></span><br><span class="line">plt.scatter(x, y, s = <span class="number">75</span>, c = color, alpha = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">plt.xlim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line">plt.ylim((-<span class="number">1.5</span>, <span class="number">1.5</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不显示坐标轴的值</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab06-1.png" alt="绘制散点图" title="绘制散点图" /></p><h3 id="绘制柱状图"><a class="markdownIt-Anchor" href="#绘制柱状图"></a> 绘制柱状图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制柱状图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">10</span></span><br><span class="line">x = np.arange(n)</span><br><span class="line"><span class="comment"># 生成数据, 均匀分布(0.5, 1.0)之间</span></span><br><span class="line">y1 = (<span class="number">1</span> - x / <span class="built_in">float</span>(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line">y2 = (<span class="number">1</span> - x / <span class="built_in">float</span>(n)) * np.random.uniform(<span class="number">0.5</span>, <span class="number">1.0</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制柱状图, 向上</span></span><br><span class="line">plt.bar(x, y1, facecolor = <span class="string">&#x27;blue&#x27;</span>, edgecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图, 向下</span></span><br><span class="line">plt.bar(x, -y2, facecolor = <span class="string">&#x27;green&#x27;</span>, edgecolor = <span class="string">&#x27;white&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">temp = <span class="built_in">zip</span>(x, y2)</span><br><span class="line"><span class="comment"># 在柱状图上显示具体数值, ha水平对齐, va垂直对齐</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">zip</span>(x, y1):</span><br><span class="line">    plt.text(x + <span class="number">0.05</span>, y + <span class="number">0.1</span>, <span class="string">&#x27;%.2f&#x27;</span> % y, ha = <span class="string">&#x27;center&#x27;</span>, va = <span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> temp:</span><br><span class="line">    plt.text(x + <span class="number">0.05</span>, -y - <span class="number">0.1</span>, <span class="string">&#x27;%.2f&#x27;</span> % y, ha = <span class="string">&#x27;center&#x27;</span>, va = <span class="string">&#x27;bottom&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置坐标轴范围</span></span><br><span class="line">plt.xlim(-<span class="number">1</span>, n)</span><br><span class="line">plt.ylim(-<span class="number">1.5</span>, <span class="number">1.5</span>)</span><br><span class="line"><span class="comment"># 去除坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab07-1.png" alt="绘制柱状图" title="绘制柱状图" /></p><h3 id="绘制登高线图"><a class="markdownIt-Anchor" href="#绘制登高线图"></a> 绘制登高线图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制登高线图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义等高线高度函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">x, y</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="number">1</span> - x / <span class="number">2</span> + x ** <span class="number">5</span> + y ** <span class="number">3</span>) * np.exp(- x ** <span class="number">2</span> - y ** <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line"><span class="comment"># 定义x, y</span></span><br><span class="line">x = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n)</span><br><span class="line">y = np.linspace(-<span class="number">3</span>, <span class="number">3</span>, n)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格数据</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充等高线的颜色, 8是等高线分为几部分</span></span><br><span class="line">plt.contourf(X, Y, f(X, Y), <span class="number">8</span>, alpha = <span class="number">0.75</span>, cmap = plt.cm.hot)</span><br><span class="line"><span class="comment"># 绘制等高线</span></span><br><span class="line">C = plt.contour(X, Y, f(X, Y), <span class="number">8</span>, colors = <span class="string">&#x27;black&#x27;</span>, linewidth = <span class="number">0.5</span>)</span><br><span class="line"><span class="comment"># 绘制等高线数据</span></span><br><span class="line">plt.clabel(C, inline = <span class="literal">True</span>, fontsize = <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去除坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab08-1.png" alt="绘制登高线图" title="绘制登高线图" /></p><h3 id="绘制-image"><a class="markdownIt-Anchor" href="#绘制-image"></a> 绘制 Image</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制Image</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义图像数据</span></span><br><span class="line">a = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">9</span>).reshape(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 显示图像数据</span></span><br><span class="line">plt.imshow(a, interpolation = <span class="string">&#x27;nearest&#x27;</span>, cmap = <span class="string">&#x27;bone&#x27;</span>, origin = <span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加颜色条</span></span><br><span class="line">plt.colorbar()</span><br><span class="line"><span class="comment"># 去掉坐标轴</span></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab09-1.png" alt="绘制Image" title="绘制Image" /></p><h3 id="绘制-3d-图形"><a class="markdownIt-Anchor" href="#绘制-3d-图形"></a> 绘制 3D 图形</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">绘制3d图形</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"><span class="comment"># 将figure变为3d</span></span><br><span class="line">ax = Axes3D(fig)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据数目</span></span><br><span class="line">n = <span class="number">256</span></span><br><span class="line"><span class="comment"># 定义x, y</span></span><br><span class="line">x = np.arange(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line">y = np.arange(-<span class="number">4</span>, <span class="number">4</span>, <span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成网格数据</span></span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算每个点对的长度</span></span><br><span class="line">R = np.sqrt(X ** <span class="number">2</span> + Y ** <span class="number">2</span>)</span><br><span class="line"><span class="comment"># 计算Z轴的高度</span></span><br><span class="line">Z = np.sin(R)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制3D曲面</span></span><br><span class="line">ax.plot_surface(X, Y, Z, rstride = <span class="number">1</span>, cstride = <span class="number">1</span>, cmap = plt.get_cmap(<span class="string">&#x27;rainbow&#x27;</span>))</span><br><span class="line"><span class="comment"># 绘制从3D曲面到底部的投影</span></span><br><span class="line">ax.contour(X, Y, Z, zdim = <span class="string">&#x27;z&#x27;</span>, offset = -<span class="number">2</span>, cmap = <span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置z轴的维度</span></span><br><span class="line">ax.set_zlim(-<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab10-1.png" alt="绘制3D图形" title="绘制3D图形" /></p><h3 id="subplot-绘制多图"><a class="markdownIt-Anchor" href="#subplot-绘制多图"></a> subplot 绘制多图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">subplot绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第三个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第四个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab11-1-1.png" alt="subplot绘制多图" title="subplot绘制多图" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">subplot绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制第一个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第二个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第三个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"><span class="comment"># 绘制第四个图</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab11-1-2.png" alt="subplot绘制多图" title="subplot绘制多图" /></p><h3 id="figure-绘制多图"><a class="markdownIt-Anchor" href="#figure-绘制多图"></a> figure 绘制多图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第一个子图的句柄, 第一个子图跨度为1行3列, 起点是表格(0, 0)</span></span><br><span class="line">ax1 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">0</span>, <span class="number">0</span>), colspan = <span class="number">3</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax1.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第二个子图的句柄, 第二个子图跨度为1行3列, 起点是表格(1, 0)</span></span><br><span class="line">ax2 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">0</span>), colspan = <span class="number">2</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax2.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第三个子图的句柄, 第三个子图跨度为1行1列, 起点是表格(1, 2)</span></span><br><span class="line">ax3 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">2</span>), colspan = <span class="number">1</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax3.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure分成3行3列, 取得第四个子图的句柄, 第四个子图跨度为1行3列, 起点是表格(2, 0)</span></span><br><span class="line">ax4 = plt.subplot2grid((<span class="number">3</span>, <span class="number">3</span>), (<span class="number">2</span>, <span class="number">0</span>), colspan = <span class="number">3</span>, rowspan = <span class="number">1</span>)</span><br><span class="line">ax4.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab12-1-1.png" alt="figure绘制多图" title="figure绘制多图" /><br />或</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure绘制多图</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib.gridspec <span class="keyword">as</span> gridspec</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="comment"># 分隔figure</span></span><br><span class="line">gs = gridspec.GridSpec(<span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">ax1 = plt.subplot(gs[<span class="number">0</span>, :])</span><br><span class="line">ax2 = plt.subplot(gs[<span class="number">1</span>, <span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line">ax3 = plt.subplot(gs[<span class="number">1</span>, <span class="number">2</span>])</span><br><span class="line">ax4 = plt.subplot(gs[<span class="number">2</span>, :])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">ax1.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax1.set_title(<span class="string">&#x27;Test&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax3.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">ax4.plot([<span class="number">0</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab12-1-2.png" alt="figure绘制多图" title="figure绘制多图" /></p><h3 id="figure-图的嵌套"><a class="markdownIt-Anchor" href="#figure-图的嵌套"></a> figure 图的嵌套</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">figure图的嵌套</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">y = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%</span></span><br><span class="line">left, bottom, width, height = <span class="number">0.1</span>, <span class="number">0.1</span>, <span class="number">0.8</span>, <span class="number">0.8</span></span><br><span class="line"><span class="comment"># 获得绘制的句柄</span></span><br><span class="line">ax1 = fig.add_axes([left, bottom, width, height])</span><br><span class="line"><span class="comment"># 绘制点(x,y)</span></span><br><span class="line">ax1.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax1.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax1.set_title(<span class="string">&#x27;test&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套方法一</span></span><br><span class="line"><span class="comment"># figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%</span></span><br><span class="line">left, bottom, width, height = <span class="number">0.2</span>, <span class="number">0.6</span>, <span class="number">0.25</span>, <span class="number">0.25</span></span><br><span class="line"><span class="comment"># 获得绘制的句柄</span></span><br><span class="line">ax2 = fig.add_axes([left, bottom, width, height])</span><br><span class="line"><span class="comment"># 绘制点(x,y)</span></span><br><span class="line">ax2.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">ax2.set_ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">ax2.set_title(<span class="string">&#x27;part1&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 嵌套方法二</span></span><br><span class="line">plt.axes([bottom, left, width, height])</span><br><span class="line">plt.plot(x, y, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;part2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab13-1.png" alt="figure图的嵌套" title="figure图的嵌套" /></p><h3 id="主次坐标轴"><a class="markdownIt-Anchor" href="#主次坐标轴"></a> 主次坐标轴</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">主次坐标轴</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">10</span>, <span class="number">0.1</span>)</span><br><span class="line">y1 = <span class="number">0.05</span> * x ** <span class="number">2</span></span><br><span class="line">y2 = -<span class="number">1</span> * y1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig, ax1 = plt.subplots()</span><br><span class="line"><span class="comment"># 得到ax1的对称轴ax2</span></span><br><span class="line">ax2 = ax1.twinx()</span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">ax1.plot(x, y1, <span class="string">&#x27;g-&#x27;</span>)</span><br><span class="line">ax2.plot(x, y2, <span class="string">&#x27;b--&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置label</span></span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;X data&#x27;</span>)</span><br><span class="line">ax1.set_xlabel(<span class="string">&#x27;Y1&#x27;</span>, color = <span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">ax2.set_xlabel(<span class="string">&#x27;Y2&#x27;</span>, color = <span class="string">&#x27;b&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="/images/matlab14-1.png" alt="主次坐标轴" title="主次坐标轴" /></p><h3 id="创建动画"><a class="markdownIt-Anchor" href="#创建动画"></a> 创建动画</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">动画</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> animation</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义figure</span></span><br><span class="line">fig, ax = plt.subplots()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x = np.arange(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">0.01</span>)</span><br><span class="line"><span class="comment"># line, 表示只取返回值中的第一个元素</span></span><br><span class="line">line, = ax.plot(x, np.sin(x))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义动画的更新</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">i</span>):</span></span><br><span class="line">    line.set_ydata(np.sin(x + i/<span class="number">10</span>))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义动画的初始值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span>():</span></span><br><span class="line">    line.set_ydata(np.sin(x))</span><br><span class="line">    <span class="keyword">return</span> line,</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建动画</span></span><br><span class="line">ani = animation.FuncAnimation(fig = fig, func = update, init_func = init, interval = <span class="number">10</span>, blit = <span class="literal">False</span>, frames = <span class="number">200</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示动画</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 动画保存</span></span><br><span class="line"><span class="comment">#我这里是保存为html文件了，打开即可完美运行</span></span><br><span class="line">ani.save(<span class="string">&#x27;sin.html&#x27;</span>, writer = <span class="string">&#x27;imagemagick&#x27;</span>, fps = <span class="number">30</span>, dpi = <span class="number">100</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/matlab15-1.png" alt="创建动画" title="创建动画" /></p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>逆向笔记梳理</title>
      <link href="/2018/10/10/noteReverseEnfineering/"/>
      <url>/2018/10/10/noteReverseEnfineering/</url>
      
        <content type="html"><![CDATA[<p>先把大纲列出来，有空就慢慢更新完善。</p><span id="more"></span><h2 id="x86-与-x64"><a class="markdownIt-Anchor" href="#x86-与-x64"></a> x86 与 x64</h2><p><code>x86</code>是基于<code>intel 8086</code>处理器的小端（<code>little-endian</code>）体系结构（<code>IA-32</code>的<code>32位</code>实现），他在两种操作模式下执行</p><ul><li>实模式：处理机刚刚上电后只支持 <code>16</code> 位指令集的状态。</li><li>保护模式：处理机支持虚拟内存、分页及其他功能的状态。<br />该体系的<code>64位</code>扩展称为<code>x64</code>或<code>x86-64</code>，<code>x86</code>通过一种称为环级别(<code>ring level</code>)的抽象来支持特权隔离(<code>privilege separation</code>)。</li></ul><h3 id="寄存器组与数据类型"><a class="markdownIt-Anchor" href="#寄存器组与数据类型"></a> 寄存器组与数据类型</h3><p>运行于保护模式下的<code>x86</code>体系结构有 8 个<code>32位</code>通用寄存器(<code>General Purpose Registers, GPR</code>):<code>EAX</code>、<code>EBX</code>、<code>ECX</code>、<code>EDX</code>、<code>EDI</code>、<code>ESI</code>、<code>EBP</code>、<code>ESP</code>。这些寄存器还能进一步分化成<code>8位</code>和<code>16位</code>寄存器。指令指针存储在<code>EIP</code>寄存器中。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">31  23  15  7   0</span><br><span class="line">|       EAX     |</span><br><span class="line">|   |   |   AX  |</span><br><span class="line">|   |   |AH |AL |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EBP     |       |       ESP     |</span><br><span class="line">|       |   BP  |       |       |   SP  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       ESI     |       |       EDI     |</span><br><span class="line">|       |   SI  |       |       |   DI  |</span><br><span class="line"></span><br><span class="line">31  23  15  7   0       31  23  15  7   0</span><br><span class="line">|       EIP     |       |       EFLAGS  |</span><br></pre></td></tr></table></figure><table><thead><tr><th style="text-align:left">寄存器</th><th style="text-align:left">用途</th></tr></thead><tbody><tr><td style="text-align:left">ECX</td><td style="text-align:left">循环计数</td></tr><tr><td style="text-align:left">ESI</td><td style="text-align:left">字符串/内存操作的源</td></tr><tr><td style="text-align:left">EDI</td><td style="text-align:left">字符串/内存操作中的目标</td></tr><tr><td style="text-align:left">EBP</td><td style="text-align:left">帧基指针</td></tr><tr><td style="text-align:left">ESP</td><td style="text-align:left">栈指针</td></tr></tbody></table><p>常用的数据类型有以下几种：</p><ul><li>字节(Byte): 8 位，比如 AL、BL、CL。</li><li>字(Word): 16 位，比如 AX、BX、CX。</li><li>双字(Double Word): 32 位，比如 EAX、EBX、ECX。</li><li>四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。</li></ul><p><code>32位</code>寄存器<code>EFLAGS</code>用于存储运算状态以及其他运行状态（比如陷阱标志位）。</p><p>除了通用寄存器、<code>EIP</code>和<code>EFLAGS</code>，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：<code>CR0</code>寄存器控制分页机制的开关，<code>CR2</code>寄存器中保存着导致缺页异常发生的线性地址，<code>CR3</code>是分页数据结构的基地址，<code>CR4</code>控制硬件虚拟化设置。<code>DR0～DR7</code>寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点<code>DR0～DR3</code>，其余寄存器用于保存状态）</p><h3 id="指令集"><a class="markdownIt-Anchor" href="#指令集"></a> 指令集</h3><p><code>x86</code>指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式：</p><ul><li>立即数到寄存器</li><li>寄存器到寄存器</li><li>立即数到内存</li><li>寄存器到内存，或反向</li><li>内存到内存</li></ul><p>前四种是所有现代体系结构都支持的，而最后一种是<code>x86</code>独有的。像 ARM 这样的经典<code>RISC</code>体系结构只支持通过加载/存储指令（<code>LDR/STR</code>）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令：</p><ol><li>把数据从内存读入到寄存器中（LDR）</li><li>寄存器加 1（ADD）</li><li>把寄存器值写回内存（STR）<br />而对已<code>x86</code>来说，因为可以直接访问内存，这样的操作只需要一条指令（<code>INC或ADD</code>）。<code>MOVS</code>指令可以同时读写内存。<br />ARM：</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1B 68   LDR     R3, [R3]</span><br><span class="line">; 读入地址R3处的值并保存在R2中</span><br><span class="line">5A 1C   ADDS    R2, R3, #1</span><br><span class="line">; 加1</span><br><span class="line">1A 60   STR     R2, [R3]</span><br><span class="line">; 把更新后的值写回地址R3处</span><br></pre></td></tr></table></figure><p>x86：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FF 00   inc     dword ptr [eax]</span><br><span class="line">; 直接递增地址EAX处的值</span><br></pre></td></tr></table></figure><p><code>x86</code>的另一个重要特性是使用了变长指令——指令的长度从<code>1到15字节</code>不等。而在<code>ARM</code>上，指令长度只能是<code>2字节或4字节</code>。</p><h4 id="语法"><a class="markdownIt-Anchor" href="#语法"></a> 语法</h4><p>根据<code>汇编器/反汇编器</code>的不同，x86 汇编代码有两种记法：<code>Intel</code>和<code>AT&amp;T</code>。<br />Intel(Windows 上的记法)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mov ecx, AABBCCDDh</span><br><span class="line">mov ecx, [eax]</span><br><span class="line">mov ecx, eax</span><br></pre></td></tr></table></figure><p>AT&amp;T(unix 上的 GCC 记法):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">movl $0xAABBCCDD, %ecx</span><br><span class="line">movl (%eax), %ecx</span><br><span class="line">movl %eax, %ecx</span><br></pre></td></tr></table></figure><ul><li>AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。</li><li>AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。</li><li>AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。</li></ul><h4 id="数据移动"><a class="markdownIt-Anchor" href="#数据移动"></a> 数据移动</h4><p>指令用于操作来自寄存器或主内存中的数据。</p><h4 id="栈操作与函数调用"><a class="markdownIt-Anchor" href="#栈操作与函数调用"></a> 栈操作与函数调用</h4><p>C 语言的局部变量就存储在函数的栈空间中。操作系统从<code>ring3</code>切换到<code>ring0</code>时，要把状态信息保存在栈上。具体来讲，<code>x86</code>上的栈是<code>ESP</code>指向的一段连续内存区域，他向下增长。压栈（<code>push指令</code>）递减<code>ESP</code>的值，然后把数据写入 ESP 指向的位置；出栈（<code>pop</code>指令）读出<code>ESP</code>指向位置的数据并递增<code>ESP</code>。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。<br />假定<code>ESP</code>最初指向<code>0xb20000</code>，然后执行下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">; 起始值ESP=0xb20000</span><br><span class="line">B8 AA AA AA AA      MOV     EAX,0AAAAAAAAh</span><br><span class="line">BB BB BB BB BB      MOV     EBX,0BBBBBBBBh</span><br><span class="line">B9 CC CC CC CC      MOV     ECX,0CCCCCCCCh</span><br><span class="line">BA DD DD DD DD      MOV     EDX,0DDDDDDDDh</span><br><span class="line">50                  PUSH    EAX</span><br><span class="line">; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）</span><br><span class="line">53                  PUSH    EBX</span><br><span class="line">; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）</span><br><span class="line">5E                  POP     ESI</span><br><span class="line">; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）</span><br><span class="line">5F                  POP     EDI</span><br><span class="line">; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4）</span><br></pre></td></tr></table></figure><p>其他一些指令也可以直接修改<code>ESP</code>，比如<code>ADD</code>和<code>SUB</code></p><p>高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。</p><p>C 代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span></span></span><br><span class="line"><span class="function">__cdecl <span class="title">addme</span><span class="params">(<span class="keyword">short</span> a, <span class="keyword">short</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rerurn a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">004113A0 55             push    ebp</span><br><span class="line">004113A1 8B EC          mov     ebp, esp</span><br><span class="line">...</span><br><span class="line">004113BE 0F BF 45 08    movsx   eax, word ptr [ebp+8]</span><br><span class="line">004113C2 0F BF 4D 0C    movsx   ecx, word ptr [ebp+0ch]</span><br><span class="line">...</span><br><span class="line">004113CB 8B E5          mov     esp, ebp</span><br><span class="line">004113CD 5D             pop     ebp</span><br><span class="line">004113CE C3             retn</span><br><span class="line">; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列）</span><br></pre></td></tr></table></figure><p>通过下面的代码调用函数：</p><p>C 代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum = addme(x,y);</span><br></pre></td></tr></table></figure><p>汇编代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">004129F3 50             push    eax</span><br><span class="line">...</span><br><span class="line">004129F8 51             push    ecx</span><br><span class="line">004129F9 E8 F1 E7 FF FF call    addme</span><br><span class="line">004129FE 83 C4 08       add     esp, 8</span><br></pre></td></tr></table></figure><p>先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(<code>Application Binary Interface, ABI</code>)所定义的。</p><table><thead><tr><th style="text-align:left">调用惯例</th><th style="text-align:left">CDECL</th><th style="text-align:left">STDCALL</th><th style="text-align:left">FASTCALL</th></tr></thead><tbody><tr><td style="text-align:left">参数</td><td style="text-align:left">从右向左压栈。调用方负责在调用后清理栈</td><td style="text-align:left">与 CDECL 相同，除了被调用方负责清理栈</td><td style="text-align:left">前两个参数通过 ECX 和 EDX 传递。其余压栈</td></tr><tr><td style="text-align:left">返回值</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td><td style="text-align:left">保存在 EAX 中</td></tr><tr><td style="text-align:left">非易失寄存器</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td><td style="text-align:left">EBP、ESP、EBX、ESI、EDI</td></tr></tbody></table><p>现在我们回到前面的代码片段来讨论函数<code>addme</code>是如何被调用的。</p><p>在第 1 行和第 3 行代码中把两个参数压入栈顶，<code>EXC</code>和<code>EAX</code>分别是第一个和第二个参数。第四行代码通过<code>CALL</code>指令调用了<code>addme</code>函数。这立即导致返回地址<code>0x4120FE</code>被压栈，然后<code>0x4113A0</code>处开始执行。</p><p>第 4 行代码执行后，就进入了<code>addme</code>函数的函数体。第 1 行代码把<code>EBP</code>压栈。第 2 行代码把<code>EBP</code>设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为<code>函数序言</code>（<code>function prologue</code>）第 4 行代码读入地址<code>EBP+8</code>的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以<code>EBP</code>作为基地址的。在这个上下文环境中，<code>EBP</code>被称为<code>帧基指针</code>，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为<code>帧指针省略</code>（<code>frame pointer omission</code>）的优化方法指定编译器生成不使用<code>EBP</code>作为帧指针的代码。这种优化下，局部变量和参数的访问是相对<code>ESP</code>进行的，这时<code>EBP</code>可以作为一个通用寄存器，就像<code>EAX</code>、<code>EBX</code>、<code>EXC</code>等寄存器一样。第六行代码执行数字的加运算，并把结果放入<code>EAX</code>中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的<code>EBP</code>数值出栈到<code>EBP</code>。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（<code>function epilogue</code>）。这个时间点上，栈顶值为<code>CALL</code>指令保存的返回地址<code>0x4129F9</code>。第 10 行执行<code>RET</code>指令，这个指令将栈顶元素出栈并从<code>0x4129FE</code>开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据<code>CDECL</code>调用惯例的规定，栈清理的工作必须由调用者完成。</p><p>如果函数<code>addme</code>有局部变量，那么代码需要在第 2 行之后通过减小<code>ESP</code>值来增长栈大小。然后所有的局部变量都可以通过<code>EBP</code>加上一个负的偏移量来访问。</p><h4 id="控制流"><a class="markdownIt-Anchor" href="#控制流"></a> 控制流</h4><ul><li>ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0</li><li>SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位</li><li>CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。</li><li>OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。<br />算术运算指令会根据计算结果更新这些标志位。举例来说，<code>SUB EAX</code>,<code>EAX</code>指令会引起 ZF 标志的设置。<code>Jcc</code>指令会根据这些标志位改变控制流，其中<code>cc</code>是某个条件代码(<code>conditional code</code>)，该指令最多支持 16 中条件代码。</li></ul><table><thead><tr><th style="text-align:left">条件代码</th><th style="text-align:left">跳转条件</th><th style="text-align:left">机器描述</th></tr></thead><tbody><tr><td style="text-align:left">JZ/JE</td><td style="text-align:left">若为 0；若相等</td><td style="text-align:left">ZF = 1</td></tr><tr><td style="text-align:left">JNZ/JNE</td><td style="text-align:left">若不为 0；若不相等</td><td style="text-align:left">ZF = 0</td></tr><tr><td style="text-align:left">JS</td><td style="text-align:left">若为负</td><td style="text-align:left">SF = 1</td></tr><tr><td style="text-align:left">JNS</td><td style="text-align:left">若不为负</td><td style="text-align:left">SF = 0</td></tr><tr><td style="text-align:left">JP/JPE</td><td style="text-align:left">若 1 出现的次数为偶数</td><td style="text-align:left">PF = 1</td></tr><tr><td style="text-align:left">JNP/JPO</td><td style="text-align:left">若 1 出现的次数为奇数</td><td style="text-align:left">PF = 0</td></tr><tr><td style="text-align:left">JO</td><td style="text-align:left">若溢出</td><td style="text-align:left">OF = 1</td></tr><tr><td style="text-align:left">JNO</td><td style="text-align:left">若无溢出</td><td style="text-align:left">OF = 0</td></tr><tr><td style="text-align:left">JC/JB/JNAE</td><td style="text-align:left">若进位；若低于；若不高于等于</td><td style="text-align:left">CF = 1</td></tr><tr><td style="text-align:left">JNC/JNB/JAE</td><td style="text-align:left">若无进位；若不低于；若高于等于</td><td style="text-align:left">CF = 0</td></tr><tr><td style="text-align:left">JBE/JNA</td><td style="text-align:left">若低于等于；若不高于</td><td style="text-align:left">ZF = 1 或 CF = 1</td></tr><tr><td style="text-align:left">JNBE/JA</td><td style="text-align:left">若不低于等于；若高于</td><td style="text-align:left">ZF = 0 或 CF = 0</td></tr><tr><td style="text-align:left">JL/JNGE</td><td style="text-align:left">若小于；若不大于等于</td><td style="text-align:left">SF != OF</td></tr><tr><td style="text-align:left">JNL/JGE</td><td style="text-align:left">若不小于；若大于等于</td><td style="text-align:left">SF = OF</td></tr><tr><td style="text-align:left">JLE/JNG</td><td style="text-align:left">若小于等于；若不大于</td><td style="text-align:left">ZF != OF 或 ZF = 1</td></tr><tr><td style="text-align:left">JNLE/JG</td><td style="text-align:left">若不小于等于；若大于</td><td style="text-align:left">SF = 0 且 ZF = 0</td></tr></tbody></table><h3 id="系统机制"><a class="markdownIt-Anchor" href="#系统机制"></a> 系统机制</h3><p>两种基础系统机制：虚拟地址转换（<code>virtual address translation</code>）和异常/中断处理（<code>exception/interrupt handling</code>）</p><h4 id="地址转换"><a class="markdownIt-Anchor" href="#地址转换"></a> 地址转换</h4><p>计算机系统中的物理内存以<code>4KB</code>为单元作为一个页（<code>page</code>）。实际上页的大小也可以超过<code>4KB</code>，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">A1 78 56 34 12 MOV EAX, [0x12345678]  ; 读入虚内地址为0x12345678的内存</span><br><span class="line">89 08 MOV [EAX], ECX  ; 把ECX写入虚拟地址为EAX处</span><br></pre></td></tr></table></figure><p>物理地址是处理器访问内存时使用的实际内存地址。处理器的<code>MMU</code>(<code>Memory Management Unit</code>， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于<code>MMU</code>来说这个地址则是结构化的。在支持<code>PAE</code>(<code>Physical Address Extension</code>， 物理地址扩展)的<code>x86</code>系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括<code>PDPT</code>(<code>Page Directory Pointer Table</code>，页目录指针表)、<code>PD</code>(<code>Page Directory</code>，页目录)、<code>PT</code>(<code>Page Table</code>， 页表)以及<code>PTE</code>(<code>Page Table Entry</code>，页表项)。<code>PDPT</code>是<code>4个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PD</code>。<code>PD</code>是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PT</code>。<code>PT</code>也是一个有<code>512个元素</code>的数组，每个元素<code>8字节</code>，指向一个<code>PTE</code>。以虚拟地址<code>0xBF80EE6B</code>(转换成二进制：<code>10111111 10000000 11101110 01101011</code>)来理解，如下表：</p><table><thead><tr><th style="text-align:left">10(0x2)</th><th style="text-align:left">111111 100(0x1FC)</th><th style="text-align:left">00000 1110(0xE)</th><th style="text-align:left">1110 01101011(0xE6B)</th></tr></thead><tbody><tr><td style="text-align:left">2 位</td><td style="text-align:left">9 位</td><td style="text-align:left">9 位</td><td style="text-align:left">12 位</td></tr><tr><td style="text-align:left">索引到 PDPT</td><td style="text-align:left">索引到 PD</td><td style="text-align:left">索引到 PT</td><td style="text-align:left">页偏移量</td></tr></tbody></table><p>这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。</p><p>地址转换过程就围绕着这 3 个表和<code>CR3</code>寄存器。<code>CR3</code>寄存器保存着<code>PDPT</code>的物理基地址。</p><h4 id="中断与异常"><a class="markdownIt-Anchor" href="#中断与异常"></a> 中断与异常</h4><p>简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。</p><h3 id="x64"><a class="markdownIt-Anchor" href="#x64"></a> x64</h3><p><code>x64</code>是<code>x86</code>的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如<code>PUSHAD</code>)。</p><h4 id="寄存器组与数据类型补充"><a class="markdownIt-Anchor" href="#寄存器组与数据类型补充"></a> 寄存器组与数据类型补充</h4><p><code>x64</code>的寄存器组有<code>18个64位GPR</code>，下面画图解释这些寄存器的结构，注意前缀为<code>R</code>的是<code>64位</code>寄存器。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RAX |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EAX    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   AX |    |</span><br><span class="line">|    |    |    |    |    |    |   AH |   AL |</span><br><span class="line"></span><br><span class="line">64      .       .       .       31      23      15      7       0</span><br><span class="line">|RBP |    |    |    |    |    |    |    |</span><br><span class="line">|       |       |       |       |EBP    |    |    |    |</span><br><span class="line">|    |    |    |    |    |    |   BP |    |</span><br><span class="line">|    |    |    |    |    |    |    |   BPL |</span><br></pre></td></tr></table></figure><p>虽然<code>RBP</code>任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数<code>x64</code>编译器只是把<code>RBP</code>当作<code>GPR</code>来用，而用<code>RSP</code>作为基地址引用局部变量。</p><h4 id="数据移动补充"><a class="markdownIt-Anchor" href="#数据移动补充"></a> 数据移动补充</h4><p><code>x64</code>支持一种称为<code>RIP</code>相对寻址(<code>RIP-relative addressing</code>)的概念，其允许指令引用数据时使用相对<code>RIP</code>的地址。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">0000000000000000 48 8B 05 00 00+    mov rax, qword ptr cs:loc_A</span><br><span class="line">                                    ; 最开始写作&quot;mov rax,[rip]&quot;</span><br><span class="line">0000000000000007                    loc_A:</span><br><span class="line">0000000000000007 48 31 C0           xor rax,rax</span><br><span class="line">000000000000000A 90                 nop</span><br></pre></td></tr></table></figure><p>第 1 行读入<code>loc_A</code>的地址（为<code>0x7</code>）然后保存到<code>RAX</code>中。<code>RIP</code>相对寻址主要用于产生位置无关代码。<br />多数算术运算指令都自动升级为<code>64位</code>，即使操作数只有<code>32位</code>。例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">48 B8 88 77 66+     mov rax, 1122334455667788h</span><br><span class="line">31 C0               xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=0</span><br><span class="line">48 C7 C0 FF FF+     mov rax, 0FFFFFFFFFFFFFFFFh</span><br><span class="line">FF C0               inc eax  ; 执行后RAX=0</span><br></pre></td></tr></table></figure><h4 id="规范地址"><a class="markdownIt-Anchor" href="#规范地址"></a> 规范地址</h4><p><code>x64</code>中虚拟地址的宽度是<code>64位</code>，但多数处理器并不支持完整的<code>64位</code>虚拟地址空间。当前<code>Intel/AMD</code>处理器只使用<code>48位</code>地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从<code>第63位</code>到具体实现的最高有效位都是<code>1</code>或者都是<code>0</code>，那么这个虚拟地址就称为规范地址。具体来说，这意味着从<code>48到63位</code>都要和<code>47位</code>相同。如果代码引用一个非规范地址，就会触发系统异常。</p><h4 id="函数调用"><a class="markdownIt-Anchor" href="#函数调用"></a> 函数调用</h4><p><code>x86</code>上有一些调用惯例需要通过栈来传递一些参数。对于<code>x64</code>来说，多数调用惯例都是通过寄存器传递参数，比如在<code>windows x64</code>中，只有一种调用惯例用到栈，并且其中前四个参数还是通过<code>RCX</code>、<code>RDX</code>、<code>R8</code>和<code>R9</code>来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过<code>RDI</code>、<code>RSI</code>、<code>RDX</code>、<code>RCX</code>、<code>R8</code>和<code>R9</code>传递。<br />------------------------本次更新时间 2018-10-16 10:53</p><h2 id="arm"><a class="markdownIt-Anchor" href="#arm"></a> ARM</h2><p>这里介绍的是<code>ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)</code>中定义的<code>ARM</code>体系结构。</p><h3 id="基本特性"><a class="markdownIt-Anchor" href="#基本特性"></a> 基本特性</h3><p><code>ARM</code>是<code>RISC</code>体系结构，因此与<code>CISC</code>体系结构(<code>x86/x64</code>)有一些基本区别。(从实践的角度说，最新版本的<code>Intel</code>处理器也具有一些<code>RISC</code>的特征；也就是说，他们已经不再是纯粹的<code>CISC</code>。)首先，与<code>x86</code>相比，<code>ARM</code>的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（<code>16位</code>或<code>32位</code>，根据当前状态而定）。第三，<code>ARM</code>的内存访问模式是<code>加载-存储</code>模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有<code>加载/存储</code>指令能够访问内存，具体来说，在<code>ARM</code>中是<code>LDR</code>和<code>STR</code>指令。如果要递增某个内存地址上的<code>32位</code>数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。<code>x86</code>则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。</p><p><code>ARM</code>还提供了几种不同级别的特权模式来实现特权隔离。<code>x86</code>上的特权级别是通过 4 种<code>ring</code>级别定义的，其中<code>ring0</code>具有最高特权级别，<code>ring3</code>的特权级别最低。在<code>ARM</code>中，有 8 种不同级别的特权模式：</p><ul><li>USR(USER,用户模式)</li><li>FIQ(FAST INTERRUPT REQUEST,快速中断请求模式)</li><li>IRQ(INTERRUPT REQUEST,中断请求模式)</li><li>SVC(SUPERVISOR, 管理模式)</li><li>MON(MONITOR,监视模式)</li><li>ABT(ABORT,中止模式)</li><li>UND(UNDERFINED,未定义指令模式)</li><li>SYS(SYSTEM,系统模式)</li></ul><p>多数操作系统内核模式运行于<code>SVC</code>。在<code>Windows</code>或<code>Linux</code>上都是。</p><p><code>x64</code>处理器可以运行在<code>32位</code>或<code>64位</code>模式下，也可以交替运行于这两种模式下。<code>ARM</code>处理与之类似，他们也可以运行在两种状态下：<code>ARM</code>和<code>Thumb</code>状态。<code>ARM/Thumb</code>状态决定的只有指令集，而不是特权模式。比如运行子啊在<code>ARM</code>状态下，指令总是<code>32位宽</code>；而在<code>Thumb</code>下，指令可以是<code>16位宽</code>也可以是<code>32位宽</code>。决定处理器执行状态的是以下两个因素。</p><ul><li>通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。）</li><li>如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。</li></ul><p><code>ARM</code>核心启动的时候，多数情况下都是进入<code>ARM</code>状态并保持在这个状态，知道显式或隐式地切换到<code>Thumb</code>模式。具体实践中，多数较新的操作系统使用<code>Thumb</code>代码是为了获得更高的代码密度（混合使用<code>16/32位宽</code>度指令的代码大小小于全部使用<code>32位</code>指令），而且应用程序可以运行于任意模式下。因为多数<code>Thumb</code>和<code>ARM</code>指令助记符都是相同的，所以在<code>32位Thumb</code>指令后添加一个<code>.W</code>后缀标识。</p><p>注意，有一种很常见的误解，就是把<code>Thumb</code>模式看作<code>x86/x64</code>上的实模式，把<code>ARM</code>模式看作保护模式。<code>x86/x64</code>平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位<code>ARM</code>平台上的操作系统和应用程序则可以交替运行于<code>ARM</code>状态和<code>Thumb</code>状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。<br /><code>Thumb</code>有两个版本：<code>Thumb-1</code>和<code>Thumb-2</code>。<code>Thumb-1</code>用于<code>ARMv6</code>和更早期的体系结构，指令集宽度都是<code>16位</code>。<code>Thumb-2</code>增加了更多的指令，并支持<code>16位</code>和<code>32位</code>的指令宽度。<code>ARMv7</code>只用<code>Thumb-2</code>，所以只要是讨论<code>Thumb</code>，都是<code>Thumb-2</code>、<br /><code>ARM</code>状态与<code>Thumb</code>状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在<code>ARM</code>状态下支持，而在<code>Thumb</code>状态下不可用，或者反之。要了解更多请参考<code>ARM</code>的官方文档。<br />------------------------更新时间 2018-10-17 16:34</p><h3 id="数据类型与寄存器"><a class="markdownIt-Anchor" href="#数据类型与寄存器"></a> 数据类型与寄存器</h3><p>与高级语言类似，<code>ARM</code>也支持多种数据类型的运算，包括：<code>8位</code>（字节），<code>16位</code>（半字）、<code>32位</code>（字）和<code>64位</code>（双字）。</p><p><code>ARM</code>的体系结构定义了<code>16个32位</code>通用寄存器，命名为<code>R0~R15</code>，实际开发中只用<code>前13个作为通用寄存器</code>（就像<code>x86</code>中的<code>EAX</code>、<code>EBX</code>等），最后三个有特殊的意义。</p><ul><li><p>R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端</p></li><li><p>R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。</p></li><li><p>R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0x00008344 push &#123;lr&#125;</span><br><span class="line">0x00008346 mov r0,pc</span><br><span class="line">0x00008348 mov.w r2, r2, ls1 #31</span><br><span class="line">0x0000834C pop &#123;pc&#125;</span><br></pre></td></tr></table></figure><p>在第 2 行执行之后，<code>R0</code>的值为<code>0x0000834A</code>(=<code>0x00008346+4</code>)</p><p>与其他体系结构类似，<code>ARM</code>把当前执行状态信息保存在当前程序状态寄存器（<code>CPSR</code>）中。从应用程序开发者的角度来看，<code>CPSR</code>类似于<code>x86/x84</code>下的<code>EFLAGS/RFLAG</code>寄存器。某些文档中会提到应用程序状态寄存器（<code>APSR</code>），这是<code>CPSR</code>中某些字段的别名。<code>CPSR</code>中有很多标志位，下面列出其中的部分：</p><ul><li>E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。</li><li>T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。</li><li>M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-10-18 09:30</p><h3 id="系统级控制与设置"><a class="markdownIt-Anchor" href="#系统级控制与设置"></a> 系统级控制与设置</h3><p><code>ARM</code>提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(<code>MMU, Memory Management Unit</code>)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在<code>x86/x64</code>上，这些设置接口是放在<code>CR0</code>和<code>CR4</code>中的；而在<code>ARM</code>上，则放在<code>CP15</code>中，<code>ARM</code>体系结构中有<code>16</code>个协处理器，编号为<code>CP0~CP15</code>.前 13 个协处理器时可选的或者是<code>ARM</code>保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的<code>ARM</code>指令控制。举例来说，<code>CP10</code>和<code>CP11</code>常常用于调试和系统设置。而且<code>CP15</code>通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。</span><br></pre></td></tr></table></figure><p>每个协处理器有<code>16个寄存器</code>和<code>8个相应的操作码</code>。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过<code>MRC</code>(读)和<code>MCR</code>(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于<code>x86/x64</code>中的<code>CR3</code>)并保存到<code>R0</code>中，可以使用如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中</span><br></pre></td></tr></table></figure><p>这句代码表示：“使用操作码<code>0/0</code>读出<code>CP15</code>的<code>C2/C0</code>，并保存结果到通用寄存器<code>R0</code>。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（<code>C13/C0</code>）是操作系统保留的，用于保存特定于进程或线程的数据。</p><p><code>MRC</code>和<code>MCR</code>指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在<code>SVC</code>模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像<code>ROM</code>、<code>bootloader</code>、固件这样很底层的代码或内核模式代码中。<br />------------------------更新时间 2018-10-21 13:10</p><h3 id="指令集介绍"><a class="markdownIt-Anchor" href="#指令集介绍"></a> 指令集介绍</h3><p>相比起<code>x86</code>体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器<code>R6~R10</code>保存到<code>R1</code>指向的一段内存位置，可以使用指令<code>STM R1,&#123;R6-R10&#125;</code>。<code>R6</code>会保存到内存地址<code>R1</code>，<code>R7</code>保存到<code>R1+4</code>，<code>R8</code>保存到<code>R1+8</code>，以此类推。对于不连续的寄存器，可以用逗号分隔（比如<code>&#123;R1,R5,R8&#125;</code>）。<code>ARM</code>的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号<code>!</code>来表示。举例来说，如果把前面的指令改写为<code>STM R1!, &#123;R6-R10&#125;</code>并执行，那么<code>R1</code>将会被更新为保存<code>R10</code>的地址之后的下一个地址。<br />------------------------更新时间 2018-10-22 08:10</p><h3 id="数据加载与存储"><a class="markdownIt-Anchor" href="#数据加载与存储"></a> 数据加载与存储</h3><p><code>ARM</code>是一种<code>加载-存储式</code>的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在<code>ARM</code>体系结构中，加载和存储指令包括<code>LDR/STR</code>、<code>LDM/STM</code>和<code>PUSH/POP</code>。</p><h4 id="ldr-与-str"><a class="markdownIt-Anchor" href="#ldr-与-str"></a> LDR 与 STR</h4><p><code>LDR/STR</code>指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。</p><p>第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式：</p><ul><li><code>STR Ra, [Rb, imm]</code></li><li><code>LDR Ra, [Rc, imm]</code><br /><code>Rb</code>是基址寄存器，<code>imm</code>是要加到<code>Rb</code>的偏移量</li></ul><p>第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下：</p><ul><li><code>STR Ra, [Rb, Rc]</code></li><li><code>LDR Ra, [Rb, Rc]</code><br />根据上下文的不同，<code>Rb</code>或<code>Rc</code>可以是基址或偏移量。</li></ul><p>第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下：</p><ul><li><code>STR Ra, [Rb, Rc, &lt;shifter&gt;]</code></li><li><code>LDR Ra, [Rb, Rc, &lt;shifter&gt;]</code><br />Rb 是基址寄存器，Rc 是一个立即数，<code>&lt;shifter&gt;</code>是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。</li></ul><p>------------------------更新时间 2018-10-23 07:30</p><h4 id="ldr-的其他用途"><a class="markdownIt-Anchor" href="#ldr-的其他用途"></a> LDR 的其他用途</h4><p><code>LDR</code>用于从内存向寄存器中加载数据，但有时候会看到这样的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">01: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]</span><br><span class="line">02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]</span><br><span class="line">03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z]</span><br></pre></td></tr></table></figure><p>伪指令内部使用了立即数寻址形式的<code>LDR</code>指令，<code>PC</code>作为基址寄存器。有时这也成为<code>PC</code>相对寻址（或在<code>x64</code>上称为<code>RIP</code>相对寻址）。<code>ARM</code>二进制文件通常有一个文本池（<code>literal pool</code>），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个<code>32</code>位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">01: .text:0100B134 35 4B LDR R3, =0x68DB8BAD</span><br><span class="line">; 实际上就是LDR R3, [PC, #0xD4]</span><br><span class="line">; 这时PC = 0x0100B138</span><br><span class="line">02: ...</span><br><span class="line">03: .text:0100B20C AD 8B DB 68  dword_100B20C DCD 0x68DB8BAD</span><br></pre></td></tr></table></figure><p>因为代码处于<code>Thumb</code>状态，<code>PC</code>值是当前指令加上<code>4</code>，也就是<code>0x0100B138</code>。这里使用了立即数寻址方式，所以要读出位于<code>0x0100B20C</code>（<code>=0x0100B138+0x4D</code>）的字，这就是我们想要加载的常量。<br />------------------------更新时间 2018-10-26 07:00</p><h4 id="ldm-与-stm"><a class="markdownIt-Anchor" href="#ldm-与-stm"></a> LDM 与 STM</h4><p><code>LDM</code>和<code>STM</code>与<code>LDR/STR</code>类似，区别是前者可以从给定的基址寄存器加载多个字。<code>LDM</code>和<code>STM</code>通常用于从内存读出或写入多个数据块，通常语法为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br><span class="line">STM&lt;mode&gt; Rn[!], &#123;Rm&#125;</span><br></pre></td></tr></table></figure><p><code>Rn</code>是基址寄存器，其中保存要加载/存储的内存地址。<code>！</code>是可选的，意思是基址寄存器会更新为新的地址（写回）。<code>Rm</code>是要加载或存储的范围。<code>LDM</code>和<code>STM</code>有四种模式。</p><ul><li>IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。</li><li>IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。</li><li>DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。</li><li>DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。</li></ul><p>下面是调试器观察的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disas main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;: mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式</span><br><span class="line">0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x00008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000834c in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r3 r4 r5</span><br><span class="line">r3 0x1 1</span><br><span class="line">r4 0x2 2</span><br><span class="line">r5 0x3 3</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p>第 5 行把一个内存地址写入<code>R6</code>，这个内存地址（<code>0x1050c</code>）的内容是一个 3 字数据（第 17 行）。6-8 行将<code>R2～R0</code>设置为某个常量。第 9 行加载从<code>R6</code>指向的内存地址开始的 3 个字到<code>R3～R5</code>。如第 24 ～ 26 行所示，<code>R3～R5</code>的内容正是期望值。第 10 行存储<code>R0~R2</code>到<code>R6</code>指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 |  |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 |  |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 |  |  | ldm r6, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |\/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | r6 |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | r6+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | r6+8 |  |</span><br><span class="line">| --- |\/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0xA | r6   |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | r6+4 |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | r6+8 |</span><br><span class="line">| --- |</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br></pre></td></tr></table></figure><p>下面用写回模式做同样的实验：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">(gdb) br main</span><br><span class="line">Breakpoint 1 at 0x8344</span><br><span class="line">(gdb) disaa main</span><br><span class="line">Dump of assembler code for function main:</span><br><span class="line">0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改</span><br><span class="line">0x00008348 &lt;+4&gt;: mov r0, #10</span><br><span class="line">0x0000834c &lt;+8&gt;: mov r1, #11</span><br><span class="line">0x00008350 &lt;+12&gt;:mov r2, #12</span><br><span class="line">0x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式</span><br><span class="line">0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式</span><br><span class="line">...</span><br><span class="line">(gdb) r</span><br><span class="line">Breakpoint 1, 0x0008344 in main ()</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008348 in main ()</span><br><span class="line">...</span><br><span class="line">(gdb)</span><br><span class="line">0x00008354 in main ()</span><br><span class="line">(gdb) x/3x $r6</span><br><span class="line">0x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003</span><br><span class="line">(gdb) si</span><br><span class="line">0x00008358 in main ()</span><br><span class="line">(gdb) info reg r6</span><br><span class="line">r6 0x10518 66840</span><br><span class="line">(gdb) si</span><br><span class="line">0x0000835c in main ()</span><br><span class="line">(gdb) info reg $r6</span><br><span class="line">r6 0x10524 66852</span><br><span class="line">(gdb) x/4x $r6-12</span><br><span class="line">0x10518 : 0x0000000a 0x0000000b 0x0000000c</span><br></pre></td></tr></table></figure><p><code>0x00000000</code></p><p>第 9 行使用<code>IA</code>写回模式，所以<code>R6</code>更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"> mem</span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | ldr r6, =mem |</span><br><span class="line">| --- ||| mov r0, #10</span><br><span class="line">| 0x2 | 0x1050c+4 |  | mov r1, #11 |</span><br><span class="line">| --- ||| mov r2, #12</span><br><span class="line">| 0x3 | 0x1050c+8 |  | ldm r6!, &#123;r3,r4,r5&#125; |</span><br><span class="line">| --- |0x1050c+c \/</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c |  | stm r6, &#123;r0,r1,r2&#125; |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x2 | 0x1050c+4 |  |</span><br><span class="line">| --- |||</span><br><span class="line">| 0x3 | 0x1050c+8 |  |</span><br><span class="line">| --- |0x1050c+c r6 \/</span><br><span class="line">r0=a r1=b r2=c</span><br><span class="line">r3=1 r4=2 r5=3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">|---|</span><br><span class="line">| 0x1 | 0x1050c       |</span><br><span class="line">| --- |</span><br><span class="line">| 0x2 | 0x1050c+4     |</span><br><span class="line">| --- |</span><br><span class="line">| 0x3 | 0x1050c+8     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xA | 0x1050c+c     |</span><br><span class="line">| --- |</span><br><span class="line">| 0xB | 0x1050c+10    |</span><br><span class="line">| --- |</span><br><span class="line">| 0xC | 0x1050c+14    |</span><br><span class="line">| --- | 0x1050c+18 r6 |</span><br></pre></td></tr></table></figure><p><code>LDM</code>和<code>STM</code>指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联<code>memcpy</code>。这类似于<code>x86</code>中带有<code>REP</code>前缀的<code>movs</code>指令。</p><ul><li>注意<br /><code>STM/LDM</code>后面经常会出现后缀<code>FD</code>、<code>FA</code>、<code>ED</code>或<code>EA</code>。它们就是不同模式下（<code>IA/IB</code>等）的<code>STM/LDM</code>指令的伪指令，分别对应于<code>STMFD/STMDB</code>、<code>STMFA/STMIB</code>、<code>STMED/STMDA</code>、<code>STMEA/STMIA</code>、<code>LDMFD/LDMIA</code>、<code>LDMFA/LDMDA</code>和<code>LDMEA/LDMDB</code>。因为这些对应关系太难记忆，建议为每个指令画一个图。</li></ul><p>------------------------更新时间 2018-11-4 08:00</p><h4 id="push-与-pop"><a class="markdownIt-Anchor" href="#push-与-pop"></a> PUSH 与 POP</h4><p>加载/存储指令的最后一组是<code>PUSH</code>和<code>POP</code>。他们类似于<code>LDM/STM</code>，但有两点不同：</p><ul><li>他们隐式地使用 SP 作为基地址；</li><li>SP 会自动更新。</li></ul><p>和<code>x86/x64</code>中的一样，栈是朝下向低地址方向增长的。通用的语法是<code>PUSH/POP &#123;Rn&#125;</code>,其中<code>Rn</code>可以是一个寄存器范围。</p><p><code>PUSH</code>指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把<code>SP</code>更新为第一个位置的地址。<code>POP</code>从当前栈指针处开始向寄存器加载数据，然后更新<code>SP</code>为最后一个位置的地址的向上 4 字节处。<code>PUSH/POP</code>实际上就是以<code>SP</code>作为基地址指针的带写回的<code>STMDB/LDMIA</code>。</p><p>最常用到<code>PUSH/POP</code>的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像<code>ARM</code>状态下的<code>STMFD/LDMFD</code>一样）。举例来说：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址</span><br><span class="line">...</span><br><span class="line">BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-5 07:00</p><h3 id="函数与函数调用"><a class="markdownIt-Anchor" href="#函数与函数调用"></a> 函数与函数调用</h3><p><code>x86/x64</code>只有一个用于函数调用的指令（<code>CALL</code>）和一个用于分支跳转的指令（<code>JMP</code>）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在<code>x86</code>中，<code>CALL</code>指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到<code>EIP</code>，从而从返回地址恢复执行。</p><p><code>ARM</code>体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（<code>LR</code>）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到<code>PC</code>寄存器，否则会无条件跳转到<code>LR</code>。其次，根据目标地址的最低位（<code>LSB</code>）不同，一次分支跳转可以在<code>ARM</code>状态和<code>Thumb</code>状态之间切换。第三点，<code>ARM</code>定义了标准调用惯例：前 4 个 32 位参数通过寄存器（<code>R0-R3</code>）传递，其余的参数放在栈上。返回值保存在<code>R0</code>中。</p><p><code>ARM</code>中函数调用的指令是<code>B</code>、<code>BX</code>、<code>BL</code>和<code>BLX</code>。</p><p>尽管在函数调用的上下文中很少看到<code>B</code>指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于<code>x86</code>中的<code>JMP</code>指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。</p><p><code>B</code>指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，<code>B</code>指令的语法为<code>B imm</code>，其中<code>imm</code>是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为<code>ARM</code>和<code>Thumb</code>指令是<code>2字节</code>或<code>4字节</code>对齐的，所以目标偏移量必须是一个偶数。</p><p><code>BX</code>是分支跳转并交换（<code>Branch and Exchange</code>）。与<code>B</code>指令的相似之处在于，两者都是把控制转移到某个目标地址处，但<code>BX</code>能够在<code>ARM</code>和<code>Thumb</code>状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以<code>X</code>结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到<code>Thumb</code>状态，否则就执行在<code>ARM</code>状态。指令的格式是<code>BX&lt;寄存器&gt;</code>，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到<code>LR</code>（也即 <code>BX LR</code>）从函数返回，还有一种是用于切换到不同状态的代码（也即从<code>ARM</code>切换到<code>Thumb</code>状态或反之）。在编译后的代码中，函数结尾处几乎总会出现<code>BX LR</code>，基本上于<code>x86</code>中的<code>RET</code>相同。</p><p><code>BL</code>是分支跳转并连接（<code>Branch with Link</code>），它类似于<code>B</code>指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到<code>LR</code>。这也许是和<code>x86</code>中的<code>CALL</code>指令最为接近的一条指令，经常在函数调用中使用。<code>BL</code>指令格式与<code>B</code>指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">00014350 BL foo ; LR = 0x00014354</span><br><span class="line">00014354 MOVS R4, #0x15</span><br><span class="line">...</span><br><span class="line">0001B224 foo</span><br><span class="line">0001B224 PUSH &#123;R1-R3&#125;</span><br><span class="line">0001B226 MOV R3, 0x6124</span><br><span class="line">...</span><br><span class="line">0001B24C BX LR ; 返回到0x00014354</span><br></pre></td></tr></table></figure><p>上面代码的第 1 行使用<code>BL</code>调用函数<code>foo</code>。在转换控制到目标之前，<code>BL</code>在<code>LR</code>中保存了返回地址（<code>0x000014354</code>）。<code>foo</code>做了一些工作然后返回到调用者（<code>BX LR</code>）。</p><p><code>BLX</code>是指跳转加连接和交换（<code>Branch with Link and Exchange</code>）。于<code>BL</code>类似，<code>BLX</code>也可以支持状态切换。两者主要的区别在于，<code>BLX</code>可以接受偏移量或寄存器作为跳转目标，而且在<code>BLX</code>指令使用偏移量的情况下，处理器总是会切换状态（<code>ARM</code>到<code>Thumb</code>或反之）。因为这条指令于<code>BL</code>的特性相同，也可以把它当做<code>x86</code>中的<code>CALL</code>指令。实际使用中，<code>BL</code>和<code>BLX</code>都用于实现函数调用。如果函数在<code>32MB</code>范围之内，通常使用<code>BL</code>，而目标区域不确定（比如函数指针）的时候常用<code>BLX</code>。通常在<code>Thumb</code>状态下运行的时候，使用<code>BLX</code>指令调用库例程，而在<code>ARM</code>状态下使用<code>BL</code>。</p><p>------------------------更新时间 2018-11-9 07:00</p><h3 id="算术运算"><a class="markdownIt-Anchor" href="#算术运算"></a> 算术运算</h3><p>把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过<code>mov</code>指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（<code>LSL</code>）、右移（<code>LSR</code>、<code>ASR</code>）和循环移位（<code>ROR</code>、<code>RRX</code>）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。<code>ARM</code>和<code>Thumb</code>指令的宽度可能是<code>16</code>位或<code>32</code>位，所以无法直接使用<code>32</code>位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动<code>32</code>位常量到寄存器的方法是把常量分割为两个<code>16位</code>数值，分两次移动；这通常通过<code>MOVW</code>和<code>MOVT</code>指令实现。<code>MOVT</code>设置寄存器的<code>高16位</code>，<code>MOVW</code>设置<code>低16位</code>。</p><p>基本算术和逻辑运算包括<code>ADD</code>、<code>SUB</code>、<code>MUL</code>、<code>AND</code>、<code>ORR</code>和<code>EOR</code>。</p><p>注意：<code>ARM</code>没有原生的除法指令。（<code>ARMv7-R</code>和<code>ARMv7-M</code>内核有<code>SDIV</code>和<code>UDIV</code>指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是<code>Windows C</code>运行时的一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">41 46 MOV R1， R8</span><br><span class="line">40 46 MOV R0,R6</span><br><span class="line">35 F0 9E 9F BL __rt_udiv ; udiv的软件实现</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-11 07:00</p><h3 id="分支跳转与条件执行"><a class="markdownIt-Anchor" href="#分支跳转与条件执行"></a> 分支跳转与条件执行</h3><p>前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（<code>APSR</code>）中的条件标志位实现的。<code>APSR</code>是<code>CPSR</code>的别名，类似于<code>x86</code>中的<code>EFLAG</code>寄存器。</p><ul><li>N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1）</li><li>Z（Zero，零标志位）：运算结果为 0 时设置</li><li>C（Carry，借位标志位）：两个无符号值计算结果溢出时设置</li><li>V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置</li><li>IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">        31          26      15      10              9       5               4           0</span><br><span class="line">CPSR    |cond.flags |       |1T     |大小端标志位E    |       |Thumb标志位T    |模式标志位M  |</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">APSR |N|Z|C|V|Q  |       |保留|</span><br><span class="line"> 31 26 15 0</span><br></pre></td></tr></table></figure><p>N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。</p><table><thead><tr><th style="text-align:left">后缀/编码</th><th style="text-align:left">意义</th><th style="text-align:left">标志位</th></tr></thead><tbody><tr><td style="text-align:left">EQ</td><td style="text-align:left">等于</td><td style="text-align:left">Z==1</td></tr><tr><td style="text-align:left">NE</td><td style="text-align:left">不等于</td><td style="text-align:left">Z==0</td></tr><tr><td style="text-align:left">MI</td><td style="text-align:left">减、负</td><td style="text-align:left">N==1</td></tr><tr><td style="text-align:left">PL</td><td style="text-align:left">加、正或者为 0</td><td style="text-align:left">N==0</td></tr><tr><td style="text-align:left">HI</td><td style="text-align:left">无符号大于</td><td style="text-align:left">C<mark>1 且 Z</mark>0</td></tr><tr><td style="text-align:left">LS</td><td style="text-align:left">无符号小于</td><td style="text-align:left">C<mark>0 或 Z</mark>1</td></tr><tr><td style="text-align:left">GE</td><td style="text-align:left">有符号大于等于</td><td style="text-align:left">N==V</td></tr><tr><td style="text-align:left">LT</td><td style="text-align:left">有符号小于</td><td style="text-align:left">N！=V</td></tr><tr><td style="text-align:left">GT</td><td style="text-align:left">有符号大于</td><td style="text-align:left">Z<mark>0 且 N</mark>V</td></tr><tr><td style="text-align:left">LE</td><td style="text-align:left">有符号小于等于</td><td style="text-align:left">Z==1 或 N！=V</td></tr></tbody></table><p>默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。</p><p>最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码：<br />ARM</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">B3 EB E7 7F CMP.W  R3, R7, ASR #31</span><br><span class="line">05 DB BLT  loc_less</span><br><span class="line">01 DC  BGT  loc_greater</span><br><span class="line">BD 42 CMP  R5, R7</span><br><span class="line">02 D9  BLS  loc_less</span><br><span class="line"> loc_greater</span><br><span class="line">07 3D  SUBS  R5, #7</span><br><span class="line">6E F1 00 0E  SBC.W  LR, LR, #0</span><br><span class="line"> loc_less</span><br><span class="line">A5 FB 08 12  UMULL.W R1, R2, R5, R8</span><br><span class="line">87 FB 08 04  SMULL.W R0, R4, R7, R8</span><br><span class="line">0E FB 08 23  MLA.W  R3, LR, R8, R2</span><br></pre></td></tr></table></figure><p>C 伪代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (r3 &lt; r7) &#123;goto loc_less;&#125;</span><br><span class="line"> else if (r3 &gt; r7) &#123;goto loc_greater;&#125;</span><br><span class="line"> else if (r5 &lt; r7) &#123;goto loc_less;&#125;</span><br></pre></td></tr></table></figure><p>------------------------更新时间 2018-11-12 07:00</p><h4 id="thunb-状态"><a class="markdownIt-Anchor" href="#thunb-状态"></a> Thunb 状态</h4><h4 id="switch-case"><a class="markdownIt-Anchor" href="#switch-case"></a> switch-case</h4><h3 id="杂项"><a class="markdownIt-Anchor" href="#杂项"></a> 杂项</h3><h2 id="windows-内核"><a class="markdownIt-Anchor" href="#windows-内核"></a> Windows 内核</h2><h2 id="调试与自动化"><a class="markdownIt-Anchor" href="#调试与自动化"></a> 调试与自动化</h2><h2 id="代码混淆"><a class="markdownIt-Anchor" href="#代码混淆"></a> 代码混淆</h2><h2 id="代码研究"><a class="markdownIt-Anchor" href="#代码研究"></a> 代码研究</h2><h3 id="windows-内核代码"><a class="markdownIt-Anchor" href="#windows-内核代码"></a> windows 内核代码</h3><p>片段 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)</span><br><span class="line">sub_4038F0 proc near</span><br><span class="line">push rbx ; rbx压栈</span><br><span class="line">push rbp ; rbp压栈</span><br><span class="line">push rsi ; rsi压栈</span><br><span class="line">push rdi ; rdi压栈</span><br><span class="line">push r12 ; r12压栈</span><br><span class="line">sub rsp, 60h ; rsp的值减去0x60</span><br><span class="line">mov bpl, r8b ; r8p的值入bpl</span><br><span class="line">mov r12, rdx ; 将rdx的值放进栈r12中</span><br><span class="line">mov rdi, rcx ; 将rcx的值放进栈rdi中</span><br><span class="line">mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针</span><br><span class="line">mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]</span><br><span class="line">xor edx, edx ; ChargeQuota 将edx初始化置0</span><br><span class="line">mov cl, [rax+4ch] ; StackSize 栈空间大小</span><br><span class="line">mov rsi, rax ; 将rax的值放进栈rsi中</span><br><span class="line">call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）</span><br><span class="line">test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）</span><br><span class="line">mov rbx, rax ; 将rax的值放进栈rbx中</span><br><span class="line">jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中</span><br><span class="line">mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。</span><br><span class="line">jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）</span><br><span class="line">loc_403932:</span><br><span class="line">lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址</span><br><span class="line">xor r8d, r8d ; State 状态值初始化为0</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]</span><br><span class="line">lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址</span><br><span class="line">lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址</span><br><span class="line">mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件</span><br><span class="line">lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址</span><br><span class="line">mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]</span><br><span class="line">mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给rax</span><br><span class="line">mov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中</span><br><span class="line">mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]</span><br><span class="line">mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0</span><br><span class="line">call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态</span><br><span class="line">test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中</span><br><span class="line">mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6</span><br><span class="line">mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中</span><br><span class="line">mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中</span><br><span class="line">test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.</span><br><span class="line">jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中</span><br><span class="line">mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0</span><br><span class="line">loc_4039A6:</span><br><span class="line">mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle   将寄存器r12中的值放进[rcx-28h]中</span><br><span class="line">mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object  将寄存器rdi中的值放进[rcx-30h]中</span><br><span class="line">mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dh</span><br><span class="line">mov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length  将[rcx-40h]处的双字设置为1</span><br><span class="line">mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中</span><br><span class="line">lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址</span><br><span class="line">mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中</span><br><span class="line">mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中</span><br><span class="line">mov rdx, rbx ; Irp 将rbx处的值放进rdx中</span><br><span class="line">mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0</span><br><span class="line">mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0</span><br><span class="line">call cs:IofCallDriver ; 调用IofCallDriver方法</span><br><span class="line">cmp eax, 103h ; STATUS_PENDING 比较eax和103h</span><br><span class="line">jnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09</span><br><span class="line">lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址</span><br><span class="line">mov r9b, 1 ; Alertable 将r9b赋值为1</span><br><span class="line">xor r8d, r8d ; WaitMode r8d置为0</span><br><span class="line">xor edx, edx ; WaitReason edx置为0</span><br><span class="line">mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0</span><br><span class="line">call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。</span><br><span class="line">loc_403A09:</span><br><span class="line">mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eax</span><br><span class="line">loc_403A0C: ; 清理栈</span><br><span class="line">add rsp, 60h ; 栈指针rsp+60h进行复位</span><br><span class="line">pop r12 ; 出栈r12</span><br><span class="line">pop rdi ; 出栈rdi</span><br><span class="line">pop rsi ; 出栈rsi</span><br><span class="line">pop rbp ; 出栈rbp</span><br><span class="line">pop rbx ; 出栈rbx</span><br><span class="line">retn</span><br><span class="line">sub_4038F0 endp</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何编写一个简单内核</title>
      <link href="/2018/09/04/noteKernelProgram/"/>
      <url>/2018/09/04/noteKernelProgram/</url>
      
        <content type="html"><![CDATA[<p>编写一个简单的内核，可以再 <code>x86</code> 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。</p><span id="more"></span><h2 id="x86-机器是如何启动的"><a class="markdownIt-Anchor" href="#x86-机器是如何启动的"></a> x86 机器是如何启动的</h2><p>在我们考虑编写内核之前，让我们看看机器是如何启动并将控制转移到内核的。</p><p>上电后，<code>x86 CPU</code>的大多数寄存器都有明确定义的值。指令指针（<code>EIP</code>）寄存器保存处理器正在执行的指令的存储器地址。<code>EIP</code>硬编码为值<code>0xFFFFFFF0</code>，因此，<code>x86 CPU</code>硬连线开始在物理地址<code>0xFFFFFFF0</code>处执行。实际上，它是<code>32</code>位地址空间的最后<code>16</code>个字节。该存储器地址称为复位向量。</p><p>现在，芯片组的内存映射确保<code>0xFFFFFFF0</code>映射到<code>BIOS</code>的某个部分，而不是<code>RAM</code>。同时，<code>BIOS</code>将自身复制到<code>RAM</code>以便更快地访问，我们称之为<code>shadowing</code>。地址<code>0xFFFFFFF0</code>只包含一条跳转指令，指向<code>BIOS</code>复制自身的内存中的地址。</p><p>到这里，<code>BIOS</code>代码开始执行。<code>BIOS</code>首先按配置的引导设备顺序搜索可引导设备。它会检查某个幻数以确定设备是否可引导（第一扇区的字节 511 和 512 是否为<code>0xAA55</code>）。</p><p>一旦<code>BIOS</code>找到可引导设备，它就会从物理地址<code>0x7c00</code>开始将设备第一个扇区的内容复制到<code>RAM</code>中，然后跳转到地址并执行刚刚加载的代码，此代码称为引导加载程序。</p><p>然后，引导加载程序将内核加载到物理地址<code>0x100000</code>。地址<code>0x100000</code>用作<code>x86</code>计算机上所有大内核的起始地址。</p><p>所有<code>x86</code>处理器都以简单的<code>16</code>位模式开始，称为实模式。<code>GRUB</code>引导加载程序通过将<code>CR0</code>寄存器的最低位设置为<code>1</code>来切换到<code>32</code>位保护模式，因此，内核以<code>32</code>位保护模式加载。</p><p>请注意，在<code>Linux</code>内核的情况下，<code>GRUB</code>会检测<code>Linux</code>启动协议并以实模式加载<code>Linux</code>内核。<code>Linux</code>内核本身可以切换到保护模式。</p><h2 id="我们需要什么"><a class="markdownIt-Anchor" href="#我们需要什么"></a> 我们需要什么</h2><ul><li><p>一台 x86 电脑</p></li><li><p>Linux</p></li><li><p>NASM 汇编程序</p></li><li><p>gcc</p></li><li><p>ld（GNU 链接器）</p></li><li><p>grub</p></li></ul><h2 id="源代码"><a class="markdownIt-Anchor" href="#源代码"></a> 源代码</h2><p>源代码可以在 Github 存储库中找到<a href="https://github.com/arjun024/mkernel">mkernel</a></p><h2 id="使用程序集的入口点"><a class="markdownIt-Anchor" href="#使用程序集的入口点"></a> 使用程序集的入口点</h2><p>我们喜欢用 C 语言编写所有内容，但我们无法避免一些组装。我们将用<code>x86</code>汇编语言编写一个小文件，以此来作为我们内核的起点。我们所有的汇编文件都会调用一个外部函数，我们将用 C 编写，然后暂停程序流程。</p><p>我们如何确保此汇编代码将作为内核的起点呢？</p><p>我们将使用链接脚本来链接目标文件以生成最终的内核可执行文件（稍后将详细解释）。在此链接描述文件中，我们将明确指定我们希望将二进制文件加载到地址<code>0x100000</code>。正如我之前所说，这个地址是内核的预期。因此，引导加载程序将负责触发内核的入口点。</p><p>这是汇编代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">;;kernel.asm</span><br><span class="line"></span><br><span class="line">bits 32                     ;nasm directive - 32 bit</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">extern kmain                ;kmain is defined in the c file</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">    cli ;block interrupts</span><br><span class="line"></span><br><span class="line">    mov esp, stack_space    ;set stack pointer</span><br><span class="line"></span><br><span class="line">    call kmain</span><br><span class="line"></span><br><span class="line">    hlt                     ;halt the CPU</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">resb 8192                   ;8KB for stack</span><br><span class="line"></span><br><span class="line">stack_space:</span><br></pre></td></tr></table></figure><p>第一条指令<code>bits 32</code>不是<code>x86</code>汇编指令，它是<code>NASM</code>汇编程序的一个指令，它指定它应该生成代码，以在<code>32</code>位模式下运行的处理器上运行。在我们的例子中，它并不是强制性的，但是这里包含了它，因为它确实是一个良好实践。</p><p>第二行开始文本部分（又名代码部分），这是我们放置所有代码的地方。</p><p><code>global</code>是另一个将源代码中的符号设置为全局的<code>NASM</code>指令，通过这样做，链接器知道符号的<code>start</code>位置，这恰好是我们的切入点。</p><p><code>kmain</code>是我们的函数，将在我们的<code>kernel.c</code>文件中定义。<code>extern</code>声明该函数在其他地方声明。</p><p>然后，我们有了<code>start</code>函数，它调用<code>kmain</code>函数并使用<code>hlt</code>指令暂停<code>CPU</code>。中断可以从<code>hlt</code>指令中唤醒<code>CPU</code>，所以我们事先使用<code>cli</code>指令禁用中断。<code>cli</code>是明显中断的缩写。</p><p>理想情况下，我们应该为堆栈留出一些内存并将堆栈指针（<code>esp</code>）指向它。但是，似乎<code>GRUB</code>这样做就已经设置了堆栈指针。但是，为了以防万一，我们将在<code>BSS</code>部分中分配一些空间，并将堆栈指针指向分配的内存的开头。我们使用<code>resb</code>以字节为单位保留内存的指令，在它之后，留下一个标签，指向保留的内存块的边缘。在<code>kmain</code>调用之前，堆栈指针（<code>esp</code>）使用<code>mov</code>指令使指向该空间。</p><h2 id="c-中的内核"><a class="markdownIt-Anchor" href="#c-中的内核"></a> C 中的内核</h2><p>在<code>kernel.asm</code>，我们调用了该函数<code>kmain()</code>。所以我们的<code>C</code>代码将开始执行<code>kmain()</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  kernel.c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">kmain</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = <span class="string">&quot;my first kernel&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> *vidptr = (<span class="keyword">char</span>*)<span class="number">0xb8000</span>; <span class="comment">//video mem begins here.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this loops clears the screen</span></span><br><span class="line"><span class="comment">     * there are 25 lines each of 80 columns; each element takes 2 bytes</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span>(j &lt; <span class="number">80</span> * <span class="number">25</span> * <span class="number">2</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* blank character */</span></span><br><span class="line"></span><br><span class="line">        vidptr[j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attribute-byte - light grey on black screen */</span></span><br><span class="line"></span><br><span class="line">        vidptr[j+<span class="number">1</span>] = <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">        j = j + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    j = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* this loop writes the string to video memory */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(str[j] != <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* the character&#x27;s ascii */</span></span><br><span class="line"></span><br><span class="line">        vidptr[i] = str[j];</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* attribute-byte: give character black bg and light grey fg */</span></span><br><span class="line"></span><br><span class="line">        vidptr[i+<span class="number">1</span>] = <span class="number">0x07</span>;</span><br><span class="line"></span><br><span class="line">        ++j;</span><br><span class="line"></span><br><span class="line">        i = i + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们所有的内核都会清除屏幕并写入字符串“我的第一个内核”。</p><p>首先，我们创建一个指向<code>vidptr</code>地址<code>0xb8000</code>的指针，该地址是受保护模式下的视频内存的开始。屏幕的文本内存只是我们地址空间中的一块内存，屏幕的内存映射输入/输出从<code>0xb8000</code>开始，支持<code>25</code>行，每行包含<code>80</code>个<code>ASCII</code>字符。</p><p>该文本存储器中的每个字符元素由<code>16位</code>（<code>2字节</code>）表示，而不是我们习惯的<code>8位</code>（<code>1字节</code>）。第一个字节应该具有<code>ASCII</code>中的字符表示，第二个字节是<code>attribute-byte</code>。这描述了其特征属性，比如说颜色。</p><p>如果要<code>s</code>在黑色背景上打印绿色字符，我们只需要将字符<code>s</code>存储在视频存储器地址的第一个字节中，将值<code>0x02</code>存储在第二个字节中即可。<code>0</code>代表黑色背景，<code>2</code>代表绿色前景。</p><p>请查看下表中的不同颜色：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">0 - Black,</span><br><span class="line">1 - Blue,</span><br><span class="line">2 - Green,</span><br><span class="line">3 - Cyan,</span><br><span class="line">4 - Red,</span><br><span class="line">5 - Magenta,</span><br><span class="line">6 - Brown,</span><br><span class="line">7 - Light Grey,</span><br><span class="line">8 - Dark Grey,</span><br><span class="line">9 - Light Blue,</span><br><span class="line">10/a - Light Green,</span><br><span class="line">11/b - Light Cyan,</span><br><span class="line">12/c - Light Red,</span><br><span class="line">13/d - Light Magenta,</span><br><span class="line">14/e - Light Brown,</span><br><span class="line">15/f – White.</span><br></pre></td></tr></table></figure><p>在我们的内核中，我们将在黑色背景上使用浅灰色字符，所以我们的属性字节必须具有值<code>0x07</code>。</p><p>在第一个<code>while</code>循环中，程序在 25 行的 80 列中写入具有<code>0x07</code>属性的空白字符，这样就可以清除屏幕。</p><p>在第二个<code>while</code>循环中，空终止字符串<code>“my first kernel”</code>的字符被写入视频内存块，每个字符保存一个<code>0x07</code>的属性字节。</p><p>这将会在屏幕上显示字符串。</p><h2 id="链接部分"><a class="markdownIt-Anchor" href="#链接部分"></a> 链接部分</h2><p>我们将<code>kernel.asm</code>与<code>NASM</code>组装成一个目标文件，然后使用<code>GCC</code>，将<code>kernel.c</code>编译成另一个目标文件。现在，我们的工作是将这些对象链接到可执行的可引导内核。</p><p>为此，我们使用显式链接脚本，它可以作为参数传递给<code>ld</code>（我们的链接器）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line"> *  link.ld</span><br><span class="line"></span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">OUTPUT_FORMAT(elf32-i386)</span><br><span class="line"></span><br><span class="line">ENTRY(start)</span><br><span class="line"></span><br><span class="line">SECTIONS &#123;</span><br><span class="line"></span><br><span class="line">   . = 0x100000;</span><br><span class="line"></span><br><span class="line">   .text : &#123; *(.text) &#125;</span><br><span class="line"></span><br><span class="line">   .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">   .bss  : &#123; *(.bss)  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们将输出可执行文件的输出格式设置为<code>32位</code>可执行文件和可链接格式（<code>ELF</code>）。ELF 是<code>x86</code>架构上类<code>Unix</code>系统的标准二进制文件格式。</p><p><code>ENTRY</code>有一个论点，它指定应该是我们的可执行文件的入口点的符号名称。</p><p><code>SECTIONS</code>是我们最重要的部分，在这里，我们定义可执行文件的布局。我们可以指定如何合并不同的部分以及每个部分的放置位置。</p><p>在<code>SECTIONS</code>语句后面的大括号内，句点字符（<code>.</code>）表示位置计数器。</p><p>在<code>SECTIONS</code>块的开头，位置计数器始终初始化为<code>0x0</code>，这可以通过为其分配新值来修改它。</p><p>记住前文中说过的，内核的代码应该从地址<code>0x100000</code>开始，所以我们将位置计数器设置为<code>0x100000</code>。</p><p>看看下一行<code>.text：&#123;*（.text）&#125;</code></p><p>星号（<code>*</code>）是一个匹配任何文件名的通配符，因此，表达式<code>*(.text)</code>表示<code>.text</code>来自所有输入文件的所有输入节。</p><p>因此，链接器将目标文件的所有文本部分，合并到位置计数器中存储地址的可执行文件部分，所以我们的可执行文件的代码部分从<code>0x100000</code>开始。</p><p>链接器放置文本输出节之后，位置计数器的值将变为<code>0x1000000 +</code>文本输出节的大小。</p><p>类似的，数据和<code>bss</code>部分被合并并放置在<code>location-counter</code>的<code>then</code>值处。</p><h2 id="grub-和-multiboot"><a class="markdownIt-Anchor" href="#grub-和-multiboot"></a> Grub 和 Multiboot</h2><p>现在，我们准备好构建内核的所有文件。但是，既然我们想用<code>GRUB</code>引导程序引导我们的内核，那么还有一步。</p><p>有一个使用引导加载程序加载各种<code>x86</code>内核的标准，称为<code>Multiboot spec</code>（多重引导规范）。</p><p>如果<code>GRUB</code>符合<code>Multiboot</code>规范，它将只加载我们的内核。</p><p>根据规范，内核必须在其前<code>8个千字节</code>内包含一个头，称为<code>Multiboot header</code>（多引导头）。</p><p>此外，此<code>Multiboot</code>标头必须包含<code>3个字节</code>，即 4 字节对齐，即：</p><ul><li><p>一个魔术字段（<code>magic field</code>）：包含幻数<code>0x1BADB002</code>，以识别头部。</p></li><li><p>一个标志字段（<code>flags field</code>）：我们不关心这个字段，只需将其设置为零。</p></li><li><p>一个校验字段（<code>checksum field</code>）：添加<code>“magic”</code>和<code>“flags”</code>的校验字段必须为零。</p></li></ul><p>所以我们的<code>kernel.asm</code>就会变成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">;;kernel.asm</span><br><span class="line"></span><br><span class="line">;nasm directive - 32 bit</span><br><span class="line"></span><br><span class="line">bits 32</span><br><span class="line"></span><br><span class="line">section .text</span><br><span class="line"></span><br><span class="line">        ;multiboot spec</span><br><span class="line"></span><br><span class="line">        align 4</span><br><span class="line"></span><br><span class="line">        dd 0x1BADB002               ;magic</span><br><span class="line"></span><br><span class="line">        dd 0x00                     ;flags</span><br><span class="line"></span><br><span class="line">        dd - (0x1BADB002 + 0x00)    ;checksum. m+f+c should be zero</span><br><span class="line"></span><br><span class="line">global start</span><br><span class="line"></span><br><span class="line">extern kmain                        ;kmain is defined in the c file</span><br><span class="line"></span><br><span class="line">start:</span><br><span class="line"></span><br><span class="line">  cli ;block interrupts</span><br><span class="line"></span><br><span class="line">  mov esp, stack_space              ;set stack pointer</span><br><span class="line"></span><br><span class="line">  call kmain</span><br><span class="line"></span><br><span class="line">  hlt ;halt the CPU</span><br><span class="line"></span><br><span class="line">section .bss</span><br><span class="line"></span><br><span class="line">resb 8192                           ;8KB for stack</span><br><span class="line"></span><br><span class="line">stack_space:</span><br></pre></td></tr></table></figure><p><code>DD</code>定义大小为 4 个字节的双字。</p><h2 id="构建内核"><a class="markdownIt-Anchor" href="#构建内核"></a> 构建内核</h2><p>现在，我们将创建从目标文件<code>kernel.asm</code>和<code>kernel.c</code>，然后使用我们的链接脚本链接。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nasm -f elf32 kernel.asm -o kasm.o</span><br></pre></td></tr></table></figure><p>将运行汇编程序以<code>ELF-32位</code>格式创建目标文件<code>kasm.o</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -m32 -c kernel.c -o kc.o</span><br></pre></td></tr></table></figure><p><code>'-c'</code>选项确保在编译之后，链接不会隐式发生。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o</span><br></pre></td></tr></table></figure><p>将使用我们的链接描述文件运行链接器并生成名为<code>kernel</code>的可执行文件。</p><h2 id="配置你的-grub-并运行你的内核"><a class="markdownIt-Anchor" href="#配置你的-grub-并运行你的内核"></a> 配置你的 grub 并运行你的内核</h2><p><code>GRUB</code>要求您的内核具有名称模式<code>kernel-&lt;version&gt;</code>，所以，我们需要重命名内核。我将内核可执行文件重命名为<code>kernel-701</code>。</p><p>现在将它放在<code>/ boot</code>目录中。（需要超级用户权限才能执行此操作。）</p><p>在<code>GRUB</code>配置文件中，<code>grub.cfg</code>应该添加一个条目，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">title myKernelroot (hd0,0)kernel /boot/kernel-701 ro</span><br></pre></td></tr></table></figure><p>不要忘记删除指令<code>hiddenmenu</code>（如果存在的话）。</p><p>重新启动计算机，你将获得列出内核名称的列表选择。</p><p>那就是你的内核!!</p><h2 id="ps"><a class="markdownIt-Anchor" href="#ps"></a> PS</h2><ul><li><p>始终建议给自己设置一个虚拟机，用于各种内核黑客攻击。</p></li><li><p>要在<code>grub2</code> 上运行它，这是新发行版的默认引导加载程序，你的配置应如下所示：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">menuentry &#x27;kernel 701&#x27; &#123;set root=&#x27;hd0,msdos1&#x27;multiboot /boot/kernel-701 ro&#125;</span><br></pre></td></tr></table></figure><ul><li>此外，如果您想在 qemu 模拟器上运行内核而不是使用 GRUB 启动内核，你可以通过以下方式执行此操作：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-system-i386 -kernel kernel</span><br></pre></td></tr></table></figure><h2 id="参考和感谢"><a class="markdownIt-Anchor" href="#参考和感谢"></a> 参考和感谢</h2><ol><li><p><a href="https://github.com/arjun024/mkernel">arjun024 的源码及思路</a></p></li><li><p><a href="http://wiki.osdev.org">wiki.osdev.org</a></p></li><li><p><a href="http://osdever.net">osdever.net</a></p></li><li><p>Multiboot spec</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何判断员工持股计划是否靠谱</title>
      <link href="/2018/03/26/stocksCom/"/>
      <url>/2018/03/26/stocksCom/</url>
      
        <content type="html"><![CDATA[<p>公司的本意是希望公司发展好，员工多赚钱，但其中也不乏很多公司都是在发展不顺、股票大幅下跌等情况下，为了稳定人心、稳住股价，推出员工持股计划。</p><span id="more"></span><p>这样不确定因素太多，容易成为接盘侠。目前员工持股绝大部分是亏的（数据可以自己搜一下，从股市、工商信息这几个官方渠道去搜），不要只盯着那几家发展好的公司，用幸存者偏差去看待员工持股这件事，要看全盘数据案例。</p><p>首先，员工持股计划是通过二级市场买入，如果你看好公司未来前景，完全可以自己买，无需通过公司的员工持股计划买入。<br />当行情不好的时候你自主购买的股票可以随时卖出止损，员工持股是做不到的，员工持股一般是统一管理和操作。，当公司的员工持股计划亏50%以上，算上1:1的杠杆实际上本金早就没了。</p><h2 id="公司为什么热衷于员工持股"><a class="markdownIt-Anchor" href="#公司为什么热衷于员工持股"></a> 公司为什么热衷于员工持股？</h2><ol><li>给广大投资者以信心炒高股价；</li><li>股价高质押股票可以融到更多的钱；</li><li>稳定公司人员，股票赚了皆大欢喜你不会走，股票亏了你等着公司兜底更不会走（一般员工持股老板都会明示或暗示兜底）</li></ol><p>那么，问题来了，绝大部分的员工持股都是亏的怎么办？</p><p>通常的做法都是展期，有一年的，有两年的，反正就一个字，拖。其中有一部分公司在大幅亏损的情况下选择终止员工持股计划，这些公司都有一个共同的特点就是配资部分超过了1:1，这个在资管新规出来以后是不符合规定的，所以必须要卖出。</p><p>整个员工持股计划的周期一般在2年左右，也有3年的，加上展期3～5年很常见，试问职业生涯有几个3、5年？</p><h2 id="作为员工如何破局"><a class="markdownIt-Anchor" href="#作为员工如何破局"></a> 作为员工如何破局？</h2><p>要回归本质，要了解自己公司的前景如何，发展会不会比现在更好，创始人人品如何？投资人或投资团队操作过的案例（对资金流进行溯源）及风评怎样？</p><p>核心思想，要做价值投资，以上只是价值投资的参考因素。</p><p>参与公司员工持股计划，实际上是一种以员工身份进行的投资行为。因此，重点在两方面：</p><p>其一，你是否愿意将自己与公司绑定一段时间？这个需要认真考虑。</p><p>其二，既然是投资行为，成本、收益、风险如何，值得认真衡量。</p><p>总结下来就是，公司是否值得你为之奋斗？投资的渠道非常广泛，投资公司是否是你所知道的最佳投资方式？</p><p>同时，还要考虑以下几个问题：</p><ol><li>员工持股的实施方式，一定程度决定了参与员工持股计划的成本。员工持股的实施方式通常是员工自己掏钱在二级市场或者通过公司进行非公开发行取得公司股份。不过有的上市公司员工持股的股份由控股的股东直接赠送给员工，显然相对来说后者更有诱惑力。</li><li>个人职业发展定位。员工持股计划对股份通常有一定时间的锁定的。比如一到三年。那么这段期间，公司通常不愿意看到员工离职的，如果离职，也往往不能继续持有通过员工持股计划取得的相应股份，可能需要自己在离职前进行转售。如果你有换工作的打算，见鬼去吧。</li><li>公司的的行业地位与发展前景。参与员工持股计划最终能否取得收益，完全取决于持股计划到期时公司股票在二级市场的交易价格与最初股票购买价格的差额。因此，而持股计划到期时公司股票的交易价格与公司的行业地位与发展前景具有一定的关联性。</li><li>员工持股计划实时性A股大盘行情。A股股市不同年份股指波动较大，如果员工持股计划在牛市时实施，若干年后大盘转熊的概率比较大，这个时候可能员工持股计划获得的收益将及其有限。</li><li>持股计划的结构化安排和个人的风险偏好。为了扩大员工在持股计划获得的收益额，可能会对员工持股计划进行结构化的安排，为员工在银行取得一定比例的配资额，进行杆杠化操作。如果进行1：3的杆杠化，如果员工持股计划股票买入价格10元，员工持股计划到期时，股票价格20元，不考虑员工持股计划的管理费用、银行配资的成本，那么员工可以获得4倍的收益（如果没有杆杠化，只能获得1倍的收益）。相反的，如果到时候亏损，同样会扩大个人的亏损额度。因此要进行权衡。如果公司控股股东能够对该亏损进行兜底，则员工个人风险会小很多。</li></ol><p>归根结底，要做价值投资。投资需谨慎，谁的钱都不是大风刮来的。</p>]]></content>
      
      
      <categories>
          
          <category> stocks </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>碎碎念</title>
      <link href="/2016/08/01/lifeMind/"/>
      <url>/2016/08/01/lifeMind/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉，这个密码看着不太对，请再试试。" data-whm="抱歉，这个文章不能被纠正，不过您还是能看看解密后的内容。">  <script id="hbeData" type="hbeData" data-hmacdigest="fcc4d164664986e0d0338a0d73dbec78c80c5c65bf8ee00c30ba3ef5c8279c35">c6499caab5bf0a89de423ff0eaf2d543e46f11ce84886c432231de3df175b274ca4c9f82dea0937ba39b8f5643c003a952a3a8a4f08f42b99aa2d829a5a966bb416078aee9f331da95b8aa46d0c833669bf8f273b72cb7f57d50af0c1cb720a0f5785ba7a9a5b4fddce41c2d85a6d590200f9d4e6edc4d34ab327c2998981d569cd4e7501c6505a2ce1650c346ba1714d4ebc9972e0aa50e0fa406739e99eff13571d123b14a33f9cb4c9a896b6f9748962b0a691cbf1afba33c3eedd4efbcf4d49082e0750b1cc5447eccc72f66b61dad1b79c0d7cd6661a3829f99dc2e43c9671ea477f18acf9194b5b18702cc5f1bd80bf46fe86a82c5388c680fe7d91456b0b03b37f26e076231383cff95b6c139c41d8fb02b61d22996e1db64a9ce5507cfd294ebf01a6446fb643d91b904b98b2e324f37da61e74eec07694dc8a808cb559bbfa0d56ff86ce1300ededc90c29c290ffe598549cc03f320fd9459a2cdf10ba414baf0dacc574f469adae74266ef5a7881e2ce04cc8f98e319b5b482de44f2f4c547f3a9368390c1022227ee34bff56de618f0b7bc299617e1d88341fa728eda6f7943428dee60cbddf2f55987f157c7b0210987c7bf06ee2cabdbf699763c035eaa4f918907be6d4cda9249933e5d49a2085ef676ef424db657e9fbf36c88d587fa9ff91edf9fa90a56a613f1e6ccb09d3a98c0d2ceba1a5743d4d91333083b2ef4017292363551c311190d1a1176959570fdf64d4a4fb31cb540fa40d4ab3045912343985855b3d3439f94a5ee05d50d20783162b22356af230492d451a0c11b4a363d9cd1f74ba04b6befc89570da866564cdd773f35e626dc1db44b4743c5fe4bd6f1d7ecd726d359c56774f27444eeeafe3dfbfaa5d47c8576c6b140afe67b0bb5959b28a5f9b955e79e7c4d86b52589776a6ce0081cc68f8a292cea02453e2e4f9db6a3379de13cbf8484050b6ae721e2188c0c2805d7d86b43c352133db3320d06e1ac6d84245aea3f37650b656a7c473e20568e1f09175f9013aeefe576cf906cf5ac0e9deb8a1f7647afec824bfa0c66ad757839bd37d853d18babb919e1d4592e8fcd36db2d12a2b9c1d9ef2f297227e849f372fe9e227c867989f30133b00405bc794ed8133a135c8a171545c09b76e28fbf8ed1c4e48a7ce7418f365bea54774523a2063724b068c3c7f192fd36231199184e98fa6fe53bf999efa9128d203d8277cf643470b6e1650938b9375def5b64a62bc01c854bded7e74d5178ae5a9acc95faa1746af6b42aef14bc9ff96bdd1446fc17cd46400d8b32caad6046933453c79583d2faeb651ae3dc3003fc082a1d6a4859917f002f7e6d55e205efd869bf9a68fa4c57f57de10a4091cb2db1150e4dc2efe50c98a64fcd839fcabd24f2e7f39a7a380100dfaa399246ccf6014a523114af6e21cff0b1c6014618878f3e8a936bf86a72b8e57221b81ef6f969779abfb0d09b9dc1a06d28b37c7895e258aea0828771de704c54d12f5aa33ab5b2b65d51a2a59b48124e444aeff77885d897828ef6e5fd93bc4c27b4c133f673ad987160de2c132aa9added485c0ab7f2426974222c95a9f01ebcc6150754ca9e0d9149fca348e04f10d727957209fd4f8974df0afd26b0ce260bdc7f0880a9d6253613803fba1219a35dfa90856a425b2e2574004cb9d7a05df8fa92aafdc85ee97ac06fbe21563efd0ec141ec045fcaba90991fecbcdd68e9661a4eb61699695f58f7ee503d7fd93231b278785f703240675702760a844da01da6c84ea6e969d860ab7a3ed3665b15af8dea44bdd0880f696cf0fc3c1342f53988a92591cec837c94443019c926a45eebdbc1bd4b938450557d8492046ea659c7213f17088122cc8de477bb444a6bf54e2bb3f45845b5f787ac40d11c6e30b267325ff133d5636f317ab1622069e384424253f8ca915820efe96022f29f4704e6d0e970505ab44eb65878e08dade82ed19b96ccce77f3d46a4060ca83dd4c34983aa6fafdf88d55cd783ac10a4f07c22a610167f57e6e1fea6bf0352d80cf58ad02a199b7083a1621d43a9dc1996f9cef10ae303e1e6b54dc99be35df92274beef05f60793ef700b8371433acfb1ba9916277aaa35eee21f0772fa057cdc14ffa1384e3558a09fa871bcd46b6e1f50813bbcd2e1c022e33456291faf392987b35aea0bf6562a667554af1f14c9726907024459b76726ac8d38b66fe8d8615a4ccdb5a98bcba5d16cd80bb73491fc1d279e5373cab3619df24b0bf868586eb9e9489408930235cdfe641a7fc7d2f6323bcf1f722f2fae711dbecee3949b035f5ead5f288de21da9f55428399c22bbad6e4762ba268cd67dab3ac4e309be6c3aa621636a70cfa9e203bf3643b847c7a7a21d1f457d77407744260d23f7d8bf53a9ea6c52443012dab540e6a6f7d88818713320ab5caf7a158dce8f42c3873bcd25952b1f115b7e014190aff69a7ea548182b6fb96b9314f464cb1ce87704690f3cf08e2d7f1cdd9fb0ea5250ae9b1d655448ae9622ef7f22556ebe603505344562daa6d0f4b642a83a5c69a690248acd10fa12de49aee325e26705a32e0cac92f1a5aae0fa13a39a7925e558cb2a1300bf9d16ac40071a87ebd8241e01a3d80a47076d3331e94a3d372958da7c877fd7e3a344373d2b928b41a8c849cc7375d02ea4db2b4c1cdca050be2ead131dab2f9ac511e9fa95467883c8e697a1145f90dab609476fc5a762e7c6268e84fd71635273823e1d4175bde6932c88a7c9b8ecc56301369444e2f4d6634cb3fa13f20a6dcaf0673712625e3e52a94e708502aad5835707ecfc14fbd61d22d0cb787c3fd6d95cd8ec51eccf62ca04c7d8636e427a6997839addd8a1a2294fbb34aa47058001206ebce821c9a19b6615603dd952d80065d87ce30affdff5590cf352fc0fe78d270d15d9dca66a60d7e382e86b2a149eb72f8bd2353439e030a7e31da5e00f18d9b20fab87ef6e40d91393b806a7cd5728a68f9938f5139e4a92acdd6c96791bdef6eb1be8d687e0a5d2d39381002ad096d62471d876ae0db3fe9981c374f8a75a7eb8817647893c2ec208d095c3ce0049d352e3f02ca7ffc2e731cf3b61115cd1f1556f8aa1a152791f1f77ce657b7b55b46882df1adfd8d0f0c88bd8c34d5281f3e54ec5255cd7b4f67c293206db643d749fcfe3b6357d70b3e25230e90013fd1b7f76455d616f78783a474fcdaa55fa62e1d4857910bd18aa570b5e91d3861ae49b8896be7edcbf7ac85c691e6abec06e50845f54a380f7855c9b566e620f9da9c0b6a8c08d829f0210e7ace64ee0aa3eddc43d900e87de864f349fae5bbdef208572979d1f127190cafec6ee4c0b8240fe48cdf8d7fa94f368cdf843cd66d0075c87dd2623be693471bc23f7904437ff67c250c51a0ffaf69a408c83e1d4075f4e7501468ab2fe8bf797b1ec55c17ed28a6221a0714af2424a5ce36e6ad613a4529ad0e7529771102b0be4bd17125ea26a89e133a3c50330d7849fac327b1aae17b5224a9227265716dab791c04804a3a9b553a3b50b5f52173b44f254d849ab255550dadfe0a7e622ed1199b60642b6563eeffd1f77a362a69660294119c1f138a7aac912359ad7df87f872b5b7a3a8b1527beee3394e20e065a7ebc5a8c57264a2794eac4396ba174cb2986b15df7e143e3b297c037a7ded49e1d9c6e08196a9f9e530597aced7f82900cd8f240961c31536968e4315e41459130966d701f60bdc2e79bc3f5674601ff6e0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好，这里需要密码。</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>利用多核CPU加速Linux命令</title>
      <link href="/2015/08/14/tipsLinuxCommand/"/>
      <url>/2015/08/14/tipsLinuxCommand/</url>
      
        <content type="html"><![CDATA[<p>要想让<code>Linux</code>命令使用所有的<code>CPU</code>内核，我们需要用到<code>GNU Parallel</code>命令，它让我们所有的<code>CPU</code>内核在单机内做神奇的<code>map-reduce</code>操作，当然，这还要借助很少用到的<code>–pipes 参数(也叫做–spreadstdin)</code>。这样，你的负载就会平均分配到各<code>CPU</code>上。</p><span id="more"></span><p>你是否曾经有过要计算一个非常大的数据(几百 GB)的需求？或在里面搜索，或其它操作——一些无法并行的操作。数据专家们，我是在对你们说。你可能有一个 4 核或更多核的 CPU，但我们合适的工具，例如 <code>grep</code>, <code>bzip2</code>, <code>wc</code>, <code>awk</code>, <code>sed</code>等等，都是单线程的，只能使用一个 CPU 内核。</p><p>借用卡通人物 Cartman 的话，“如何我能使用这些内核”?</p><p>要想让 Linux 命令使用所有的 CPU 内核，我们需要用到<a href="https://www.gnu.org/software/parallel/">GNU Parallel</a>命令，它让我们所有的 CPU 内核在单机内做神奇的 map-reduce 操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各 CPU 上，真的。</p><h2 id="bzip2"><a class="markdownIt-Anchor" href="#bzip2"></a> BZIP2</h2><p>bzip2 是比 gzip 更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。<br />以前的做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.bin | bzip2 –best &gt; compressedfile.bz2</span><br></pre></td></tr></table></figure><p>现在这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.bin | parallel –pipe –recend ” -k bzip2 –best &gt; compressedfile.bz2</span><br></pre></td></tr></table></figure><p>尤其是针对 bzip2，GNU parallel 在多核 CPU 上是超级的快。你一不留神，它就执行完成了。</p><h2 id="grep"><a class="markdownIt-Anchor" href="#grep"></a> GREP</h2><p>如果你有一个非常大的文本文件，以前你可能会这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep pattern bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你可以这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel  –pipe grep ‘pattern’</span><br></pre></td></tr></table></figure><p>或者这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel –block 10M –pipe grep ‘pattern’</span><br></pre></td></tr></table></figure><p>这第二种用法使用了 <code>–block 10</code>M 参数，这是说每个内核处理 1 千万行——你可以用这个参数来调整每个 CUP 内核处理多少行数据。</p><h2 id="awk"><a class="markdownIt-Anchor" href="#awk"></a> AWK</h2><p>下面是一个用 awk 命令计算一个非常大的数据文件的例子。<br />常规用法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat rands20M.txt | awk ‘&#123;s+=<span class="variable">$1</span>&#125; END &#123;<span class="built_in">print</span> s&#125;’</span><br></pre></td></tr></table></figure><p>现在这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat rands20M.txt | parallel –pipe awk \<span class="string">&#x27;&#123;s+=\$1&#125; END &#123;print s&#125;\’ | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’</span></span><br></pre></td></tr></table></figure><p>这个有点复杂：<code>parallel</code>命令中的<code>–pipe</code>参数将<code>cat</code>输出分成多个块分派给<code>awk</code>调用，形成了很多子计算操作。这些子计算经过第二个管道进入了同一个<code>awk</code>命令，从而输出最终结果。第一个<code>awk</code>有三个反斜杠，这是<code>GNU parallel</code>调用<code>awk</code>的需要。</p><h2 id="wc"><a class="markdownIt-Anchor" href="#wc"></a> WC</h2><p>想要最快的速度计算一个文件的行数吗？<br />传统做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc -l bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你应该这样：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel  –pipe wc -l | awk ‘&#123;s+=<span class="variable">$1</span>&#125; END &#123;<span class="built_in">print</span> s&#125;’</span><br></pre></td></tr></table></figure><p>非常的巧妙，先使用<code>parallel</code>命令<code>mapping</code>出大量的<code>wc -l</code>调用，形成子计算，最后通过管道发送给<code>awk</code>进行汇总。</p><h2 id="sed"><a class="markdownIt-Anchor" href="#sed"></a> SED</h2><p>想在一个巨大的文件里使用 sed 命令做大量的替换操作吗？<br />常规做法：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed s^old^new^g bigfile.txt</span><br></pre></td></tr></table></figure><p>现在你可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat bigfile.txt | parallel –pipe sed s^old^new^g</span><br></pre></td></tr></table></figure><p>然后你可以使用管道把输出存储到指定的文件里。</p>]]></content>
      
      
      <categories>
          
          <category> tips </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Plan Do Review</title>
      <link href="/2015/03/20/lifePersonPlan/"/>
      <url>/2015/03/20/lifePersonPlan/</url>
      
        <content type="html"><![CDATA[<p>凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。</p><span id="more"></span><h2 id="个人成长"><a class="markdownIt-Anchor" href="#个人成长"></a> 个人成长</h2><ul><li><p>确立个人方向，结合工作内容，找出对应短板</p><p>该领域主要专家们的工作是否了解？<br />相关网络协议，文件格式是否熟悉？<br />相关的技术和主要工具是否都看过？用过？</p></li><li><p>阅读只是学习过程的起点，不能止于阅读</p><p>工具的每个参数每个菜单都要看、要试；<br />学习网络协议要实际抓包分析，学习文件格式要读代码实现；<br />学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个<code>Exploit</code>；<br />细节、细节、细节，刨根问底；</p></li></ul><h2 id="建立学习参考目标"><a class="markdownIt-Anchor" href="#建立学习参考目标"></a> 建立学习参考目标</h2><ul><li><p>短期参考什么？比自己优秀的同龄人</p><p>阅读他们的文章和其他工作成果，从细节中观察他们的学习方式和工作方式。</p></li><li><p>中期参考什么？你的方向上的业内专家</p><p>了解他们的成长轨迹，跟踪他们关注的内容。</p></li><li><p>长期参考什么？业内老牌企业和先锋企业</p><p>把握行业发展、技术趋势，为未来做积累。</p></li></ul><h2 id="推荐的学习方式"><a class="markdownIt-Anchor" href="#推荐的学习方式"></a> 推荐的学习方式</h2><ul><li><p>以工具为线索</p><p>一个比较省事的学习目录：<code>Kali Linux</code></p><p>学习思路，以<code>Metasploit</code>为例：</p><pre><code>  遍历每个子目录，除了 Exploit 里面还有什么？  每个工具分别有什么功能？原理是什么？涉及哪些知识？  能否改进优化？能否发展、组合出新的功能？</code></pre></li><li><p>以专家为线索</p><p>你的技术方向里有哪些专家？</p><p>他们的邮箱、主页、社交网络账号是什么？</p><p>他们在该方向上有哪些作品？发表过哪些演讲？</p><p>跟踪关注，一个一个学。</p></li></ul><h2 id="处理好学习-工作和生活"><a class="markdownIt-Anchor" href="#处理好学习-工作和生活"></a> 处理好学习、工作和生活</h2><ul><li><p>学习、工作和生活是矛盾统一的</p></li><li><p>三者都需要时间，你一天只有 24 小时</p><p>调和矛盾的关键：提高效率。</p></li></ul><h2 id="如何提高效率"><a class="markdownIt-Anchor" href="#如何提高效率"></a> 如何提高效率</h2><ul><li>做好预研，收集相关前人成果，避免无谓的重复劳动</li><li>在可行性判断阶段，能找到工具就不写代码，能用脚本语言写就不要用编译语言，能把完美主义放在最终实现阶段</li><li>做好笔记并定期整理，遗忘会让所有的投入都白费</li><li>多和同事交流，别人说的一个工具的名字可能让你节约数小时</li><li>咖啡可以提高思维效率，而且合法</li><li>无论怎么提高效率，要成为专家，都需要大量的时间投入</li></ul>]]></content>
      
      
      <categories>
          
          <category> life </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
