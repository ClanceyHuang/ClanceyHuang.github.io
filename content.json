{"meta":{"title":"Kirk","subtitle":"debug.cool","description":"debug","author":"ClanceyHuang","url":"http://debug.cool","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-08-03T02:09:36.655Z","updated":"2021-08-03T02:09:36.655Z","comments":false,"path":"/404.html","permalink":"http://debug.cool/404.html","excerpt":"","text":""},{"title":"Categories","date":"2021-08-03T02:09:36.665Z","updated":"2021-08-03T02:09:36.665Z","comments":false,"path":"categories/index.html","permalink":"http://debug.cool/categories/index.html","excerpt":"","text":""},{"title":"About","date":"2021-08-03T03:07:37.054Z","updated":"2021-08-03T03:07:37.054Z","comments":false,"path":"about/index.html","permalink":"http://debug.cool/about/index.html","excerpt":"","text":"Hi, I am Kirk! 👋 🔭 普普通通的代码搬砖工一名。 🌱 国内某 “末端” 邮电学校计算机专业，目前在某 “Low Tech” 公司&quot;混日子&quot;。 ⚡ 周末爱睡觉、看书等冬眠类型活动。 💬 欢迎一起玩耍、一起搞事~~~ ClanceyHuang#outlook.com"},{"title":"Links","date":"2021-08-03T02:09:36.717Z","updated":"2021-08-03T02:09:36.717Z","comments":true,"path":"links/index.html","permalink":"http://debug.cool/links/index.html","excerpt":"","text":""},{"title":"Tags","date":"2021-08-03T02:09:36.718Z","updated":"2021-08-03T02:09:36.718Z","comments":false,"path":"tags/index.html","permalink":"http://debug.cool/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-08-03T02:09:36.718Z","updated":"2021-08-03T02:09:36.718Z","comments":false,"path":"repository/index.html","permalink":"http://debug.cool/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"一些比较有趣的代码片段","slug":"funCode","date":"2021-08-02T15:44:00.000Z","updated":"2021-08-03T03:00:46.711Z","comments":true,"path":"2021/08/02/funCode/","link":"","permalink":"http://debug.cool/2021/08/02/funCode/","excerpt":"平时应对业务需求时，自己会不知不觉看到或者写出有一些比较有趣的代码片段。","text":"平时应对业务需求时，自己会不知不觉看到或者写出有一些比较有趣的代码片段。 识别文本里时间 需求背景是用户记录会议纪要，然后程序从纪要中提取时间地点人物，用于创建待办事项。这里提供部分时间的匹配方法。这个正则真的是写到头秃。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150/** * @param string $str 需要识别的文本 * @param int $default_year 默认的年，用于填充 * @param int $default_month 默认的月，用于填充 * @param int $default_day 默认的天，用于填充 * @return mixed */function pickTimeFromStr($str,$default_year=2020,$default_month=1,$default_day=1)&#123; // test:// $str = &#x27;发布时间 2/11 发布时间 2015-2-18 18:11 发布的 2015/2/14 测试 2021年12月8日 9:30 &#x27;; $regex_list = [ &quot;/((?&lt;year&gt;\\d&#123;4&#125;)[\\/\\-\\.])?((?&lt;month&gt;\\d&#123;1,2&#125;)[\\/\\-\\.])(?&lt;day&gt;\\d&#123;1,2&#125;)?(\\s*(?&lt;amorpm&gt;(上午)|(下午)|(晚上))?((?&lt;hours&gt;\\d&#123;1,2&#125;)|(?&lt;hours_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))[\\x&#123;65f6&#125;|\\x&#123;70b9&#125;|\\:]((?&lt;mins&gt;\\d&#123;1,2&#125;)|(?&lt;mins_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;)))?/u&quot;, &quot;/((?&lt;year&gt;\\d&#123;2,4&#125;)年)?(((?&lt;month&gt;\\d&#123;1,2&#125;)|(?&lt;month_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))月)?(((?&lt;day&gt;\\d&#123;1,2&#125;)|(?&lt;day_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))日)?(\\s*(?&lt;day_const&gt;(今天)|(明天)|(后天))?(?&lt;amorpm&gt;(上午)|(下午)|(晚上))?((?&lt;hours&gt;\\d&#123;1,2&#125;)|(?&lt;hours_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))[\\x&#123;65f6&#125;|\\x&#123;70b9&#125;|\\:]((?&lt;mins&gt;\\d&#123;1,2&#125;)|(?&lt;mins_cn&gt;(一|二|三|四|五|六|七|八|九|十)&#123;1,3&#125;))?)?/u&quot;, ]; $matches = []; $date_list = []; foreach($regex_list as $regex)&#123; preg_match_all($regex, $str, $matches); if($matches[&#x27;year&#x27;])&#123; foreach ($matches[&#x27;year&#x27;] as $year_key =&gt; $year_val)&#123; // TODO： 添加错误正则保护 if (!$year_val &amp;&amp; !$matches[&#x27;month_cn&#x27;][$year_key] &amp;&amp; !$matches[&#x27;month&#x27;][$year_key] &amp;&amp; !$matches[&#x27;day_cn&#x27;][$year_key] &amp;&amp; !$matches[&#x27;day&#x27;][$year_key] &amp;&amp; !$matches[&#x27;hours_cn&#x27;][$year_key] &amp;&amp; !$matches[&#x27;hours&#x27;][$year_key] &amp;&amp; !$matches[&#x27;mins_cn&#x27;][$year_key] &amp;&amp; !$matches[&#x27;mins&#x27;][$year_key]) &#123; continue; &#125; if($year_val &amp;&amp; $year_val&lt;100)&#123;$year_val = 2000 +$year_val; &#125; $current_year = $year_val?:$default_year; // 月 if ($matches[&#x27;month_cn&#x27;][$year_key]) &#123; $current_month = checkNatInt($matches[&#x27;month_cn&#x27;][$year_key]); $current_month = $current_month ?: $default_month; &#125; else &#123; $current_month = $matches[&#x27;month&#x27;][$year_key] ?: $default_month; &#125; // 日 if ($matches[&#x27;day_cn&#x27;][$year_key]) &#123; $current_day = checkNatInt($matches[&#x27;day_cn&#x27;][$year_key]); $current_day = $current_day ?: $default_day; &#125; else &#123; $current_day = $matches[&#x27;day&#x27;][$year_key] ?: $default_day; &#125; // 中文小时 if ($matches[&#x27;hours_cn&#x27;][$year_key]) &#123; $hours = checkNatInt($matches[&#x27;hours_cn&#x27;][$year_key]); if ($matches[&#x27;amorpm&#x27;][$year_key] == &#x27;下午&#x27; || $matches[&#x27;amorpm&#x27;][$year_key] == &#x27;晚上&#x27;) &#123; $hours += 12; &#125; $current_hours = $hours?:&quot;00&quot;; &#125; else &#123; $current_hours = $matches[&#x27;hours&#x27;][$year_key]?:&quot;00&quot;; &#125; // 中文分钟 if ($matches[&#x27;mins_cn&#x27;][$year_key]) &#123; $current_mins = checkNatInt($matches[&#x27;mins_cn&#x27;][$year_key]); $current_mins = $current_mins ?: &quot;00&quot;; &#125; else &#123; $current_mins = $matches[&#x27;mins&#x27;][$year_key]?:&quot;00&quot;; &#125; if(!checkdate($current_month, $current_day, $current_year) || $current_hours&gt;23 || $current_mins&gt;59) &#123; continue; &#125; $date_val = $current_year.&quot;-&quot;.$current_month.&quot;-&quot;.$current_day.&quot; &quot;.$current_hours.&quot;:&quot;.$current_mins; $time = strtotime($date_val); if ((!$matches[&#x27;day_cn&#x27;][$year_key] &amp;&amp; !$matches[&#x27;day&#x27;][$year_key]) &amp;&amp; ($matches[&#x27;hours_cn&#x27;][$year_key] || $matches[&#x27;hours&#x27;][$year_key])) &#123; if ($matches[&#x27;day_const&#x27;] == &#x27;明天&#x27;) &#123; $time += 24 * 3600 - 1; &#125; if ($matches[&#x27;day_const&#x27;] == &#x27;后天&#x27;) &#123; $time += 24 * 3600 * 2 - 1; &#125; &#125; $date_list[] = $time; &#125; &#125; &#125; if (empty($date_list))&#123; return []; &#125;elseif(count($date_list)==1)&#123; return [&#x27;start_time&#x27;=&gt;$date_list[0],&#x27;end_time&#x27;=&gt;strtotime(date(&#x27;Y-m-d 23:59&#x27;,$date_list[0]))]; &#125;else&#123; $start_time = min($date_list); $end_time = max($date_list); $result = [&#x27;start_time&#x27;=&gt;$start_time,&#x27;end_time&#x27;=&gt;$end_time]; return $result; &#125;&#125;function checkNatInt($str) &#123; $map = [ &#x27;一&#x27; =&gt; &#x27;1&#x27;,&#x27;二&#x27; =&gt; &#x27;2&#x27;,&#x27;三&#x27; =&gt; &#x27;3&#x27;,&#x27;四&#x27; =&gt; &#x27;4&#x27;,&#x27;五&#x27; =&gt; &#x27;5&#x27;,&#x27;六&#x27; =&gt; &#x27;6&#x27;,&#x27;七&#x27; =&gt; &#x27;7&#x27;,&#x27;八&#x27; =&gt; &#x27;8&#x27;,&#x27;九&#x27; =&gt; &#x27;9&#x27;, &#x27;壹&#x27; =&gt; &#x27;1&#x27;,&#x27;贰&#x27; =&gt; &#x27;2&#x27;,&#x27;叁&#x27; =&gt; &#x27;3&#x27;,&#x27;肆&#x27; =&gt; &#x27;4&#x27;,&#x27;伍&#x27; =&gt; &#x27;5&#x27;,&#x27;陆&#x27; =&gt; &#x27;6&#x27;,&#x27;柒&#x27; =&gt; &#x27;7&#x27;,&#x27;捌&#x27; =&gt; &#x27;8&#x27;,&#x27;玖&#x27; =&gt; &#x27;9&#x27;, &#x27;零&#x27; =&gt; &#x27;0&#x27;,&#x27;两&#x27; =&gt; &#x27;2&#x27;, &#x27;仟&#x27; =&gt; &#x27;千&#x27;,&#x27;佰&#x27; =&gt; &#x27;百&#x27;,&#x27;拾&#x27; =&gt; &#x27;十&#x27;, &#x27;万万&#x27; =&gt; &#x27;亿&#x27;, ]; $str = str_replace(array_keys($map), array_values($map), $str); $str = checkString($str, &#x27;/([\\d亿万千百十]+)/u&#x27;); $func_c2i = function ($str, $plus = false) use(&amp;$func_c2i) &#123; if(false === $plus) &#123; $plus = array(&#x27;亿&#x27; =&gt; 100000000,&#x27;万&#x27; =&gt; 10000,&#x27;千&#x27; =&gt; 1000,&#x27;百&#x27; =&gt; 100,&#x27;十&#x27; =&gt; 10,); &#125; $i = 0; if($plus) foreach($plus as $k =&gt; $v) &#123; $i++; if(strpos($str, $k) !== false) &#123; $ex = explode($k, $str, 2); $new_plus = array_slice($plus, $i, null, true); $l = $func_c2i($ex[0], $new_plus); $r = $func_c2i($ex[1], $new_plus); if($l == 0) $l = 1; return $l * $v + $r; &#125; &#125; return (int)$str; &#125;; return $func_c2i($str);&#125;function checkString($var, $check = &#x27;&#x27;, $default = &#x27;&#x27;) &#123; if (!is_string($var)) &#123; if(is_numeric($var)) &#123; $var = (string)$var; &#125; else &#123; return $default; &#125; &#125; if ($check) &#123; return (preg_match($check, $var, $ret) ? $ret[1] : $default); &#125; return $var;&#125;","categories":[],"tags":[]},{"title":"My Architect Growth Path","slug":"architectNotes","date":"2021-07-05T15:44:00.000Z","updated":"2021-08-03T02:09:36.657Z","comments":true,"path":"2021/07/05/architectNotes/","link":"","permalink":"http://debug.cool/2021/07/05/architectNotes/","excerpt":"“增删改查”业务系统的技术含量不在于如何实现，而在于如何对现实世界的抽象，如何应对复杂的需求及变更，如何把控项目的质量和进度。能否实现功能，会不会一门新技术只是程序员的基本要求，而且在信息如此发达的当下，这些已经没有任何难度，也不会成为程序员的核心竞争力，而深入理解计算机系统，设计能力，高质量代码能力，项目的把控能力才是要坚持苦练的内功也是架构师和码农的本质区别。","text":"“增删改查”业务系统的技术含量不在于如何实现，而在于如何对现实世界的抽象，如何应对复杂的需求及变更，如何把控项目的质量和进度。能否实现功能，会不会一门新技术只是程序员的基本要求，而且在信息如此发达的当下，这些已经没有任何难度，也不会成为程序员的核心竞争力，而深入理解计算机系统，设计能力，高质量代码能力，项目的把控能力才是要坚持苦练的内功也是架构师和码农的本质区别。 这段话是一位老前辈在我离职前告诉我的（老东家很好很好，只是我觉得技术到了瓶颈，想出去看看），当时我还不太理解，只是一心追求新技术的学习，觉得现有的业务已经没办法带来挑战的快感了。 现在回味过来，越来越觉得这段话的正确性，可能人都是不撞南墙不回头的吧。 这篇文章用来记录我的架构师成长之路。 0x00 考证篇 借着考证的机会，梳理自身的知识体系，同时，架构师证书的含金量还是挺高的，还是比较想拿到这张证书。 记得大三报名过一次，然后考试那天睡过头了，本质原因可能是觉得自己当时还是学生，在技术论文（一般是实际项目案例作为论文素材）模块拿不到分，也就没有那么上心。 基础知识图谱 计算机组成原理与体系结构 考模块考察分值大概在5分左右。 Flynn分类法 分类依据两个指标： 指令流 数据流 按照体系结构类型有如下区别： 单指令流单数据流SISD 结构：控制部分一个，处理器一个，主存模块一个 关键特性： 代表：单处理器系统(386,486,586) 单指令流多数据流SIMD 结构：控制部分一个，处理器多个，主存模块多个 关键特性：各处理器以异步的形式执行同一条指令 代表：并行处理机，阵列处理机，超级向量处理机 多指令流单数据流MISD 结构：控制部分多个，处理器一个，主存模块多个 关键特性：被证明不可能，至少是不实际 代表：目前没有，有文献称流水线计算机为此类 多指令流多数据流MIMD 结构：控制部分多个，处理器多个，主存模块多个 关键特性：能够实现作业、任务、指令等各级全面并行 代表：多处理机系统，多计算机 CISC和RISC CISC 复杂(根据不同的用户做不同的指令) 指令：数量多，使用频率差别大，可变长格式。 寻址方式：支持多种 实现方式：微程序控制技术（微码） 其它：研制周期长 RISC 简单 指令：数量少，使用频率接近，定长格式，大部分为单周期指令，操作寄存器(为提升效率)，只有Load/Store操作内存 寻址方式：支持方式少 实现方式：增加了通用寄存器，硬布线逻辑控制为主，适合采用流水线 其它：优化编译，有效支持高级语言。 计算机层次化存储结构 CPU读取数据先从Cache中获取，若获取不到，再从寄存器中获取。(Cache 的命中率很关键) Cache的基本概念 Cache的功能：提高CPU数据输入输出的速率，突破冯诺依曼瓶颈，即CPU与存储系统间数据传送带宽限制。 在计算机的存储体系中，Cache是访问速度最快的层次。 使用Cache改善系统性能的依据是程序的局部性原理。 如果以h代表对Cache的访问命中率，t1表示Cache的周期时间，t2表示主存储器周期时间，以读操作为例，使用Cache主存储器的系统平均周期为t3，则 t3=h*t1+(1-h)*t2 其中，1-h又称为失效率(未命中率)。 时间局部性与空间局部性 计算机在处理相关的数据和程序的时候，某些时段集中访问/读取某些数据。 Demo示例代码： 1234567int i,s=0;for(i=1;i&lt;1000;i++)&#123; for(j=1;j&lt;1000;j++)&#123; s+=j; &#125;&#125;printf(&quot;result is %d&quot;,s); 时间局部性 空间局部性 工作集理论：工作集是进程运行时间被频繁访问的页面集合。 里面的循环 100w次，s的数据在cache中，刚刚访问完，再次访问，读取高效，是时间局部性。 例如数组a中，访问了a0，又临近访问a1，访问a0时临近的数据a1其实已被取入Cache中，这就是空间的局限性。 随机存储器与只读存储器 随机存储器 DRAM (Dynamic RAM，动态RAM) - SDRAM SRAM (Static RAM，静态RAM) 只读存储器 MROM (Mask ROM 掩模式ROM) PROM (Programmable ROM，一次可编程ROM) EPROM (Erasable PROM，可擦除的PROM) 闪速存储器 (flash memory 闪存) 磁盘工作原理 流水线的基本概念 流水线周期及流水线执行时间计算 流水线吞吐率计算 流水线加速比计算 系统配置与性能评价 计算机性能指标及阿姆达尔解决方案 计算机性能评价方法 计算机性能监测方法 操作系统基本原理 进程状态转换图 前趋图 进程的同步与互斥 PV操作 PV操作练习题1 PV操作与前趋图 PV操作练习题2 死锁问题 银行家算法 页式存储、段式存储、段页式存储 页面淘汰算法 页面淘汰算法练习题 索引文件结构 树型目录结构 位示图法 数据传输控制方式 微内核操作系统 数据库系统 数据库三级模式两级映射 数据库设计过程说明 ER模型 关系代数 规范化理论 规范化理论_函数依赖 规范化理论的价值与用途 规范化理论_求候选关键字 规范化理论_范式 规范化理论_范式练习题 规范化理论_模式分解 数据库并发控制 数据库完整性约束 数据库安全 数据库备份与恢复 分布式数据库系统 数据库优化 数据仓库与数据挖掘 联邦数据库 NoSQL技术 反规范化技术 大数据基本概念 计算机网络基础 七层模型 网络技术标准与协议 网络规划与设计 无线网 网络接入技术 网络存储技术 磁盘阵列（RAID） IPv6 物联网 云计算 企业信息化战略与实施 打破信息孤岛，实现战略统一。 信息与信息化的概念 信息的定义 香农：信息就是不确定性的减少。 维纳：信息就是信息，既不是物质，也不是能量 信息的特点 客观性（真伪性）：也叫事实性，不符合事实的信息不仅没价值，还有副作用。 动态性：信息随着时间的变化而变化。 层次性：信息可分为战略级，管理级和操作级。 传递性：信息在时间上的传递即是存储，在空间上的传递即是转移或扩散。 滞后性：信息是数据加工后的产物，所以相对数据有滞后性。 扩压性：信息和实物不同，它可以扩散也可以压缩。 分享性：信息可以分享，这和物质不同，并且信息分享具有非零和性。 信息化的概念 信息化是从工业社会到信息社会的演进与交替。 信息化的主体是全体社会成员（政府、企业、团体和个人），时域就是一个长期过程，空域是经济和社会的一切领域，手段是先进社会生产工具。 信息化对组织的意义 组织结构创新：如虚拟企业、虚拟社交。 组织管理创新：实施电子政务，建立电子政府，建立电子社区以提升管理水平。 组织经营创新：利用信息化将经营和管理融为一体。 早就信息化的人才队伍：三类人才（IT专业人才，业务人才，专家型人才） 信息化标准、法律和规定 信息系统的概念 信息系统的类型 信息系统战略规划 - 方法 第一阶段：以数据处理为核心，围绕职能部分需求 企业系统规划法（BSP）：自上而下识别系统目标，自下而上设计信息系统，对组织机构的变动具有适应性。(提出了U/C矩阵，Use Create，哪些功能使用哪些数据、哪些功能建立哪些数据)。 关键成功因素法（CSF）：找实现目标的关键信息集合，从而确定开发优先次序。 战略集合转化法（SST）：把战略目标看成“信息集合”，把战略目标转变成信息系统的战略目标。 第二阶段：以企业内部MIS为核心，围绕企业整体需求。 战略数据规划法（SDP）（考虑数据全局性）、信息工程法（IE）、战略栅格法（SG）。 第三阶段：综合考虑企业内外环境，以集成为核心，围绕企业战略需求。 价值链分析法（VCA）、战略一致性模型（SAM）。 信息系统的生命周期 系统规划 初步调查、分析系统目标、子系统组成、拟实施方案、可行性研究、制定系统建设方案。 系统设计任务书(系统建设方案、实施计划) 系统分析 业务流程分析、数据与数据流程分析、软件需求分析、网络需求分析。 系统需求规格说明、软件需求规格说明书、确认测试计划、系统测试计划、初步的用户手册。 系统设计 软件架构设计、软件概要设计、详细设计、网络设计 架构设计文档、概要设计说明书、详细设计说明书、程序规格说明书、概要测试计划、详细测试计划、各类设计图 系统实施 软件编码、软件单元/集成/系统测试、综合布线 源码、单元测试、集成测试报告、操作手册 系统验收 确认测试、试运行 确认测试报告、项目验收报告 政府信息化与电子政务 政府对政府 G2G (Government To Government) 政府对企业 G2B或B2G (Government To Business) 政府对公民 G2C或C2G (Government To Citizen) 政府对公务员 G2E (Government To Employee) 企业资源计划（ERP） 演变历史 物料需求计划 MRP Material Requirement Planning 物料单系统 制造资源计划 MRPII manufacuring resourxe planning II 增加库存、分销等 企业资源计划 ERP enterprise resource planning 打通了供应链，把财务、人力资源、销售管理等纳入。 管理思想：它是思想的变革。 软件产品：但不是直接买来就用，需要个性化的开发与部署 管理系统：存在众多的子系统，这些子系统有统一的规划，是互联互通的，便于事前事中监控。 众多的子系统 财务管理 会计核算 财务管理 生产控制管理 主生产计划 物料需求计划 能力需求计划 车间控制 制造标准 人力资源管理 人力资源规划 招聘管理 工资核算 工时管理 差旅费核算 物流管理 分销管理 库存控制 采购管理 客户关系管理（CRM） 供应链管理（SCM） 商业智能（BI） 电子数据交换（EDI） 企业应用集成 电子商务 AI 区块链 软件工程 信息系统开发方法 瀑布模型 原型模型、演化模型、增量模型 螺旋模型 V模型 喷泉模型与RAD 构件组装模型（CBSD） 统一过程（UP） 敏捷开发方法 逆向工程 面向对象基本概念 UML UML-01 UML-02 UML-03 需求的分类 需求的获取 需求分析 业务流程重组（BPR）与业务流程管理（BPM） 人机界面设计 结构化设计 面向对象设计 面向对象设计（设计原则） 面向对象设计（设计模式的概念） 面向对象设计（设计模式的分类） 面向对象设计（创建型模式） 面向对象设计（结构型模式） 面向对象设计（行为型模式） 测试原则与类型 测试用例设计 测试阶段 面向对象测试 测试管理 软件调试 系统运行与维护 软件能力成熟度模型集成（CMMI） 项目管理 范围管理 时间管理 单代号网络图 双代号网络图 自由时差 甘特图 成本管理 挣值管理 质量模型 PDCA、质量保证及质量控制的介绍 质量管理工具 配置管理 风险管理 项目管理工具 软件架构设计 软件架构的概念 软件架构风格总概 软件架构风格-数据流风格 软件架构风格-调用返回风格 软件架构风格-独立构件风格 软件架构风格-虚拟机风格 软件架构风格-仓库风格 软件架构风格－CS架构 软件架构风格－BS架构 软件架构风格－富互联网应用（RIA） 软件架构风格－基于服务的架构（SOA） 软件架构风格－SOA的实现方式（WebService） 软件架构风格－SOA的实现方式（ESB） 软件架构评估－质量属性 软件架构评估方法 软件架构评估方法（ATAM） 软件架构评估方法（SAAM） 软件产品线技术 中间件技术 J2EE与NET MVC模式 MVP模式 系统安全分析与设计 信息系统安全属性 对称加密与非对称加密 信息摘要 数字签名 数字证书与PGP 设计邮件加密系统(实例) PKI公钥体系 PKI公钥体系分层情况 信息系统安全保障层次 安全审计与安全系统设计原则 各个网络层次的安全保障 网络威胁与攻击 DOS与DDOS攻击 防火墙技术 入侵检测 计算机病毒与木马 系统可靠性分析与设计 系统故障模型 可靠性指标 串联系统与并联系统可靠度计算 系统容错技术 N版本程序设计、恢复块方法、防卫式程序设计 双机容错与集群技术 法律法规与标准化知识 法律法规知识（保护期限） 法律法规知识（知识产权人确定） 法律法规知识（侵权判定） 标准化基础知识（标准的分类与标准的编号） 数学与经济管理 网络与最大流量 线性规划 运筹方法_决策 运筹方法_决策树决策表与期望货币价值 状态转移矩阵 数学建模","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Windows10下WSL开发环境搭建","slug":"tipsWSL","date":"2021-01-20T14:44:00.000Z","updated":"2021-08-03T02:09:36.664Z","comments":true,"path":"2021/01/20/tipsWSL/","link":"","permalink":"http://debug.cool/2021/01/20/tipsWSL/","excerpt":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。","text":"工作环境的一架台式机是Windows10系统，Windows系统对开发者来说并不是很友好（.net及Windows内核开发者除外，比如一些扩展包，例如PHP的swoole，在Windows上现在没有直接安装的解决方案）。 刚开始一段时间(WSL没有出来那会，也不想用虚拟机和Docker)把台式机改成Linux系统，但是呢，各种办公软件在Linux平台就很糟心了，比如微信、QQ 这些软件，在Linux没有官方版本，通过黑科技进行移植的版本会出现各种故障，比如发送文档都得做磁盘空间共享，简直让人崩溃。 如果是纯粹只负责写代码的工作场景倒无所谓了，但是需要和客户、同事进行沟通，涉及到视频、音频、文件传输，简直炸毛。。。 背景 某天装备升级强化了下，内存有16G，试着安装了Windows的WSL，这是微软自研的架构，为了兼容Linux内核。简单来讲就是Windows系统内置了一套Linux内核，直接做了系统间的映射。 准备 材料 Windows10 wsl Ubuntu18.appx WSL 环境初始化 打开Windows自带的power shell终端，执行Enable-WindowsOptionalFeature -Online -FeatureName Microsoft-Windows-Subsystem-Linux命令，就在Windows上安装好了wsl环境。 接着下载一份Ubuntu18.04镜像，同样是在power shell终端执行命令Invoke-WebRequest -Uri https://aka.ms/wsl-ubuntu-1804 -OutFile Ubuntu.appx -UseBasicParsing，当前目录路径下就会出现一个Ubuntu的appx软件，点击安装即可。 Ubuntu 配置 点击安装Ubuntu.appx后，系统会弹出一个黑色窗口，提示你输入unix系统的用户名及密码，正常配置即可。 修改镜像源 我们需要把Linux系统的软件镜像地址改成国内的镜像地址，否则安装软件包会卡到你怀疑人生，我们先到网上搜索一下Ubuntu18国内镜像源（这里选用了阿里的镜像源），源链接如下： 1234567891011# alibaba source listdeb http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ bionic-backports main restricted universe multiverse 得到需要的源链接后，再到Ubuntu系统里更改源文件即可，命令操作如下： 1234567# 先备份原文件sudo cp /etc/apt/source.list /etc/apt/source.list-back# 再更改原文件sudo vim /etc/apt/source.list# 将上面的源链接拷贝进来，再保存退出# 更新系统的源包管理sudo apt-get update &amp;&amp; sudo apt-get upgrade -y 这样，我们就配置好了国内镜像源。 部署 nginx web开发，一般web代理服务器选择apache或者nginx，这里讲nginx的部署，相应的操作命令如下： 123456# 安装nginx，等待一段时间即可。sudo apt-get install nginx# 创建我们的vhost文件夹mkdir ~/vhost# 更改nginx配置sudo vim /etc/nginx/nginx.conf 在 include /etc/nginx/site-avaliable 下引入我们的 vhost 文件夹： 1include /home/kirk/vhost/*.conf; 本地 hosts 配置下开发域名 123sudo vim /etc/hosts# 增加一条指向记录127.0.0.1 api.kirk.com 编写 vhost 文件,如 vim ~/vhost/Kirk.conf 12345678910111213141516171819202122232425262728# API 解析server &#123; listen 80; server_name api.kirk.com; # 这里的项目地址是宿主机的项目地址，因为在Windows内置的Linux系统中，读取宿主机Windows文件的方式是使用挂载的模式， # 把Windows系统盘当成挂在盘进行处理，例如/mnt/d表示Windows的D盘，我们在D盘github/kirk文件夹下写了一个php文件，里面打印一个phpinfo(); root &quot;/mnt/d/github/kirk&quot;; location / &#123; index index.php index.html error/index.html; if (!-e $request_filename) &#123; rewrite ^(.*)$ /index.php?s=/$1 last; break; &#125; autoindex off; &#125; location ~ \\.php(.*)$ &#123; # 记住这里fastcgi监听的是9004端口，后面配置php-fpm的时候会用到，因为fastcgi要和php-fpm端口保持统一 fastcgi_pass 127.0.0.1:9004; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; &#125;&#125; 保存完conf文件后，再执行sudo service nginx reload进行重载nginx的配置。 安装 php 这里选用了php74版本，具体命令如下： 12345678# 先安装一个软件中心组件sudo apt-get install software-properties-common# 再添加一个php的第三方源（因为官方源的php版本不大适用，一个是版本少，另一个是扩展包比较少）sudo add-apt-repository ppa:ondrej/php# 再刷新一下包管理器sudo apt-get update# 安装对应版本的php及扩展包，扩展包自行按需添加sudo apt-get install php7.4 php7.4-fpm php7.4-mysql php7.4-gd php7.4-mbstring php7.4-redis 处理php-fpm，操作如下： 123456# 修改php-fpm监听的端口，与nginx的fastcgi保持一致sudo vim /etc/php/74/fpm/pool.d/www.conf# 找到listen = /run/php/php7.4-fpm.sock ,并改成下面的监听配置listen = 127.0.0.1:9004# 修改保存成功后，重启php-fpm即可sudo service php7.4-fpm restart 这样打开Windows的浏览器，访问我们刚刚配置的站点http://api.kirk.com，出现php版本信息即表示配置成功。 然后，看了下性能损耗，Windows基本的应用加上wsl共消耗3G内存，还是比集成软件PHPstudy节省了一丢丢内存，最主要的是以前Windows不能安装的扩展现在可以随意安装了~ 再试着打开微信、企业微信、开发软件 IDE，好家伙，直接达到8G内存，平时半天没有回复你们信息不是故意不回，是电脑卡死了在等待。 安装 python 环境 单单只有一个php怎么玩数据呢，需要部署下python，Ubuntu自带了python3，但是我们需要按照不同项目做环境隔离，所以需要特殊处理下隔离软件的配置： 1234567891011121314151617181920212223242526# 先看看Ubuntu有没有自带python3，执行如下命令python3# 如果进入了python3操作界面，表示系统已安装，反之需要我们自己安装.# 安装命令sudo apt-get install python3# 验证是否安装pip 包管理器pip3 -V# 如果没有出现pip3的版本信息，代表系统没有安装，需要我们手动安装sudo apt-get install pip3# 安装好了之后，开始安装python虚拟环境sudo pip3 install virtualenvsudo pip3 install virtualenvwrapper# 配置包引导sudo vim ~/.bashrc# 在最后加上这几条命令，分别表示1.虚拟环境的工作目录。2.虚拟包用python3进行驱动。3.加载虚拟包执行脚本。export WORKON_HOME=$HOME/.virtualenvsexport VIRTUALENVWRAPPER_PYTHON=/usr/bin/python3source ~/.local/bin/virtualenvwrapper.sh# 保存退出后source ~/.bashrc# 这样python虚拟环境管理包就配置好了，我们可以用如下命令创建对应的虚拟环境mkvirtualenv -p python3 Kirk# 退出python虚拟环境deactive# 删除对应虚拟环境rmvirtualenv Kirk 这样通过virtualenvwrapper进行管理python的虚拟环境，从而实现不同的项目使用不同的python包管理。 其他的环境配置会陆续更新，to be continue…","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"DiyExpress - 自定义表达式计算引擎","slug":"devDiyExpress","date":"2020-12-08T16:00:00.000Z","updated":"2021-08-03T02:09:36.658Z","comments":true,"path":"2020/12/09/devDiyExpress/","link":"","permalink":"http://debug.cool/2020/12/09/devDiyExpress/","excerpt":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。","text":"我们在数据分析的业务上，经常会有一些比较脑洞大开却又很实用的需求。 比如有个场景，当我们将数据分析的”自主权“交给用户。 由用户来决定自己需要计算分析什么维度的数据，这个需求确实是一个痛点，能解决这个需求，不就是为用户创造了价值么。 因此，花了点时间写了一套自定义表达式计算引擎。 已知用户是有一定Excel公式基础的，需要提供一个交互界面让他输入他定义的类似Excel公式的一段简单公式，其中的各个参数是自定义表单中各个字段所填充的数据。如下： 1&#123;&#123;销售返现&#125;&#125;=if ( &#123;&#123;数量&#125;&#125; &gt;= 100 AND (&#123;&#123;产品类型&#125;&#125; == &#x27;产品A&#x27; OR &#123;&#123;产品类型&#125;&#125; == &#x27;产品B&#x27;), &#123;&#123;成单金额&#125;&#125; * 0.7, &#123;&#123;成单金额&#125;&#125;*0.5) + 100 双花括号里面的是指定的字段（用来代表该字段的取值 data），单引号或者双引号是指定的取值。 我们的目标是程序根据用户定义的公式计算对应的数据，那么核心点在于如何识别用户定义的公式。 依旧是被“自定义”给坑了，需要识别用户定义的公式只能上一个词法分析器了，根据大三学的编译原理，徒手撸个状态机。。 考虑到能用脚本语言就用脚本语言，技术选型用的PHP,源码放在 github 上，DiyExpress。 贮备知识点 AST 节点树 AST (Abstract Syntax Tree(抽象语法树)) 是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构。它由一堆节点（Node）组成，每个节点都表示源代码中的一种结构。不同结构用类型来区分，常见的类型有： Identifier(标识符)，BinaryExpression(二元表达式)，VariableDeclaration(变量定义)，FunctionDeclaration(函数定义)等。 AST 是编译器看的。编译器会将源码转化成 AST。如下源码: 123456var a = 42;var b = 5;function addA(d) &#123; return a + d;&#125;var c = addA(2) + b; 会换转化成这样的 AST: AST 的使用场景？ TypeScript、babel、webpack、vue-cli等都是依赖AST进行开发的。 通过AST，可以将代码转化后，再输出。比如： 代码压缩。删除没用的空格，未使用的语句，变量名替换等。 代码高亮。 将 ES6 代码转换成 ES5 代码。 给 CSS 中的某些属性加浏览器前缀-webkit-。 将 CSS 中的px转化成rem。 生成代码。最近用了ANT DESIGN PRO。 ANT DESIGN PRO 中的 umi 可以在生成页面的代码和路由时，修改路由配置的js。umi 这种方式，用户体验很好。因此，我准备用这种方式来改造我之前做的代码生成工具。修改路由配置需要通过 AST 来转换代码。 需要学习 AST 的哪些知识？ 了解 AST 常见节点的结构 了解 AST 常见节点的结构推荐通读下AST node 规范。 源码解析 将源码转化为AST。该步骤分为词法分析（Lexical Analysis）和 语法分析（Syntactic Analysis）。 解析 JavaScript 可以用@babel/parser(以前叫 Babylon)。 转换 在遍历AST时，对指定的AST节点做新增，修改或删除操作。 转换可以用@babel/traverse。 创建和验证节点可以用@babel/types。创建AST节点代码示例见这里。 生成目标代码 将上一步转换过的AST，转化为目标代码，并生成源码映射（source maps）。 生成目标代码可以用@babel/generator To be continue…","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Window10下双系统grub修复","slug":"tipsDoubleSystem","date":"2020-03-15T15:10:00.000Z","updated":"2021-08-03T02:09:36.663Z","comments":true,"path":"2020/03/15/tipsDoubleSystem/","link":"","permalink":"http://debug.cool/2020/03/15/tipsDoubleSystem/","excerpt":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。","text":"起因是我的笔记本window10在某次更新升级时，将之前设置好的双系统引导破坏了，导致进入Linux系统时提示Unknown filesystem。 首先能确定的是Linux的引导读取出了问题，才进入到了grub rescue模式。如果记得自己的Linux引导安装在哪个区块可以直接重新读取引导（这个得看你安装双系统的时候，把Linux的引导装在哪个分区），如果不记得，就执行下面的命令输出gpt分区 1ls 这样会显示出你所有的分区，再一个一个试试下面的命令（我的引导安装在gpt7区块上） 1ls (hd0,gpt7)\\boot\\grub 其他不是引导所在的分区都是提示error: unknown filesystem。找到了所在的分区会提示该目录下的文件目录。 假定你们也是(hd0,gpt7)分区，依次执行下面的命令： 1234set root=(hd0,gpt7),set prefix=(hd0,gpt7)/boot/grubinsmod normal,normal 执行完毕会进入Linux启动的图形界面。 进入Linux系统后，打开终端执行以下命令重新安装grub引导： 12sudo update-grubsudo grub-install /dev/sda 再重启，就能恢复到正常Linux的启动引导了。","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"自定义表单设计及实现方案","slug":"devDiyForm","date":"2020-02-03T06:30:00.000Z","updated":"2021-08-03T02:09:36.658Z","comments":true,"path":"2020/02/03/devDiyForm/","link":"","permalink":"http://debug.cool/2020/02/03/devDiyForm/","excerpt":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。","text":"如何设计一款高度自定义的表单系统？ 自定义意味着表单数量不确定，每个表单字段数量不确定，每个字段类型不确定，存储量不确定，等等一切都是未知的。 以及之后如何建立索引，如何搜索定位指定的数据？这些问题都将在下面的方案中进行解答。 背景 为了实现某个比较脑洞大开的需求，建立自定义表单，而且，还限定了前置条件—技术选型不许复杂，数据存储只能基于mysql, So… 所谓的“自定义”（表设计） 我们会定义这么几张表，用来实现自定义模板的大致框架。 12345diy_field_pool 字段池（我们定义好的字段类型）diy_form 表单表（记录用户自定义的表单）diy_form_field 表单字段表（记录某张表单中有哪些字段）diy_form_entity 表单实例表（记录某张表单中的某条数据实例）diy_form_data 表单数据表（记录某张表单在某条实例下，哪些字段对应的数据） 系统初始化字段池 我们提供一批预定义的字段类型，初始化数据到diy_field_pool表中，用户也能自己定义自己的字段池。 用户创建自定义表单 用户通过选用字段池（diy_field_pool表）中提供的字段，创建一张自定义表单，表单的属性信息记录在diy_form表中，表单包含的字段（从字段池中选好的字段）记录在diy_form_field表中。这样用户就创建了一张自定义表单。 用户填写表单 用户使用创建好的表单填写数据，每新增一条数据，在diy_form_entity表就会新增一条记录，该表单中有几个field，就会同时在diy_form_data表中新增几条 data 数据。数据结构关系如下图所示： 123456789101112131415diy_form ------ diy_enity| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||---diy_field |---diy_data| ||... 如何进行数据搜索 数据存储结构中，最终保存数据的地方其实是data表，但是，data表的辅助字段有form表id，field表id，entity表id，只有一个content字段是记录真实信息的，那么，如何搭建索引体系呢？ 采用 Sphinx 构建Sphinx的sql语句时，将data表的id作为文档id。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# 公共的自定义模板的数据源source diyCommonSource&#123; type = mysql sql_db = diy sql_host = 127.0.0.1 sql_port = 3306 sql_user = root sql_pass = root sql_query_pre = SET NAMES utf8 sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from diy_form_data as dfd \\ inner join diy_form_field as dff on dff.form_id=dfd.form_id and dff.is_delete=0 \\ inner join diy_form as df on df.id=dff.form_id and df.is_delete=0 \\ where dfd.is_delete=0&#125;# 公共的自定义模板的索引index diyCommonIndex&#123; source = diyCommonSource path = /var/local/diy/sphinx/data/diyCommonIndex docinfo = extern #charset_type = zh_cn.utf-8 charset_type = utf-8 min_word_len = 1 ngram_len = 1 ngram_chars = U+3000..U+2FA1F&#125;# 范围：新闻模板（假定form_type为1）source news:diyCommonSource&#123; sql_query = \\ select \\ dfd.id, \\ dfd.entity_id,dfd.content,dfd.createat,dfd.updateat, \\ dff.id as field_id,dff.sys_id,dff.field, \\ df.id as form_id \\ from pre_diy_form_data as dfd \\ inner join pre_diy_form_field as dff \\ and dff.form_id=dfd.form_id \\ and dff.sys_id&gt;0 and dff.is_delete=0 \\ inner join pre_diy_form as df \\ and df.id=dff.form_id \\ and df.is_delete=0 \\ and df.form_type=1 \\ where dfd.is_delete=0 # 使用sql_attr设置的字段(搜索条件)，只能作为属性，使用SphinxClient::SetFilter()进行过滤； # 未被设置的字段，自动作为全文检索的字段，使用SphinxClient::Query(&quot;搜索字符串&quot;)进行全文搜索 # sql_query第一列id需为整数，且被系统使用，无需再设置sql_attr_uint sql_attr_uint = form_id sql_attr_uint = field_id sql_attr_uint = field sql_attr_uint = entity_id sql_attr_timestamp = createat sql_attr_timestamp = updateat&#125;# 构造商品模板的数据索引index news:diyCommonIndex&#123; source = news path = /var/local/diy/sphinx/data/news&#125; 其中，如果需要指定查找某些字段的数据，那么，以上面的数据源再重新定义数据源，sql 语句进一步指定 field 表的某个标志字段即可。","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"验证码识别","slug":"devCrack","date":"2019-05-10T07:44:00.000Z","updated":"2021-08-03T02:09:36.658Z","comments":true,"path":"2019/05/10/devCrack/","link":"","permalink":"http://debug.cool/2019/05/10/devCrack/","excerpt":"通过训练卷积模型，让程序自动识别验证码。","text":"通过训练卷积模型，让程序自动识别验证码。 背景 运营人员审核某些用户提交的资质证书的时候，需要到规定的公示网站上去查询证书，大致操作是这些： 到公示网站填写对应信息（证书编号等） 填写验证码（每次查询都会有校验码或者短信验证等等） 查看查询结果并比对证书 这一套流程下来，无疑是加大了审核员的工作量，而且每天审核的不止一张证书。一个比较迫切的需求就诞生了，根据不同证书种类，分别去自动获取公示网站上该证书的信。 假定以教师资质证书为例，该公示站点查询信息时，需要输入证书编号，图片验证码，即可返回该证书所对应的信息，运营人员比对用户上传的证书和站点公示的证书即可。 方案一 现在方案一是在我们自己的审核后台，将所有的数据（查询时需要的证书编号、姓名等等）都提取出来，封装成一个 post 请求数据，并将公示网站的验证码获取过来，在审核后台只留一个验证码的输入框给审核人员，输入正确的验证码，追加到 post 请求中，即可进行查询（该过程中会话交互验证的破解思路请自行摸索），将返回的数据结果进行切割处理，以比较好的交互方式呈现给运营人员。运营人员剩下的工作只要 check 一下信息即可。 ps：方案一的背后其实还进行了另一步操作，只要查询成功，就将这张验证码图片保存到本地服务器，运营人员输入的验证码作为图片名（这一步是关键，因为需要大量的训练样本进行模型训练，为方案二做铺垫）。 方案二 等一段时间后，将方案一保存下来的这批图片数据作为训练样本，去训练模型，也就是方案二，当模型的准确率达到了 0.9 以上，就可以实际拿过来使用了。（可能会说为什么不自动生成相似的验证码来进行训练，这也是一个思路，但准确率没有拿目标样本作为训练样本来的高，因为我们是不知道对方验证码的生成规则的，只能仿出一个大概相似的验证码。） 方案二部署上线的时候，只要用户提交了相关的证书信息，我们的系统就自动去公示网站上查询数据并将结果保存到数据库，这样运营人员只要在审核后台核对查询结果即可，也不用再输入验证码了。 为了更好的兼容，之前方案一预留的手动填写验证码功能也不会删减掉，防止出现系统无法自动识别验证码、获取不到查询数据的情况。这样如果系统自动查询到了数据运营人员就能直接审核，没有查询到数据，运营人员还能手动查一遍进行确认，同时还收集了验证码的训练样本。 总结 方案二是在方案一使用一段时间后才能进行的，因为我们需要大量的训练样本，如果特意通过人工去获取数据（验证码图片）并打标签（每张图片所代表的验证码），无疑是会浪费很大的人力资源。 这样在方案一阶段，审核人员还是进行常规的审核操作，就顺便收集了对应的训练数据。等到执行案案二，就将审核员彻底解放出来，在需求（审核功能、上线时间）、成本（时间、人力）、技术实现（样本获取）上目前应该是最优解了。 补充 其实同时还是做了高仿目标站点的验证码，争取做到大致相同。然后tensorflow训练后的识别率达到0.9左右估计就差不多了。 源码","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Python封装Kafka客户端","slug":"devKafka","date":"2019-04-20T12:44:00.000Z","updated":"2021-08-03T02:09:36.659Z","comments":true,"path":"2019/04/20/devKafka/","link":"","permalink":"http://debug.cool/2019/04/20/devKafka/","excerpt":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。","text":"业务上处理Kafka主要就扣着“生产者”和“消费者”这个点就行，下面讲的是在Python中封装一个比较好用的Kafka客户端。 no bb, show code.直接上代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120#!/usr/bin/env python# encoding: utf-8import sysfrom pykafka import KafkaClientreload(sys)sys.setdefaultencoding(&#x27;utf8&#x27;)class KafkaTaskException(Exception): &quot;&quot;&quot; 在这里自定义KafkaTask类的异常 &quot;&quot;&quot; passclass ParameterError(KafkaTaskException): &quot;&quot;&quot; 参数异常错误 _ParameterError_Key: 当 key 类型错误的时的抛错. _ParameterError_Topic: 当 topic 类型错误的时的抛错. _ParameterError_Consumer: 当初始化init_consumer 使用了错误的参数时抛错. &quot;&quot;&quot; _ParameterError_Key = &quot;ParameterError- type(s) for &#x27;Key&#x27;: must be bytes&quot; _ParameterError_Topic = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes&quot; _ParameterError_pykafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be bytes; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; _ParameterError_kafka_Consumer = &quot;ParameterError- type(s) for &#x27;topic&#x27;: must be str; &quot; \\ &quot;type(s) for &#x27;group_id&#x27;: must be str; &#x27;offset_type&#x27; &quot; \\ &quot;must be &#x27;LATEST&#x27; or &#x27;EARLIEST&#x27;&quot; passclass KafkaTask(object): &quot;&quot;&quot; 封装一个pykafka的客户端方法 &quot;&quot;&quot; def __init__(self, server): &quot;&quot;&quot; :param server: str类型 &quot;&quot;&quot; self.server = server self.client = KafkaClient(hosts=server) def init_producer(self, topic): &quot;&quot;&quot; 初始化Kafka生产者 :param topic:Type --&gt; bytes `Produce msg what topic You want`. :raises ParameterError: 当topic不是bytes类型时抛错. :return: &quot;&quot;&quot; if not isinstance(topic, bytes): raise ParameterError(ParameterError._ParameterError_Topic) topic = self.client.topics[topic] self.producer = topic.get_producer(sync=True) def init_consumer_pykafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by pykafka :param topic:Type --&gt; bytes `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type:Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; if not isinstance(topic, bytes) or not isinstance(group_id, str) or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_pykafka_Consumer) from pykafka.simpleconsumer import OffsetType _OffsetType = &#123;&quot;LATEST&quot;: OffsetType.LATEST, &quot;EARLIEST&quot;: OffsetType.EARLIEST&#125; topic = self.client.topics[topic] self.consumer = topic.get_simple_consumer(auto_commit_enable=True, auto_commit_interval_ms=1, consumer_id=group_id, auto_offset_reset=_OffsetType[offset_type], reset_offset_on_start=True) def init_consumer_kafka(self, topic, group_id, offset_type): &quot;&quot;&quot; Init Kafka Consumer by kafka-python :param topic: Type --&gt; str `Consumer msg what topic You want`. :param group_id: Type --&gt; str `Consumer msg what group_id You want,You can receive duplicate data using different group_id in same topic`. :param offset_type: Type --&gt; str `LATEST can receive the latest data,EARLIEST can receive earliest data in topic` :raises ParameterError: When use error Parameter to init init_consumer. :return: &quot;&quot;&quot; from kafka import KafkaConsumer if not isinstance(topic, str) or not isinstance(group_id, str) \\ or not isinstance(offset_type, str) or offset_type not in [&quot;LATEST&quot;, &quot;EARLIEST&quot;]: raise ParameterError(ParameterError._ParameterError_kafka_Consumer) self.consumer = KafkaConsumer(bootstrap_servers=self.server, auto_offset_reset=offset_type, group_id=group_id, ) self.consumer.subscribe(topics=topic.split(&#x27;,&#x27;)) def pull(self): &quot;&quot;&quot; Get info from Kafka Consumer by kafka-python Poll Parameters: timeout_ms: Type --&gt; int `Interval between each piece of data`. max_records: Type --&gt; int `The amount of data per batch of data` :return: &quot;&quot;&quot; return self.consumer.poll(timeout_ms=0, max_records=1) def send_message(self, msg, key): &quot;&quot;&quot; Send MSG by this func :param msg: Type --&gt; bytes or str `Message to broker`. :param key: Type --&gt; bytes `Producer msg what key You want,You can see the key when you receiving data`. :raises ParameterError: when error type for key. :return: &quot;&quot;&quot; if not isinstance(key, bytes): raise ParameterError(ParameterError._ParameterError_Key) produce_msg = msg.encode() if isinstance(msg, str) else msg self.producer.produce(produce_msg, partition_key=key)","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"任务分配算法","slug":"devTaskAssign","date":"2019-01-26T16:00:00.000Z","updated":"2021-08-03T02:09:36.659Z","comments":true,"path":"2019/01/27/devTaskAssign/","link":"","permalink":"http://debug.cool/2019/01/27/devTaskAssign/","excerpt":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。","text":"在开发一套内部的审核平台的时候，有这么一个需求，所有的任务需要平均的前提下随机分配给审核员。然后有存在一个问题，有的审核员效率慢，有的审核员效率高，这样分配任务的时候就需要考虑审核员当前手上剩余的审核任务(也有运营部的绩效考核原因)。 ps：需求变了，所有的都平均分了，因为运营人员不需要根据审核量进行绩效考核了，多劳多得变成大锅饭了。也白设计了这套算法，无所谓了，就当周末刷了会数独游戏吧，反正闲着也是闲着。 假设现在有 n 个任务需要分配给 m 个审核员去完成，但是每个审核员手头上还有未完成的任务，且未完成的任务数不同。那么如何均匀的把这些任务分配给各个审核员？这里我想出了一种基于平均思想的任务分配算法。 该算法的主要思想是：首先找出所有的审核员中手头未完成任务数量最大的审核员，然后其他审核员以该审核员的未完成任务数为参考数，计算自己可容纳的任务数，最后所有审核员可容纳的任务数之和即为总的可容纳任务数。 这里存在两种情况，第一种是：总的可容纳任务数小于或等于 n 个待分配的任务数，此时所有的审核员以最大未完成任务数 max_task 为参考数，接收待分配的任务。如果刚好分配完，那么算法结束；如果还有剩余任务未分配，那么将剩下的任务抽取 m 个任务分配给每一位审核员，以此类推，直到剩下的未分配任务数小于 m 位置，然后将这小于 m 的任务随机分配相应数量的审核员。 第二种情况是：总的可容纳任务数大于 n 个待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，知道退出循环（循环终止条件为：ava_task - task_num &lt;= lower_List.size(),lower_List.size()表示的是低于当前参考数的审核员数）。 接下来，我们将通过一个简单的例子来说明算法的流程，由于第一种情况比较简单，因此，该例子是基于第二种情况的，如图 1 所示. 假设有 20 个任务需要分配给 8 个审核员(对应 8 个条形图，蓝色条形图对应的数字代表该审核员手头未完成的任务数)。 首先找出者八个审核员收中未完成任务书的最大值 max_task=7，然后个审核员已 max_task 为参考数计算各自可容纳的任务数(绿色条形图对应的数字)，总的可容纳任务数为所有审核员可容纳的任务数之和，及 ava_task=6+3+4+2+5+0+5+6,有图 1 可知，lower_List.size()=7,由 31-20&gt;7，因此，可降低一个单位的参数数，即 max_task=max_task-1=6，如图 2 所示。 那么，ava_task=5+2+3+1+4+0+4+5=24，lower_List.size()=7，由于 24-20&lt;7，因此循环终止。 由于可容纳的任务数仍然大于待分配的任务数，因此需要再降低一个单位的参考数(一定要考虑这种情况)，max_task=max_task-1=5，此时 ava_task=4+1+2+0+3+0+3+4=17，lower_List.size()=6，剩余待分配任务数为 20-17=3，然后将这 3 个任务随机分配给低于当前参考数的 6 个审核员中的 3 个，每个审核员分配一个。 当然算法中还考虑了很多种情况，具体请参见如下代码。由于任务一般按审核员 ID 来分配，且 ID 一般为字符串。为了存储方便，我定义了一个二维字符串类型的数组 rev_task[i][j]来存储数据，i 表示第 i 个审核员，rev_task[i][0]存放的是第 i 个审核员的 ID，rev_task[i][1]存放的是第 i 个审核员当前未完成的任务数，rev_task[i][2]存放的是第 i 个审核员应当被分配的任务数。 算法工具类-AlgorithmUtils.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Random;public class AlgorithmUtils &#123; public static void taskAllocation(int task_num, int rev_num, String[][] rev_task) &#123; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); int temp; //获得审核人员中的最大未完成任务数 int max_task = Integer.parseInt(rev_task[0][1]); for(int i = 1; i &lt; rev_num; i++)&#123; if(max_task &lt; Integer.parseInt(rev_task[i][1])) max_task = Integer.parseInt(rev_task[i][1]); &#125; //以最大待审核任务数为参考数，判断第一轮可容纳的任务数 int ava_task = 0; List&lt;Integer&gt; lower_List = new ArrayList&lt;&gt;(); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; ava_task += (max_task-Integer.parseInt(rev_task[i][1])); lower_List.add(i); &#125; &#125; int task_rest; int task_avg; //第一种情况：第一轮可容纳的任务数小于待分配的任务数 if(ava_task - task_num &lt;= 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); &#125; task_rest = task_num-ava_task; task_avg = task_rest/rev_num; if(task_rest != 0) &#123; while(task_avg &gt; 0) &#123; for(int i = 0; i &lt; rev_num; i++) &#123; rev_task[i][2] = String.valueOf(Integer.parseInt(rev_task[i][2])+task_avg); &#125; task_rest -= rev_num*task_avg; task_avg = task_rest/rev_num; &#125; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125;else &#123;//第二种情况：第一轮可容纳的任务数大于待分配的任务数，此时降低一个单位的参考数(max_task-1)，然后循环计算可容纳的任务数，直到退出循环 while(ava_task - task_num &gt; lower_List.size()) &#123; max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][2] = &quot;0&quot;; if((max_task-Integer.parseInt(rev_task[i][1])) &gt; 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; &#125; if(ava_task - task_num &gt; 0) &#123;//如果可容纳的任务数大于待分配的任务数，那么需要再再降低一个单位的参考数 max_task--; ava_task = 0; lower_List.removeAll(lower_List); for(int i=0;i&lt;rev_num;i++)&#123; if((max_task-Integer.parseInt(rev_task[i][1])) &gt;= 0)&#123; rev_task[i][2] = String.valueOf(max_task-Integer.parseInt(rev_task[i][1])); ava_task += Integer.parseInt(rev_task[i][2]); lower_List.add(i); &#125; &#125; task_rest = task_num - ava_task; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125;else &#123; task_rest = task_num-ava_task; if(task_rest != 0) &#123; rdList.removeAll(rdList); while(rdList.size() &lt; (task_rest+1))&#123; temp = rd.nextInt(rev_num); if((!rdList.contains(temp))&amp;&amp;(lower_List.contains(temp)))&#123; rdList.add(temp); &#125; &#125; for(int i = 0; i &lt; task_rest; i++) &#123; rev_task[rdList.get(i)][2] = String.valueOf(Integer.parseInt(rev_task[rdList.get(i)][2])+1); &#125; &#125; &#125; &#125; //记录被分配的任务数 for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][1] = String.valueOf(Integer.parseInt(rev_task[i][1])+Integer.parseInt(rev_task[i][2])); &#125; &#125;&#125; 算法测试类-TestAlgorithm.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.audit.allocationAlgorithm;import java.util.ArrayList;import java.util.List;import java.util.Random;import java.util.Scanner;public class TestAlgorithm &#123; public static void main(String[] args) &#123; Scanner sc=new Scanner(System.in); System.out.println(&quot;请输入任务数：&quot;); int task_num = sc.nextInt(); System.out.println(&quot;请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：&quot;); String inputString=sc.next().toString(); String stringArray[]=inputString.split(&quot;,&quot;); int rev_num = stringArray.length;//审核人员总数 String[][] rev_task =new String[rev_num][3]; Random rd = new Random(); List&lt;Integer&gt; rdList = new ArrayList&lt;&gt;(); rdList.removeAll(rdList); int temp; while(rdList.size() &lt; (rev_num+1))&#123; temp = rd.nextInt(100); if(!rdList.contains(temp))&#123; rdList.add(temp); &#125; &#125; System.out.println(&quot;算法前的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; rev_task[i][0] = String.valueOf(rdList.get(i) + 1); rev_task[i][1]= stringArray[i]; rev_task[i][2] = &quot;0&quot;; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; System.out.println(); AlgorithmUtils.taskAllocation(task_num, rev_num, rev_task);//调用算法工具类 System.out.println(&quot;算法后的任务分配：&quot;); for(int i=0;i&lt;rev_num;i++)&#123; System.out.print(rev_task[i][0]+&quot;,&quot;+rev_task[i][1]+&quot; &quot;); &#125; &#125;&#125; 运行结果： 12345678请输入任务数：20请输入审核人员的当前未完成任务数组，整数数字输入时用英文逗号隔开：1,4,3,5,2,7,2,1算法前的任务分配：72,1 63,4 73,3 49,5 74,2 43,7 100,2 20,1算法后的任务分配：72,5 63,5 73,5 49,6 74,5 43,7 100,6 20,6 由运行结果可知，20 个任务均衡的分配给了每个审核人员，达到了平均分配的目的！","categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"}],"tags":[]},{"title":"Python可视化绘图","slug":"tipsPythonMatplotlib","date":"2019-01-24T16:00:00.000Z","updated":"2021-08-03T02:09:36.663Z","comments":true,"path":"2019/01/25/tipsPythonMatplotlib/","link":"","permalink":"http://debug.cool/2019/01/25/tipsPythonMatplotlib/","excerpt":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。","text":"Matplotlib是一个Python的绘图库，粗略理解为py集成MATLAB的功能包。以前学数学建模的时候很讨厌MATLAB，情愿用C来写算法都不想学MATLAB，现在没得法，工作需要分析一些数据，还好Python有这些相关的库，要不然真的要去研究下MATLAB了。 简单图形绘制 根据坐标点绘制： 1234567891011import numpy as npimport matplotlib.pyplot as pltx = np.array([1,2,3,4,5,6,7,8])y = np.array([3,5,7,6,2,6,10,15])plt.plot(x,y,&#x27;r&#x27;)# 折线 1 x 2 y 3 colorplt.plot(x,y,&#x27;g&#x27;,lw=10)# 4 line w# 折线 饼状 柱状x = np.array([1,2,3,4,5,6,7,8])y = np.array([13,25,17,36,21,16,10,15])plt.bar(x,y,0.2,alpha=1,color=&#x27;b&#x27;)# 5 color 4 透明度 3 0.9plt.show() 传入参数是 numpy 数组时的效果： 12345678910111213import numpy as npimport matplotlib.pyplot as pltfor i in range(0,15): # 1 柱状图 dateOne = np.zeros([2]) dateOne[0] = i; dateOne[1] = i; y = np.zeros([2]) y[0] = 10 y[1] = 20 plt.plot(dateOne,y,&#x27;r&#x27;,lw=8)plt.show() 根据函数图像绘制： 12345678910111213141516import matplotlib.pyplot as pltimport numpy as np# 从-1-----1之间等间隔采66个数.也就是说所画出来的图形是66个点连接得来的# 注意：如果点数过小的话会导致画出来二次函数图像不平滑x = np.linspace(-1, 1,66)# 绘制y=2x+1函数的图像y = 2 * x + 1plt.plot(x, y)plt.show()# 绘制x^2函数的图像y = x**2plt.plot(x, y)plt.show() figure 的简单使用 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1, 1, 50)# figure 1y1 = 2 * x + 1plt.figure()plt.plot(x, y1)# figure 2y2 = x**2plt.figure()plt.plot(x, y2)# figure 3，指定figure的编号并指定figure的大小, 指定线的颜色, 宽度和类型#一个坐标轴上画了两个图形y2 = x**2plt.figure(num = 5, figsize = (4, 4))plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)plt.show() 一共会画出三张图，前两张和上面的简单案例画出来的两张一样。 设置坐标轴 12345678910111213141516171819202122232425import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))plt.show() 上面代码的基础上加上下面代码（直接加载最后一句代码前面即可）： 123456789101112# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0)) 如果在上面代码的最后一句之前加上下面的代码： 1234# 设置坐标轴label的大小，背景色等信息for label in ax.get_xticklabels() + ax.get_yticklabels(): label.set_fontsize(12) label.set_bbox(dict(facecolor = &#x27;green&#x27;, edgecolor = &#x27;None&#x27;, alpha = 0.7)) 设置 legend 图例 123456789101112131415161718192021222324252627282930313233343536373839404142&quot;&quot;&quot;设置坐标轴&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-1, 1, 50)y1 = 2 * x + 1y2 = x**2plt.figure()plt.plot(x, y1)plt.plot(x, y2, color = &#x27;red&#x27;, linewidth = 1.0, linestyle = &#x27;--&#x27;)# 设置坐标轴的取值范围plt.xlim((-1, 1))plt.ylim((0, 3))# 设置坐标轴的lable#标签里面必须添加字体变量：fontproperties=&#x27;SimHei&#x27;,fontsize=14。不然可能会乱码plt.xlabel(u&#x27;这是x轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)plt.ylabel(u&#x27;这是y轴&#x27;,fontproperties=&#x27;SimHei&#x27;,fontsize=14)# 设置x坐标轴刻度, 之前为0.25, 修改后为0.5#也就是在坐标轴上取5个点，x轴的范围为-1到1所以取5个点之后刻度就变为0.5了plt.xticks(np.linspace(-1, 1, 5))# 获取当前的坐标轴, gca = get current axisax = plt.gca()# 设置右边框和上边框ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x坐标轴为下边框ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)# 设置y坐标轴为左边框ax.yaxis.set_ticks_position(&#x27;left&#x27;)# 设置x轴, y周在(0, 0)的位置ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))plt.show() 添加注解和绘制点以及在图形上绘制线或点 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;&quot;&quot;添加注解和绘制点以及在图形上绘制线或点&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 绘制普通图像x = np.linspace(-3, 3, 50)y = 2 * x + 1plt.figure()plt.plot(x, y)# 将上、右边框去掉ax = plt.gca()ax.spines[&#x27;right&#x27;].set_color(&#x27;none&#x27;)ax.spines[&#x27;top&#x27;].set_color(&#x27;none&#x27;)# 设置x轴的位置及数据在坐标轴上的位置ax.xaxis.set_ticks_position(&#x27;bottom&#x27;)ax.spines[&#x27;bottom&#x27;].set_position((&#x27;data&#x27;, 0))# 设置y轴的位置及数据在坐标轴上的位置ax.yaxis.set_ticks_position(&#x27;left&#x27;)ax.spines[&#x27;left&#x27;].set_position((&#x27;data&#x27;, 0))# 定义(x0, y0)点x0 = 1y0 = 2 * x0 + 1# 绘制(x0, y0)点plt.scatter(x0, y0, s = 50, color = &#x27;blue&#x27;)# 绘制虚线plt.plot([x0, x0], [y0, 0], &#x27;k--&#x27;, lw = 2.5)# 绘制注解一plt.annotate(r&#x27;$2 * x + 1 = %s$&#x27; % y0, xy = (x0, y0), xycoords = &#x27;data&#x27;, xytext = (+30, -30), \\ textcoords = &#x27;offset points&#x27;, fontsize = 16, arrowprops = dict(arrowstyle = &#x27;-&gt;&#x27;, connectionstyle = &#x27;arc3, rad = .2&#x27;))# 绘制注解二plt.text(-3, 3, r&#x27;$Test\\ text. \\mu \\sigma_i, \\alpha_i$&#x27;, fontdict = &#123;&#x27;size&#x27;: 16, &#x27;color&#x27;: &#x27;red&#x27;&#125;)plt.show() 绘制散点图 1234567891011121314151617181920212223242526&quot;&quot;&quot;绘制散点图&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 数据个数n = 1024# 均值为0, 方差为1的随机数x = np.random.normal(0, 1, n)y = np.random.normal(0, 1, n)# 计算颜色值color = np.arctan2(y, x)# 绘制散点图plt.scatter(x, y, s = 75, c = color, alpha = 0.5)# 设置坐标轴范围plt.xlim((-1.5, 1.5))plt.ylim((-1.5, 1.5))# 不显示坐标轴的值plt.xticks(())plt.yticks(())plt.show() 绘制柱状图 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制柱状图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 数据数目n = 10x = np.arange(n)# 生成数据, 均匀分布(0.5, 1.0)之间y1 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)y2 = (1 - x / float(n)) * np.random.uniform(0.5, 1.0, n)# 绘制柱状图, 向上plt.bar(x, y1, facecolor = &#x27;blue&#x27;, edgecolor = &#x27;white&#x27;)# 绘制柱状图, 向下plt.bar(x, -y2, facecolor = &#x27;green&#x27;, edgecolor = &#x27;white&#x27;)temp = zip(x, y2)# 在柱状图上显示具体数值, ha水平对齐, va垂直对齐for x, y in zip(x, y1): plt.text(x + 0.05, y + 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)for x, y in temp: plt.text(x + 0.05, -y - 0.1, &#x27;%.2f&#x27; % y, ha = &#x27;center&#x27;, va = &#x27;bottom&#x27;)# 设置坐标轴范围plt.xlim(-1, n)plt.ylim(-1.5, 1.5)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制登高线图 12345678910111213141516171819202122232425262728293031&quot;&quot;&quot;绘制登高线图&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义等高线高度函数def f(x, y): return (1 - x / 2 + x ** 5 + y ** 3) * np.exp(- x ** 2 - y ** 2)# 数据数目n = 256# 定义x, yx = np.linspace(-3, 3, n)y = np.linspace(-3, 3, n)# 生成网格数据X, Y = np.meshgrid(x, y)# 填充等高线的颜色, 8是等高线分为几部分plt.contourf(X, Y, f(X, Y), 8, alpha = 0.75, cmap = plt.cm.hot)# 绘制等高线C = plt.contour(X, Y, f(X, Y), 8, colors = &#x27;black&#x27;, linewidth = 0.5)# 绘制等高线数据plt.clabel(C, inline = True, fontsize = 10)# 去除坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 Image 12345678910111213141516&quot;&quot;&quot;绘制Image&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as np# 定义图像数据a = np.linspace(0, 1, 9).reshape(3, 3)# 显示图像数据plt.imshow(a, interpolation = &#x27;nearest&#x27;, cmap = &#x27;bone&#x27;, origin = &#x27;lower&#x27;)# 添加颜色条plt.colorbar()# 去掉坐标轴plt.xticks(())plt.yticks(())plt.show() 绘制 3D 图形 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;绘制3d图形&quot;&quot;&quot;import matplotlib.pyplot as pltimport numpy as npfrom mpl_toolkits.mplot3d import Axes3D# 定义figurefig = plt.figure()# 将figure变为3dax = Axes3D(fig)# 数据数目n = 256# 定义x, yx = np.arange(-4, 4, 0.25)y = np.arange(-4, 4, 0.25)# 生成网格数据X, Y = np.meshgrid(x, y)# 计算每个点对的长度R = np.sqrt(X ** 2 + Y ** 2)# 计算Z轴的高度Z = np.sin(R)# 绘制3D曲面ax.plot_surface(X, Y, Z, rstride = 1, cstride = 1, cmap = plt.get_cmap(&#x27;rainbow&#x27;))# 绘制从3D曲面到底部的投影ax.contour(X, Y, Z, zdim = &#x27;z&#x27;, offset = -2, cmap = &#x27;rainbow&#x27;)# 设置z轴的维度ax.set_zlim(-2, 2)plt.show() subplot 绘制多图 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 2, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 2, 2)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 2, 3)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 2, 4)plt.plot([0, 1], [0, 1])plt.show() 123456789101112131415161718192021&quot;&quot;&quot;subplot绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltplt.figure()# 绘制第一个图plt.subplot(2, 1, 1)plt.plot([0, 1], [0, 1])# 绘制第二个图plt.subplot(2, 3, 4)plt.plot([0, 1], [0, 1])# 绘制第三个图plt.subplot(2, 3, 5)plt.plot([0, 1], [0, 1])# 绘制第四个图plt.subplot(2, 3, 6)plt.plot([0, 1], [0, 1])plt.show() figure 绘制多图 12345678910111213141516171819202122232425&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figureplt.figure()# figure分成3行3列, 取得第一个子图的句柄, 第一个子图跨度为1行3列, 起点是表格(0, 0)ax1 = plt.subplot2grid((3, 3), (0, 0), colspan = 3, rowspan = 1)ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)# figure分成3行3列, 取得第二个子图的句柄, 第二个子图跨度为1行3列, 起点是表格(1, 0)ax2 = plt.subplot2grid((3, 3), (1, 0), colspan = 2, rowspan = 1)ax2.plot([0, 1], [0, 1])# figure分成3行3列, 取得第三个子图的句柄, 第三个子图跨度为1行1列, 起点是表格(1, 2)ax3 = plt.subplot2grid((3, 3), (1, 2), colspan = 1, rowspan = 1)ax3.plot([0, 1], [0, 1])# figure分成3行3列, 取得第四个子图的句柄, 第四个子图跨度为1行3列, 起点是表格(2, 0)ax4 = plt.subplot2grid((3, 3), (2, 0), colspan = 3, rowspan = 1)ax4.plot([0, 1], [0, 1])plt.show() 或 123456789101112131415161718192021222324252627&quot;&quot;&quot;figure绘制多图&quot;&quot;&quot;import matplotlib.pyplot as pltimport matplotlib.gridspec as gridspec# 定义figureplt.figure()# 分隔figuregs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :])ax2 = plt.subplot(gs[1, 0:2])ax3 = plt.subplot(gs[1, 2])ax4 = plt.subplot(gs[2, :])# 绘制图像ax1.plot([0, 1], [0, 1])ax1.set_title(&#x27;Test&#x27;)ax2.plot([0, 1], [0, 1])ax3.plot([0, 1], [0, 1])ax4.plot([0, 1], [0, 1])plt.show() figure 图的嵌套 1234567891011121314151617181920212223242526272829303132333435363738394041424344&quot;&quot;&quot;figure图的嵌套&quot;&quot;&quot;import matplotlib.pyplot as plt# 定义figurefig = plt.figure()# 定义数据x = [1, 2, 3, 4, 5, 6, 7]y = [1, 3, 4, 2, 5, 8, 6]# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.1, 0.1, 0.8, 0.8# 获得绘制的句柄ax1 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax1.plot(x, y, &#x27;r&#x27;)ax1.set_xlabel(&#x27;x&#x27;)ax1.set_ylabel(&#x27;y&#x27;)ax1.set_title(&#x27;test&#x27;)# 嵌套方法一# figure的百分比, 从figure 10%的位置开始绘制, 宽高是figure的80%left, bottom, width, height = 0.2, 0.6, 0.25, 0.25# 获得绘制的句柄ax2 = fig.add_axes([left, bottom, width, height])# 绘制点(x,y)ax2.plot(x, y, &#x27;r&#x27;)ax2.set_xlabel(&#x27;x&#x27;)ax2.set_ylabel(&#x27;y&#x27;)ax2.set_title(&#x27;part1&#x27;)# 嵌套方法二plt.axes([bottom, left, width, height])plt.plot(x, y, &#x27;r&#x27;)plt.xlabel(&#x27;x&#x27;)plt.ylabel(&#x27;y&#x27;)plt.title(&#x27;part2&#x27;)plt.show() 主次坐标轴 12345678910111213141516171819202122232425&quot;&quot;&quot;主次坐标轴&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as plt# 定义数据x = np.arange(0, 10, 0.1)y1 = 0.05 * x ** 2y2 = -1 * y1# 定义figurefig, ax1 = plt.subplots()# 得到ax1的对称轴ax2ax2 = ax1.twinx()# 绘制图像ax1.plot(x, y1, &#x27;g-&#x27;)ax2.plot(x, y2, &#x27;b--&#x27;)# 设置labelax1.set_xlabel(&#x27;X data&#x27;)ax1.set_xlabel(&#x27;Y1&#x27;, color = &#x27;g&#x27;)ax2.set_xlabel(&#x27;Y2&#x27;, color = &#x27;b&#x27;)plt.show() 创建动画 1234567891011121314151617181920212223242526272829303132333435&quot;&quot;&quot;动画&quot;&quot;&quot;import numpy as npimport matplotlib.pyplot as pltfrom matplotlib import animation# 定义figurefig, ax = plt.subplots()# 定义数据x = np.arange(0, 2 * np.pi, 0.01)# line, 表示只取返回值中的第一个元素line, = ax.plot(x, np.sin(x))# 定义动画的更新def update(i): line.set_ydata(np.sin(x + i/10)) return line,# 定义动画的初始值def init(): line.set_ydata(np.sin(x)) return line,# 创建动画ani = animation.FuncAnimation(fig = fig, func = update, init_func = init, interval = 10, blit = False, frames = 200)# 展示动画plt.show()# 动画保存#我这里是保存为html文件了，打开即可完美运行ani.save(&#x27;sin.html&#x27;, writer = &#x27;imagemagick&#x27;, fps = 30, dpi = 100)","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"逆向笔记梳理","slug":"noteReverseEnfineering","date":"2018-10-09T23:33:25.000Z","updated":"2021-08-03T02:09:36.662Z","comments":true,"path":"2018/10/10/noteReverseEnfineering/","link":"","permalink":"http://debug.cool/2018/10/10/noteReverseEnfineering/","excerpt":"先把大纲列出来，有空就慢慢更新完善。","text":"先把大纲列出来，有空就慢慢更新完善。 x86 与 x64 x86是基于intel 8086处理器的小端（little-endian）体系结构（IA-32的32位实现），他在两种操作模式下执行 实模式：处理机刚刚上电后只支持 16 位指令集的状态。 保护模式：处理机支持虚拟内存、分页及其他功能的状态。 该体系的64位扩展称为x64或x86-64，x86通过一种称为环级别(ring level)的抽象来支持特权隔离(privilege separation)。 寄存器组与数据类型 运行于保护模式下的x86体系结构有 8 个32位通用寄存器(General Purpose Registers, GPR):EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP。这些寄存器还能进一步分化成8位和16位寄存器。指令指针存储在EIP寄存器中。 12345678910111213141531 23 15 7 0| EAX || | | AX || | |AH |AL |31 23 15 7 0 31 23 15 7 0| EBP | | ESP || | BP | | | SP |31 23 15 7 0 31 23 15 7 0| ESI | | EDI || | SI | | | DI |31 23 15 7 0 31 23 15 7 0| EIP | | EFLAGS | 寄存器 用途 ECX 循环计数 ESI 字符串/内存操作的源 EDI 字符串/内存操作中的目标 EBP 帧基指针 ESP 栈指针 常用的数据类型有以下几种： 字节(Byte): 8 位，比如 AL、BL、CL。 字(Word): 16 位，比如 AX、BX、CX。 双字(Double Word): 32 位，比如 EAX、EBX、ECX。 四字(Quad Word): 64 位，虽然 x86 并不支持 64 位 GPR，但是在某些场景下可以把两个寄存器(通常是 EDA:EAX)的内容合并起来当作 64 位的值。比如 RDTSC 指令会把一个 64 位值写入 EDX:EAX 寄存器。 32位寄存器EFLAGS用于存储运算状态以及其他运行状态（比如陷阱标志位）。 除了通用寄存器、EIP和EFLAGS，还有一些寄存器用于控制重要的底层系统机制，比如虚拟内存、终端和调试等。例如：CR0寄存器控制分页机制的开关，CR2寄存器中保存着导致缺页异常发生的线性地址，CR3是分页数据结构的基地址，CR4控制硬件虚拟化设置。DR0～DR7寄存器用于设置内存断点。（注意，虽然调试寄存器有 8 个，但系统只支持 4 个内存断点DR0～DR3，其余寄存器用于保存状态） 指令集 x86指令集为寄存器和内存之间的数据移动提供了很大的灵活性。数据移动可以分为 5 种方式： 立即数到寄存器 寄存器到寄存器 立即数到内存 寄存器到内存，或反向 内存到内存 前四种是所有现代体系结构都支持的，而最后一种是x86独有的。像 ARM 这样的经典RISC体系结构只支持通过加载/存储指令（LDR/STR）从内存读出或反向内存写入数据。比如递增内存中数据值需要执行 3 条指令： 把数据从内存读入到寄存器中（LDR） 寄存器加 1（ADD） 把寄存器值写回内存（STR） 而对已x86来说，因为可以直接访问内存，这样的操作只需要一条指令（INC或ADD）。MOVS指令可以同时读写内存。 ARM： 1234561B 68 LDR R3, [R3]; 读入地址R3处的值并保存在R2中5A 1C ADDS R2, R3, #1; 加11A 60 STR R2, [R3]; 把更新后的值写回地址R3处 x86： 12FF 00 inc dword ptr [eax]; 直接递增地址EAX处的值 x86的另一个重要特性是使用了变长指令——指令的长度从1到15字节不等。而在ARM上，指令长度只能是2字节或4字节。 语法 根据汇编器/反汇编器的不同，x86 汇编代码有两种记法：Intel和AT&amp;T。 Intel(Windows 上的记法)： 123mov ecx, AABBCCDDhmov ecx, [eax]mov ecx, eax AT&amp;T(unix 上的 GCC 记法): 123movl $0xAABBCCDD, %ecxmovl (%eax), %ecxmovl %eax, %ecx AT&amp;T 记法在寄存器前加前缀%，立即数前加$。Intel 记法不加前缀。 AT&amp;T 记法加入了指示指令宽度的后缀，比如 MOVL(长整型)、MOVB(字节)等。Intel 记法没有这种标记。 AT&amp;T 记法把源操作数放在目标操作数之前。Intel 记法与之相反。 数据移动 指令用于操作来自寄存器或主内存中的数据。 栈操作与函数调用 C 语言的局部变量就存储在函数的栈空间中。操作系统从ring3切换到ring0时，要把状态信息保存在栈上。具体来讲，x86上的栈是ESP指向的一段连续内存区域，他向下增长。压栈（push指令）递减ESP的值，然后把数据写入 ESP 指向的位置；出栈（pop指令）读出ESP指向位置的数据并递增ESP。默认的自动递增/递减值为 4，但是通过前缀这个值也可以替换为 1 或 2。实际上，这个值几乎总是 4，因为 OS 要求栈双字对齐。 假定ESP最初指向0xb20000，然后执行下面的代码： 12345678910111213; 起始值ESP=0xb20000B8 AA AA AA AA MOV EAX,0AAAAAAAAhBB BB BB BB BB MOV EBX,0BBBBBBBBhB9 CC CC CC CC MOV ECX,0CCCCCCCChBA DD DD DD DD MOV EDX,0DDDDDDDDh50 PUSH EAX; 地址0xb1fffc值将会是0xAAAAAAAA，ESP将会是0xb1fffc （=0xb20000-4）53 PUSH EBX; 地址0xb1fff8的值将会是0xBBBBBBBB，ESP将会是0xb1fff8 （=0xb1fffc-4）5E POP ESI; ESI值将会是0xBBBBBBBB，ESP将会是0xb1fffc （=0xb1fff8+4）5F POP EDI; EDI值将会是0xAAAAAAAA，ESP将会是0xb20000 （=0xb1fffc+4） 其他一些指令也可以直接修改ESP，比如ADD和SUB 高级语言中有函数的概念，函数可以被调用也可以返回，而处理器本身并没有提供这样的抽象。在最底层，处理器只操作具体对象，比如寄存器或内存中的数据。在机器语言这一层级通过栈数据结构来实现函数。 C 代码： 12345int__cdecl addme(short a, short b)&#123; rerurn a+b;&#125; 汇编代码： 12345678910004113A0 55 push ebp004113A1 8B EC mov ebp, esp...004113BE 0F BF 45 08 movsx eax, word ptr [ebp+8]004113C2 0F BF 4D 0C movsx ecx, word ptr [ebp+0ch]...004113CB 8B E5 mov esp, ebp004113CD 5D pop ebp004113CE C3 retn; retn 指令就是把存储在栈顶的地址出栈到EIP，然后把控制传递给他（完全与POP EIP类似，但是x86上并没有这样的指令序列） 通过下面的代码调用函数： C 代码 1sum = addme(x,y); 汇编代码 12345004129F3 50 push eax...004129F8 51 push ecx004129F9 E8 F1 E7 FF FF call addme004129FE 83 C4 08 add esp, 8 先了解一下调用惯例，调用惯例规定了在机器层面如何进行函数调用。对于特定的系统来说他是由应用程序二进制接口(Application Binary Interface, ABI)所定义的。 调用惯例 CDECL STDCALL FASTCALL 参数 从右向左压栈。调用方负责在调用后清理栈 与 CDECL 相同，除了被调用方负责清理栈 前两个参数通过 ECX 和 EDX 传递。其余压栈 返回值 保存在 EAX 中 保存在 EAX 中 保存在 EAX 中 非易失寄存器 EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI EBP、ESP、EBX、ESI、EDI 现在我们回到前面的代码片段来讨论函数addme是如何被调用的。 在第 1 行和第 3 行代码中把两个参数压入栈顶，EXC和EAX分别是第一个和第二个参数。第四行代码通过CALL指令调用了addme函数。这立即导致返回地址0x4120FE被压栈，然后0x4113A0处开始执行。 第 4 行代码执行后，就进入了addme函数的函数体。第 1 行代码把EBP压栈。第 2 行代码把EBP设置为指向当前栈顶。这个二指令序列建立了一个新的函数帧，因此通常称为函数序言（function prologue）第 4 行代码读入地址EBP+8的值，他是栈的第一个参数。第 5 行代码读入第二个参数。注意参数访问是以EBP作为基地址的。在这个上下文环境中，EBP被称为帧基指针，因为他指向了当前函数的栈帧，参数和局部变量都可以通过相对他的地址来访问。也可以通过一种称为帧指针省略（frame pointer omission）的优化方法指定编译器生成不使用EBP作为帧指针的代码。这种优化下，局部变量和参数的访问是相对ESP进行的，这时EBP可以作为一个通用寄存器，就像EAX、EBX、EXC等寄存器一样。第六行代码执行数字的加运算，并把结果放入EAX中。第 8 行代码把栈指针设为帧指针。第 9 行代码将之前第 1 行中保存的EBP数值出栈到EBP。这个二指令序列结束了当前的函数调用，并恢复了函数调用前的栈帧通常称为函数尾声（function epilogue）。这个时间点上，栈顶值为CALL指令保存的返回地址0x4129F9。第 10 行执行RET指令，这个指令将栈顶元素出栈并从0x4129FE开始继续执行。代码中的第 5 行把栈收缩了 8 字节大小，因为根据CDECL调用惯例的规定，栈清理的工作必须由调用者完成。 如果函数addme有局部变量，那么代码需要在第 2 行之后通过减小ESP值来增长栈大小。然后所有的局部变量都可以通过EBP加上一个负的偏移量来访问。 控制流 ZF(Zero Flag， 零标志位)：指示之前算术运算的结果是否为 0 SF(Sifn Flag， 符号标志位)：设为当前结果的最高有效位 CF(Carry Flag， 借位标志位)： 指示当前结果是否需要借位。对无符号整数有效。 OF(Over Flag， 溢出标志位)： 只是当前结果是是否超过了最大值。对有符号整数有效。 算术运算指令会根据计算结果更新这些标志位。举例来说，SUB EAX,EAX指令会引起 ZF 标志的设置。Jcc指令会根据这些标志位改变控制流，其中cc是某个条件代码(conditional code)，该指令最多支持 16 中条件代码。 条件代码 跳转条件 机器描述 JZ/JE 若为 0；若相等 ZF = 1 JNZ/JNE 若不为 0；若不相等 ZF = 0 JS 若为负 SF = 1 JNS 若不为负 SF = 0 JP/JPE 若 1 出现的次数为偶数 PF = 1 JNP/JPO 若 1 出现的次数为奇数 PF = 0 JO 若溢出 OF = 1 JNO 若无溢出 OF = 0 JC/JB/JNAE 若进位；若低于；若不高于等于 CF = 1 JNC/JNB/JAE 若无进位；若不低于；若高于等于 CF = 0 JBE/JNA 若低于等于；若不高于 ZF = 1 或 CF = 1 JNBE/JA 若不低于等于；若高于 ZF = 0 或 CF = 0 JL/JNGE 若小于；若不大于等于 SF != OF JNL/JGE 若不小于；若大于等于 SF = OF JLE/JNG 若小于等于；若不大于 ZF != OF 或 ZF = 1 JNLE/JG 若不小于等于；若大于 SF = 0 且 ZF = 0 系统机制 两种基础系统机制：虚拟地址转换（virtual address translation）和异常/中断处理（exception/interrupt handling） 地址转换 计算机系统中的物理内存以4KB为单元作为一个页（page）。实际上页的大小也可以超过4KB，这里我们不讨论其他尺寸的页。内存地址分为两种：虚拟内存和物理内存。在分页启动的情况下，处理器执行的指令中使用的地址是虚拟地址。举例来说： 12A1 78 56 34 12 MOV EAX, [0x12345678] ; 读入虚内地址为0x12345678的内存89 08 MOV [EAX], ECX ; 把ECX写入虚拟地址为EAX处 物理地址是处理器访问内存时使用的实际内存地址。处理器的MMU(Memory Management Unit， 内存管理单元)在访问内存之前透明地把虚拟地址转换为物理地址。在用户开来虚拟地址就是一个数字，而对于MMU来说这个地址则是结构化的。在支持PAE(Physical Address Extension， 物理地址扩展)的x86系统上，虚拟地址可以划分为几个部分，作为偏移量索引到三个表中，包括PDPT(Page Directory Pointer Table，页目录指针表)、PD(Page Directory，页目录)、PT(Page Table， 页表)以及PTE(Page Table Entry，页表项)。PDPT是4个元素的数组，每个元素8字节，指向一个PD。PD是一个有512个元素的数组，每个元素8字节，指向一个PT。PT也是一个有512个元素的数组，每个元素8字节，指向一个PTE。以虚拟地址0xBF80EE6B(转换成二进制：10111111 10000000 11101110 01101011)来理解，如下表： 10(0x2) 111111 100(0x1FC) 00000 1110(0xE) 1110 01101011(0xE6B) 2 位 9 位 9 位 12 位 索引到 PDPT 索引到 PD 索引到 PT 页偏移量 这些表中的 8 字节元素包含关于表、内存访问许可以及其他内存属性的数据。比如，其中有一些位用于标识这个页是只读还是可读写、是否可执行、用户是否可以访问等。 地址转换过程就围绕着这 3 个表和CR3寄存器。CR3寄存器保存着PDPT的物理基地址。 中断与异常 简单讲就是操作系统通过中断和异常机制实现系统调用，完整的实现细节参考 Windows 内核部分。 x64 x64是x86的扩展，所有两者的绝大多数体系结构特性都一样，只有略微不同，比如寄存器宽度，以及某些指令不可再用(比如PUSHAD)。 寄存器组与数据类型补充 x64的寄存器组有18个64位GPR，下面画图解释这些寄存器的结构，注意前缀为R的是64位寄存器。 123456789101164 . . . 31 23 15 7 0|RAX | | | | | | | || | | | |EAX | | | || | | | | | | AX | || | | | | | | AH | AL |64 . . . 31 23 15 7 0|RBP | | | | | | | || | | | |EBP | | | || | | | | | | BP | || | | | | | | | BPL | 虽然RBP任然可以用作帧基指针，但实际应用中编译器生成的代码很少这么用，多数x64编译器只是把RBP当作GPR来用，而用RSP作为基地址引用局部变量。 数据移动补充 x64支持一种称为RIP相对寻址(RIP-relative addressing)的概念，其允许指令引用数据时使用相对RIP的地址。例如： 123450000000000000000 48 8B 05 00 00+ mov rax, qword ptr cs:loc_A ; 最开始写作&quot;mov rax,[rip]&quot;0000000000000007 loc_A:0000000000000007 48 31 C0 xor rax,rax000000000000000A 90 nop 第 1 行读入loc_A的地址（为0x7）然后保存到RAX中。RIP相对寻址主要用于产生位置无关代码。 多数算术运算指令都自动升级为64位，即使操作数只有32位。例如： 123448 B8 88 77 66+ mov rax, 1122334455667788h31 C0 xor eax, eax ; 也会清除RAX的高32位，也就是说执行后RAX=048 C7 C0 FF FF+ mov rax, 0FFFFFFFFFFFFFFFFhFF C0 inc eax ; 执行后RAX=0 规范地址 x64中虚拟地址的宽度是64位，但多数处理器并不支持完整的64位虚拟地址空间。当前Intel/AMD处理器只使用48位地址空间。所有的虚拟地址必须为规范形式。如果一个虚拟地址从第63位到具体实现的最高有效位都是1或者都是0，那么这个虚拟地址就称为规范地址。具体来说，这意味着从48到63位都要和47位相同。如果代码引用一个非规范地址，就会触发系统异常。 函数调用 x86上有一些调用惯例需要通过栈来传递一些参数。对于x64来说，多数调用惯例都是通过寄存器传递参数，比如在windows x64中，只有一种调用惯例用到栈，并且其中前四个参数还是通过RCX、RDX、R8和R9来传递的；其余的参数按照从左到右的顺序压栈。Linux 上，则是前 6 个参数通过RDI、RSI、RDX、RCX、R8和R9传递。 ------------------------本次更新时间 2018-10-16 10:53 ARM 这里介绍的是ARM Architecture Reference Manual ARMv7-A and ARMv777-R Edition (ARM DDI 0406B)中定义的ARM体系结构。 基本特性 ARM是RISC体系结构，因此与CISC体系结构(x86/x64)有一些基本区别。(从实践的角度说，最新版本的Intel处理器也具有一些RISC的特征；也就是说，他们已经不再是纯粹的CISC。)首先，与x86相比，ARM的指令集是很小的，但是提供的通用寄存器更多。第二，指令的宽度是固定的（16位或32位，根据当前状态而定）。第三，ARM的内存访问模式是加载-存储模式。这意味着操作数据之前必须先要把它从内存加载到寄存器中。只有加载/存储指令能够访问内存，具体来说，在ARM中是LDR和STR指令。如果要递增某个内存地址上的32位数值，必须先把数值从这个地址加载到寄存器中，递增，然后再存储回去。x86则允许大多数指令直接操作内存中的数据，只需要简单的加载，操作，递增三步。 ARM还提供了几种不同级别的特权模式来实现特权隔离。x86上的特权级别是通过 4 种ring级别定义的，其中ring0具有最高特权级别，ring3的特权级别最低。在ARM中，有 8 种不同级别的特权模式： USR(USER,用户模式) FIQ(FAST INTERRUPT REQUEST,快速中断请求模式) IRQ(INTERRUPT REQUEST,中断请求模式) SVC(SUPERVISOR, 管理模式) MON(MONITOR,监视模式) ABT(ABORT,中止模式) UND(UNDERFINED,未定义指令模式) SYS(SYSTEM,系统模式) 多数操作系统内核模式运行于SVC。在Windows或Linux上都是。 x64处理器可以运行在32位或64位模式下，也可以交替运行于这两种模式下。ARM处理与之类似，他们也可以运行在两种状态下：ARM和Thumb状态。ARM/Thumb状态决定的只有指令集，而不是特权模式。比如运行子啊在ARM状态下，指令总是32位宽；而在Thumb下，指令可以是16位宽也可以是32位宽。决定处理器执行状态的是以下两个因素。 通过 BX 和 BLX 指令进行分支跳转的时候，如果目标寄存器的最低有效位是 1，就切换到 Thumb 状态。（尽管指令是 2 字节对齐或 4 字节对齐的，但处理器会忽略最低有效位，因此不会有对齐的问题。） 如果当前程序状态寄存器（CPSR）中的 T 标志位被置起，就处于 Thumb 模式。CPSR 的语义会在之后详述，目前可以把它类比为 x86 中扩展的 EFLAGS 寄存器。 ARM核心启动的时候，多数情况下都是进入ARM状态并保持在这个状态，知道显式或隐式地切换到Thumb模式。具体实践中，多数较新的操作系统使用Thumb代码是为了获得更高的代码密度（混合使用16/32位宽度指令的代码大小小于全部使用32位指令），而且应用程序可以运行于任意模式下。因为多数Thumb和ARM指令助记符都是相同的，所以在32位Thumb指令后添加一个.W后缀标识。 注意，有一种很常见的误解，就是把Thumb模式看作x86/x64上的实模式，把ARM模式看作保护模式。x86/x64平台上的绝大多数操作系统运行于保护模式，很少会切换回实模式。位ARM平台上的操作系统和应用程序则可以交替运行于ARM状态和Thumb状态。还要注意，这两个状态与前面介绍的特权模式也是完全不同的概念。 Thumb有两个版本：Thumb-1和Thumb-2。Thumb-1用于ARMv6和更早期的体系结构，指令集宽度都是16位。Thumb-2增加了更多的指令，并支持16位和32位的指令宽度。ARMv7只用Thumb-2，所以只要是讨论Thumb，都是Thumb-2、 ARM状态与Thumb状态还有其他一些区别，这里我们没法全部介绍。比如，某些指令只在ARM状态下支持，而在Thumb状态下不可用，或者反之。要了解更多请参考ARM的官方文档。 ------------------------更新时间 2018-10-17 16:34 数据类型与寄存器 与高级语言类似，ARM也支持多种数据类型的运算，包括：8位（字节），16位（半字）、32位（字）和64位（双字）。 ARM的体系结构定义了16个32位通用寄存器，命名为R0~R15，实际开发中只用前13个作为通用寄存器（就像x86中的EAX、EBX等），最后三个有特殊的意义。 R13 用作栈指针(Stack Point, SP)，等价于 x86/64 下的 ESP、RSP 寄存器，指向程序栈的顶端 R14 用作连接寄存器（Link Register, SP），通常用于在函数调用中保存返回地址。某些指令会隐式的使用这个寄存器。比如，BL 总是在分支跳转到目标地址之前把返回值保存在 LR 中。x86/64 中总是把返回地址放在栈上，所以没有相应的寄存器。在不使用 LR 存储返回地址的代码中，这个寄存器可以作为通用寄存器。 R15 用作程序计数器（Program Counter，PC）。在 ARM 状态下执行的时候，PC 是当前指令的地址加 8（两条 ARM 指令之后）；在 Thumb 状态下，他是当前指令的地址加 4（两条 16 位 Thumb 指令后）。这个寄存器类似与 x86/64 下的 EIP/RIP，但后者总是指向下一条执行指令的地址。另外一个主要的区别在于，ARM 下代码可以直接读写 PC 寄存器，向 PC 寄存器写入一个值会导致运行立即从那个地址开始（参考下面代码片段）。 12340x00008344 push &#123;lr&#125;0x00008346 mov r0,pc0x00008348 mov.w r2, r2, ls1 #310x0000834C pop &#123;pc&#125; 在第 2 行执行之后，R0的值为0x0000834A(=0x00008346+4) 与其他体系结构类似，ARM把当前执行状态信息保存在当前程序状态寄存器（CPSR）中。从应用程序开发者的角度来看，CPSR类似于x86/x84下的EFLAGS/RFLAG寄存器。某些文档中会提到应用程序状态寄存器（APSR），这是CPSR中某些字段的别名。CPSR中有很多标志位，下面列出其中的部分： E(大小端标志位，Endianness bit)：ARM 可以运行在大端或小端模式下。这一位设置为 0 表示小端，1 表示大端。多数情况下使用小端，即为 0。 T(Thumb 标志位)：在 Thumb 状态下，这一位会设为 1；否则就是 ARM 状态。从 Thumb 到 ARM 或反向的状态切换的方式之一，就是修改这一标志位。 M(模式标志位， Mode Bit)：这几位指定当前的特权模式（USR、SVC 等）。 12 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M | ------------------------更新时间 2018-10-18 09:30 系统级控制与设置 ARM提供了协处理器的概念来支持额外的指令和系统级设置。举例来说，如果系统支持内存管理单元(MMU, Memory Management Unit)，那么内存管理单元的配置接口必须提供给启动代码或内核代码。在x86/x64上，这些设置接口是放在CR0和CR4中的；而在ARM上，则放在CP15中，ARM体系结构中有16个协处理器，编号为CP0~CP15.前 13 个协处理器时可选的或者是ARM保留的。制造商可以通过可选协处理器实现特定的指令或功能，每个协处理器提供了额外的“操作码”和寄存器，可以通过专门的ARM指令控制。举例来说，CP10和CP11常常用于调试和系统设置。而且CP15通常被称为系统控制协处理器，它保存着绝大多数系统设置（缓存、分页、异常等）。 1注意：NEON提供了单指令多数据（SIMD）指令集，通常用于多媒体应用程序。它与基于x86体系结构的SSE/MMX指令类似。 每个协处理器有16个寄存器和8个相应的操作码。这些寄存器和操作码的语义是特定于协处理器的。协处理器只能通过MRC(读)和MCR(写)指令访问，这两个指令接受协处理器编号、寄存器编号和操作码作为参数。举例来说，要读出转换基址寄存器(类似于x86/x64中的CR3)并保存到R0中，可以使用如下代码： 1MRC p15, 0, r0, c2, c0, 0 ; 保存到TTBR中 这句代码表示：“使用操作码0/0读出CP15的C2/C0，并保存结果到通用寄存器R0。”因为每个协处理器有很多寄存器和操作码，需要阅读文档才能确定其中每一个的精确含义。有些寄存器（C13/C0）是操作系统保留的，用于保存特定于进程或线程的数据。 MRC和MCR指令并不需要高特权级别才能运行（也就是说，可以在 USR 模式下执行），但有些协处理器寄存器和操作码只能在SVC模式下访问，如果没有足够的特权级别，该寄存器会导致异常。在实际的用户模式代码中很少看到这些指令，他们通常用在像ROM、bootloader、固件这样很底层的代码或内核模式代码中。 ------------------------更新时间 2018-10-21 13:10 指令集介绍 相比起x86体系结构，除了条件执行和桶式移位器，ARM 的指令集还有几点独特之处。首先，有些指令可以一次操作一系列寄存器。比如要把 5 个寄存器R6~R10保存到R1指向的一段内存位置，可以使用指令STM R1,&#123;R6-R10&#125;。R6会保存到内存地址R1，R7保存到R1+4，R8保存到R1+8，以此类推。对于不连续的寄存器，可以用逗号分隔（比如&#123;R1,R5,R8&#125;）。ARM的汇编语法中，寄存器范围通常用花括号表示。其次，有些指令在读写操作之后可能会更新基址寄存器，这通常通过在寄存器名后添加感叹号!来表示。举例来说，如果把前面的指令改写为STM R1!, &#123;R6-R10&#125;并执行，那么R1将会被更新为保存R10的地址之后的下一个地址。 ------------------------更新时间 2018-10-22 08:10 数据加载与存储 ARM是一种加载-存储式的体系结构，这意味着数据一定要加载到寄存器中才能操作。只有加载和存储指令能够访问内存，所有其他指令都只能操作寄存器。加载是指从内存中读入数据并保存到寄存器中的过程，存储则是指把寄存器的内容写入内存中的过程。在ARM体系结构中，加载和存储指令包括LDR/STR、LDM/STM和PUSH/POP。 LDR 与 STR LDR/STR指令比较基础的形式是，接受一个基址寄存器和一个偏移量作为参数。偏移量的表示有三种格式（立即数、寄存器、标量寄存器），每种格式有三种寻址形式。 第一种形式使用立即数作为偏移量。立即数就是一个整数。把这个数字与基址寄存器相加或相减，用于访问编译期偏移量可知的数据。立即数最常见的用途是访问结构或虚函数表中的某个特定字段。一般形式： STR Ra, [Rb, imm] LDR Ra, [Rc, imm] Rb是基址寄存器，imm是要加到Rb的偏移量 第二种偏移量格式用一个寄存器作为偏移量，通常用于访问数组中的元素，其索引值是运行时计算出的情况。其一般格式如下： STR Ra, [Rb, Rc] LDR Ra, [Rb, Rc] 根据上下文的不同，Rb或Rc可以是基址或偏移量。 第三种偏移量格式是使用标量寄存器作为偏移量。通常这种形式用在数组的迭代循环，而桶式移位器用于计算偏移量的步长。这种格式的一般形式如下： STR Ra, [Rb, Rc, &lt;shifter&gt;] LDR Ra, [Rb, Rc, &lt;shifter&gt;] Rb 是基址寄存器，Rc 是一个立即数，&lt;shifter&gt;是在立即数上执行的操作，他通常通过一个左移或右移操作对立即数进行成比例放大或缩小。 ------------------------更新时间 2018-10-23 07:30 LDR 的其他用途 LDR用于从内存向寄存器中加载数据，但有时候会看到这样的形式： 12301: DF F8 50 82 LDR.W R8, =0x2932E00 ; LDR R8, [PC, x]02: 80 4A LDR R2, =a04d ; &quot;%04d&quot; ; LDR R2, [PC, y]03: 0E 4B LDR R3, =__imp_realloc ; LDR R3, [PC, z] 伪指令内部使用了立即数寻址形式的LDR指令，PC作为基址寄存器。有时这也成为PC相对寻址（或在x64上称为RIP相对寻址）。ARM二进制文件通常有一个文本池（literal pool），这是某个字段中的一块内存区域，用于保存常量、字符串和用于提供位置无关索引支持的偏移量。（文本池是代码的一部分，所以在同一段中。）在前面的代码片段里，代码引用了保存在文本池中的一个32位常量、一个字符串和一个导入函数的偏移量。利用这种伪指令，可以只通过一个指令就把 32 位常量移入寄存器，因此它是很有用的。为了更清晰一点，下面给出一段代码示例： 1234501: .text:0100B134 35 4B LDR R3, =0x68DB8BAD; 实际上就是LDR R3, [PC, #0xD4]; 这时PC = 0x0100B13802: ...03: .text:0100B20C AD 8B DB 68 dword_100B20C DCD 0x68DB8BAD 因为代码处于Thumb状态，PC值是当前指令加上4，也就是0x0100B138。这里使用了立即数寻址方式，所以要读出位于0x0100B20C（=0x0100B138+0x4D）的字，这就是我们想要加载的常量。 ------------------------更新时间 2018-10-26 07:00 LDM 与 STM LDM和STM与LDR/STR类似，区别是前者可以从给定的基址寄存器加载多个字。LDM和STM通常用于从内存读出或写入多个数据块，通常语法为： 12LDM&lt;mode&gt; Rn[!], &#123;Rm&#125;STM&lt;mode&gt; Rn[!], &#123;Rm&#125; Rn是基址寄存器，其中保存要加载/存储的内存地址。！是可选的，意思是基址寄存器会更新为新的地址（写回）。Rm是要加载或存储的范围。LDM和STM有四种模式。 IA（后递增，Increment After）模式把数据存储到基址寄存器指定的内存位置。如果有写回的话，就写回最后一个地址加 4 字节的地址。如果没有指定的话，这是默认使用的模式。 IB（前递增，Increment Before）模式把数据存储在基址寄存器加 4 的地址上。如果有写会的话，就把最后地址写回。 DA（后递减，Decrement After）模式保存数据使得最后的地址是基地址。如果有写回的话，就把最低地址减 4 写回。 DB（前递减，Decrement Before）模式存储数据使得最后的地址是基地址减 4.如果有写回的话，就把最低地址写回。 下面是调试器观察的实例： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disas mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;: mov r2, #120x00008354 &lt;+16&gt;: ldm r6, &#123;r3,r4,r5&#125; ; IA模式0x00008358 &lt;+20&gt;: stm r6, &#123;r0,r1,r2&#125; ; IA模式...(gdb) rBreakpoint 1, 0x00008344 in main ()(gdb) si0x00008348 in main ()(gdb) x/3x $r60x105c &lt;mem&gt;: 0x00000001 0x00000002 0x00000003(gdb) si0x0000834c in main ()...(gdb)0x00008358 in main ()(gdb) info reg r3 r4 r5r3 0x1 1r4 0x2 2r5 0x3 3(gdb) si0x0000835c in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;: 0x0000000a 0x0000000b 0x0000000c 第 5 行把一个内存地址写入R6，这个内存地址（0x1050c）的内容是一个 3 字数据（第 17 行）。6-8 行将R2～R0设置为某个常量。第 9 行加载从R6指向的内存地址开始的 3 个字到R3～R5。如第 24 ～ 26 行所示，R3～R5的内容正是期望值。第 10 行存储R0~R2到R6指向的内存地址开始的空间。第 29 行显示了期望的写入值。下图展示前面的操作结果。 123456789101112131415161718192021222324252627282930 mem|---|| 0x1 | | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | | | ldm r6, &#123;r3,r4,r5&#125; || --- |\\/|---|| 0x1 | r6 | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | r6+4 | || --- |||| 0x3 | r6+8 | || --- |\\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0xA | r6 || --- || 0xB | r6+4 || --- || 0xC | r6+8 || --- |r0=a r1=b r2=cr3=1 r4=2 r5=3 下面用写回模式做同样的实验： 123456789101112131415161718192021222324252627282930(gdb) br mainBreakpoint 1 at 0x8344(gdb) disaa mainDump of assembler code for function main:0x00008344 &lt;+0&gt;: ldr r6, =mem ; 稍有修改0x00008348 &lt;+4&gt;: mov r0, #100x0000834c &lt;+8&gt;: mov r1, #110x00008350 &lt;+12&gt;:mov r2, #120x00008354 &lt;+16&gt;:ldm r6!, &#123;r3, r4, r5&#125; ; IA带写回模式0x00008358 &lt;+20&gt;:stmia r6!, &#123;r0, r1, r2&#125; ; IA带写回模式...(gdb) rBreakpoint 1, 0x0008344 in main ()(gdb) si0x00008348 in main ()...(gdb)0x00008354 in main ()(gdb) x/3x $r60x1050c &lt;mem&gt;： 0x000001 0x00000002 0x00000003(gdb) si0x00008358 in main ()(gdb) info reg r6r6 0x10518 66840(gdb) si0x0000835c in main ()(gdb) info reg $r6r6 0x10524 66852(gdb) x/4x $r6-120x10518 : 0x0000000a 0x0000000b 0x0000000c 0x00000000 第 9 行使用IA写回模式，所以R6更新为最后地址加 4 的值（第 23 行）。第 10 行、27 行和 30 行可以看到同样的模式。下图展示了实验代码片段执行的结果： 12345678910111213141516171819202122232425262728293031323334 mem|---|| 0x1 | 0x1050c | | ldr r6, =mem || --- ||| mov r0, #10| 0x2 | 0x1050c+4 | | mov r1, #11 || --- ||| mov r2, #12| 0x3 | 0x1050c+8 | | ldm r6!, &#123;r3,r4,r5&#125; || --- |0x1050c+c \\/|---|| 0x1 | 0x1050c | | stm r6, &#123;r0,r1,r2&#125; || --- |||| 0x2 | 0x1050c+4 | || --- |||| 0x3 | 0x1050c+8 | || --- |0x1050c+c r6 \\/r0=a r1=b r2=cr3=1 r4=2 r5=3|---|| 0x1 | 0x1050c || --- || 0x2 | 0x1050c+4 || --- || 0x3 | 0x1050c+8 || --- || 0xA | 0x1050c+c || --- || 0xB | 0x1050c+10 || --- || 0xC | 0x1050c+14 || --- | 0x1050c+18 r6 | LDM和STM指令可以一次写入多个字，所以通常用于块复制和块移动操作。比如有时用这些指令来执行编译时复制长度已知的内联memcpy。这类似于x86中带有REP前缀的movs指令。 注意 STM/LDM后面经常会出现后缀FD、FA、ED或EA。它们就是不同模式下（IA/IB等）的STM/LDM指令的伪指令，分别对应于STMFD/STMDB、STMFA/STMIB、STMED/STMDA、STMEA/STMIA、LDMFD/LDMIA、LDMFA/LDMDA和LDMEA/LDMDB。因为这些对应关系太难记忆，建议为每个指令画一个图。 ------------------------更新时间 2018-11-4 08:00 PUSH 与 POP 加载/存储指令的最后一组是PUSH和POP。他们类似于LDM/STM，但有两点不同： 他们隐式地使用 SP 作为基地址； SP 会自动更新。 和x86/x64中的一样，栈是朝下向低地址方向增长的。通用的语法是PUSH/POP &#123;Rn&#125;,其中Rn可以是一个寄存器范围。 PUSH指令把一个或多个寄存器保存在栈中，使得最后一个的位置位于当前栈指针向下 4 字节处，然后把SP更新为第一个位置的地址。POP从当前栈指针处开始向寄存器加载数据，然后更新SP为最后一个位置的地址的向上 4 字节处。PUSH/POP实际上就是以SP作为基地址指针的带写回的STMDB/LDMIA。 最常用到PUSH/POP的地方就是在函数的起始和结束处，在这里他们被用作函数序言和尾声（就像ARM状态下的STMFD/LDMFD一样）。举例来说： 1232D E9 F0 4F PUSH.W &#123;R4-R11, LR&#125; ; 保存寄存器和返回地址...BD E9 F0 8F POP.W &#123;R4-R11, PC&#125; ; 恢复寄存器值并返回 ------------------------更新时间 2018-11-5 07:00 函数与函数调用 x86/x64只有一个用于函数调用的指令（CALL）和一个用于分支跳转的指令（JMP）。与之不同，根据目标地址的编码方式，ARM 则提供了多种指令。调用函数的时候，处理器需要知道函数返回后从哪里继续执行，这个位置通常被称为返回地址。在x86中，CALL指令在跳转到目标函数之前隐式地把返回地址压入栈顶，等到目标函数执行完毕，会把栈顶弹出到EIP，从而从返回地址恢复执行。 ARM体系结构上的机制本质上也是如此，只有几点微小的区别。首先，返回地址可以保存在栈上，也可以保存在链接寄存器（LR）中；调用结束后要恢复执行，需要显式地把返回地址从栈上弹出到PC寄存器，否则会无条件跳转到LR。其次，根据目标地址的最低位（LSB）不同，一次分支跳转可以在ARM状态和Thumb状态之间切换。第三点，ARM定义了标准调用惯例：前 4 个 32 位参数通过寄存器（R0-R3）传递，其余的参数放在栈上。返回值保存在R0中。 ARM中函数调用的指令是B、BX、BL和BLX。 尽管在函数调用的上下文中很少看到B指令，但这条指令确实可以用于控制传递。他就是一条简单的无条件跳转指令，于x86中的JMP指令相同，通常在循环和条件执行内部用于跳转到开头或跳出循环，还可以用于调用永不返回的函数。 B指令只能使用标签偏移量作为其目标地址，而不能使用寄存器。在这种情况下，B指令的语法为B imm，其中imm是相对于当前指令的偏移量。（这里没有考虑条件执行标志位，将会在之后的笔记中详细介绍。）需要记住的是：因为ARM和Thumb指令是2字节或4字节对齐的，所以目标偏移量必须是一个偶数。 BX是分支跳转并交换（Branch and Exchange）。与B指令的相似之处在于，两者都是把控制转移到某个目标地址处，但BX能够在ARM和Thumb状态间切换，并且目标地址是保存在寄存器中的。分支跳转指令以X结尾，表示这条指令能切换状态。如果目标地址最低位是 1，那么处理器会自动切换到Thumb状态，否则就执行在ARM状态。指令的格式是BX&lt;寄存器&gt;，其中寄存器中存有目标地址。这条指令有两种最常用的方式，一种是通过跳转到LR（也即 BX LR）从函数返回，还有一种是用于切换到不同状态的代码（也即从ARM切换到Thumb状态或反之）。在编译后的代码中，函数结尾处几乎总会出现BX LR，基本上于x86中的RET相同。 BL是分支跳转并连接（Branch with Link），它类似于B指令，但他可以在把控制切换到目标偏移量之前把返回地址保存到LR。这也许是和x86中的CALL指令最为接近的一条指令，经常在函数调用中使用。BL指令格式与B指令相同（也就是说，只接受偏移量参数）。下面这段代码解释了函数调用和返回的过程： 1234567800014350 BL foo ; LR = 0x0001435400014354 MOVS R4, #0x15...0001B224 foo0001B224 PUSH &#123;R1-R3&#125;0001B226 MOV R3, 0x6124...0001B24C BX LR ; 返回到0x00014354 上面代码的第 1 行使用BL调用函数foo。在转换控制到目标之前，BL在LR中保存了返回地址（0x000014354）。foo做了一些工作然后返回到调用者（BX LR）。 BLX是指跳转加连接和交换（Branch with Link and Exchange）。于BL类似，BLX也可以支持状态切换。两者主要的区别在于，BLX可以接受偏移量或寄存器作为跳转目标，而且在BLX指令使用偏移量的情况下，处理器总是会切换状态（ARM到Thumb或反之）。因为这条指令于BL的特性相同，也可以把它当做x86中的CALL指令。实际使用中，BL和BLX都用于实现函数调用。如果函数在32MB范围之内，通常使用BL，而目标区域不确定（比如函数指针）的时候常用BLX。通常在Thumb状态下运行的时候，使用BLX指令调用库例程，而在ARM状态下使用BL。 ------------------------更新时间 2018-11-9 07:00 算术运算 把数值从内存加载到寄存器之后，代码就可以上面执行各种操作了。最简单的操作就是通过mov指令把数据移动到另一个寄存器中。操作源可以是常量、寄存器或桶式移位器的运算结果。桶式移位器运算包括左移（LSL）、右移（LSR、ASR）和循环移位（ROR、RRX）。桶式移位器让指令可以操作无法以立即数形式编码的常量，因此很有用处。ARM和Thumb指令的宽度可能是16位或32位，所以无法直接使用32位常数作为参数。有了桶式移位器，立即数可以被转换为一个更大值然后移动到其他寄存器。另一种移动32位常量到寄存器的方法是把常量分割为两个16位数值，分两次移动；这通常通过MOVW和MOVT指令实现。MOVT设置寄存器的高16位，MOVW设置低16位。 基本算术和逻辑运算包括ADD、SUB、MUL、AND、ORR和EOR。 注意：ARM没有原生的除法指令。（ARMv7-R和ARMv7-M内核有SDIV和UDIV指令，但这里不讨论）实际应用中，运行时会使用软件实现来进行除法运算，代码只要按需调用。下面是Windows C运行时的一个例子： 12341 46 MOV R1， R840 46 MOV R0,R635 F0 9E 9F BL __rt_udiv ; udiv的软件实现 ------------------------更新时间 2018-11-11 07:00 分支跳转与条件执行 前面讨论的都是按照线性顺序执行的例子，而绝大多数程序都包含有条件与循环。在汇编代码层级，这些结构是通过存储在应用程序状态寄存器（APSR）中的条件标志位实现的。APSR是CPSR的别名，类似于x86中的EFLAG寄存器。 N（Negative，负值标志位）：如果运算的结果是负数，这个标志就会被设置（结果的最高有效位为 1） Z（Zero，零标志位）：运算结果为 0 时设置 C（Carry，借位标志位）：两个无符号值计算结果溢出时设置 V（Overflow，溢出标志位）：两个有符号值计算结果溢出时设置 IT（If-then 标志位）：这些标志位编码了 Thumb 指令 IT 使用的各种条件。 1234567 31 26 15 10 9 5 4 0CPSR |cond.flags | |1T |大小端标志位E | |Thumb标志位T |模式标志位M |...APSR |N|Z|C|V|Q | |保留| 31 26 15 0 N、Z、C 和 V 标志位与 x86 中的 EFLAG 寄存器的 SF、ZF、CF 和 OF 标志位相同。在更高级的语言中，使用这些标志位来实现条件和循环；在指令级代码中，也通过这些标志位支持条件执行。通过这些标志位来描述相等性。 后缀/编码 意义 标志位 EQ 等于 Z==1 NE 不等于 Z==0 MI 减、负 N==1 PL 加、正或者为 0 N==0 HI 无符号大于 C1 且 Z0 LS 无符号小于 C0 或 Z1 GE 有符号大于等于 N==V LT 有符号小于 N！=V GT 有符号大于 Z0 且 NV LE 有符号小于等于 Z==1 或 N！=V 默认情况下指令不会更新条件标志位，除非使用了 S 后缀。比较指令（CBZ、CMP、TST、CMN 和 TEO）会自动更新标志位，因为通常他们被用于分支指令之前。 最常用的比较指令可能就是 CMP。其语法为 CMP Rn, X，其中 Rn 是寄存器，X 可以是立即数、寄存器或桶式移位操作。其语义与 x86 中的同名指令相同：执行 Rn - X，设置相应的标志位，然后丢弃结果。通常这条指令后面会跟随一个条件分支跳转。下面是一个用法示例及其伪代码： ARM 123456789101112B3 EB E7 7F CMP.W R3, R7, ASR #3105 DB BLT loc_less01 DC BGT loc_greaterBD 42 CMP R5, R702 D9 BLS loc_less loc_greater07 3D SUBS R5, #76E F1 00 0E SBC.W LR, LR, #0 loc_lessA5 FB 08 12 UMULL.W R1, R2, R5, R887 FB 08 04 SMULL.W R0, R4, R7, R80E FB 08 23 MLA.W R3, LR, R8, R2 C 伪代码 123if (r3 &lt; r7) &#123;goto loc_less;&#125; else if (r3 &gt; r7) &#123;goto loc_greater;&#125; else if (r5 &lt; r7) &#123;goto loc_less;&#125; ------------------------更新时间 2018-11-12 07:00 Thunb 状态 switch-case 杂项 Windows 内核 调试与自动化 代码混淆 代码研究 windows 内核代码 片段 1： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980; NTSTATUS __cdecl sub_4038f0(PFILE_OBJECT FileObject, HANDLE Handle, BOOLEAN flag)sub_4038F0 proc nearpush rbx ; rbx压栈push rbp ; rbp压栈push rsi ; rsi压栈push rdi ; rdi压栈push r12 ; r12压栈sub rsp, 60h ; rsp的值减去0x60mov bpl, r8b ; r8p的值入bplmov r12, rdx ; 将rdx的值放进栈r12中mov rdi, rcx ; 将rcx的值放进栈rdi中mov cs:IoGetRelatedDeviceObject ; IoGetRelatedDeviceObject返回值指向相应设备对象的指针mov [rsp+88h+arg_18], 1 ; 把1赋给[rsp+88h+arg_18]xor edx, edx ; ChargeQuota 将edx初始化置0mov cl, [rax+4ch] ; StackSize 栈空间大小mov rsi, rax ; 将rax的值放进栈rsi中call cs:IoAllocateIrp ; IoAllocateIrp例程分配一个IRP（为每个驱动层下的调用者给定I/O堆栈数量和选项）test rax, rax ; 相当于and rax rax，根据结果设置标志位，不会保存结果。（影响标志位C,O,P,Z,S。其中C与O两个标志会被设为0）mov rbx, rax ; 将rax的值放进栈rbx中jnz short loc_403932 ; 如果Z标志位为0，就跳转到loc_403932中mov eax, 0C0000017h ; 把立即数0C0000017h放进eax（此处用来表示跳转失败）。立即数必须以数开头，以字母开头会被认为是寄存器或变量。jmp loc_403A0C ; 无条件跳转到 loc_403A0C方法（loc_403A0C方法的作用是清理栈空间）loc_403932:lea rax, [rsp+88h+arg_18] ; rax获取[rsp+88h+arg_18]的地址xor r8d, r8d ; State 状态值初始化为0lea rcx, [rsp+88h+Event] ; Event rcx获取[rsp+88h+Event]的地址mov [rbx+18h], rax ; IRP.AssociatedIrp.SystemBuffer 把rax所指向地址的值赋给[rbx+18h]，也就是把1赋给[rbx+18h]lea rax, [rsp+88h+Event] ; rax获取[rsp+88h+Event]的地址lea edx, [r8+1] ; Type 类型 edx获取[r8+1]的地址mov [rbx+50h], rax ; IRP.UserEvent 把rax所指向[rsp+88h+Event]地址的值赋给[rbx+50h]，作为用户事件lea rax, [rsp+88h+var_58] ; rax获取[rsp+88h+var_58]的地址mov [rbx+48h], rax ; IRP.UserIosb 把rax所指向[rsp+88h+var_58]地址的值赋给[rbx+48h]mov rax, gs:+188h ; KPCR.Prcb.CurrentThread gs寄存器基址+18h得到的地址处的值，赋给raxmov [rbx+0C0h], rdi ; IRP.Tail.OVerlay.OriginalFileObiect 把寄存器rdi的值（也就是前面rcx的值）放进内存[rbx+48h]中mov [rbx+98h], rax ; IRP.Tail.Overlay.Thread gs寄存器基址+18h处的值放进内存[rbx+98h]mov byte ptr [rbx+40h], 0 ; IRP.RequestorMode 把[rbx+40h]处的一个字节填为0call cs:KeInitializeEvent ; 调用 KeInitializeEvent方法将一个事件对象初始化为一个同步或通知类型的事件，并且设置为一个有信号或无信号的状态test bpl, bpl ; and bpl bpl，根据结果设置标志位，不会保存结果。C与O会被设置为0.mov rcx, [rbx+0B8h] ; 将内存[rbx+0B8h]处的值放进rcx中mov byte ptr [rbx+40h], 6 ; IRP_MJ_SET_INFORMATION 把[rbx+40h]处的一个字节填为6mov [rcx-20h], rsi ; IO_STACK_LOCATION.DeviceObject 将rsi处的值放进内存[rcx-20h]中mov [rcx-18h], rdi ; IO_STACK_LOCATION.FileObject 将rdi处的值放进内存[rcx-18h]中jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov rax, [rdi+28h] ; FILE_OBJECT.SectionObjectPointer 将内存[rdi+28h]中的值放进rax中test rax, rax ; and rax rax，根据结果设置标志位，不会保存结果。C与O会被设置为0.jz short loc_4039A6 ; 如果Z标志位为1，就跳转到loc_4039A6中mov [rax+10h], 0 ; SECTION_OBJECT_POINTERS.ImageSectionObject 将[rax+10h]置为0loc_4039A6:mov [rcx-28h], r12 ; IO_STACK_LOCATION.Parameters.SetFile.DeleteHandle 将寄存器r12中的值放进[rcx-28h]中mov [rcx-30h], rdi ; IO_STACK_LOCATION.Parameters.SetFile.Object 将寄存器rdi中的值放进[rcx-30h]中mov dword ptr [rcx-38h], 0Dh ; FileDispositionInformation IO_STACK_LOCATION.Parameters.SetFile.FileInfomationClass 将[rcx-38h]处的双字设置为0Dhmov dword ptr [rcx-40h],1 ; IO_STACK_LOCATION.Parameters.SetFile.Length 将[rcx-40h]处的双字设置为1mov rax, [rbx+0b8h] ; CurrentIrpStackLocation 将[rbx+0b8h]处的值放进rax中lea rcx, sub_4038B4 ; completionroutine rcx获取sub_4038B4的地址mov [rax-10h], rcx ; IO_STACK_LOCATION.ComplerionRoutine 将rcx指向sub_4038B4的地址处的值放进[rax-10h]中mov rcx, rsi ; DeviceObject 将rsi处的值放进rcx中mov rdx, rbx ; Irp 将rbx处的值放进rdx中mov qword ptr [rax-8], 0 ; 将内存[rax-8]处的双字设置为0mov byte ptr [rax-45h], 0E0h ; flag 将内存[rax-45h]处的一个字节设置为0call cs:IofCallDriver ; 调用IofCallDriver方法cmp eax, 103h ; STATUS_PENDING 比较eax和103hjnz short loc_403A09 ; 如果eax和103h不相等就跳转到loc_403A09lea rcx, [rsp+88h+Event] ; Object rcx获取[rsp+88h+Event]的地址mov r9b, 1 ; Alertable 将r9b赋值为1xor r8d, r8d ; WaitMode r8d置为0xor edx, edx ; WaitReason edx置为0mov [rsp+88h+var_68], 0 ; 将[rsp+88h+var_68]置为0call cs:KeWaitForSingleObject ; 调用该方法将当前线程(ethread里以Wait开头的字段WaitIrql,WaitMode,WaitStatus)置为等待状态,直到提供的分发机器对象被置为已处理状态或第五个参数给出的Timeout走完。loc_403A09:mov eax, [rbx+30h] ; IRP.IoStatus.Status 将内存[rbx+30h]处的值赋给eaxloc_403A0C: ; 清理栈add rsp, 60h ; 栈指针rsp+60h进行复位pop r12 ; 出栈r12pop rdi ; 出栈rdipop rsi ; 出栈rsipop rbp ; 出栈rbppop rbx ; 出栈rbxretnsub_4038F0 endp","categories":[{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"}],"tags":[]},{"title":"如何编写一个简单内核","slug":"noteKernelProgram","date":"2018-09-04T06:04:00.000Z","updated":"2021-08-03T02:09:36.661Z","comments":true,"path":"2018/09/04/noteKernelProgram/","link":"","permalink":"http://debug.cool/2018/09/04/noteKernelProgram/","excerpt":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。","text":"编写一个简单的内核，可以再 x86 系统上加载 GRUB 引导加载程序。此内核将在屏幕上显示一条信息，然后挂起。 x86 机器是如何启动的 在我们考虑编写内核之前，让我们看看机器是如何启动并将控制转移到内核的。 上电后，x86 CPU的大多数寄存器都有明确定义的值。指令指针（EIP）寄存器保存处理器正在执行的指令的存储器地址。EIP硬编码为值0xFFFFFFF0，因此，x86 CPU硬连线开始在物理地址0xFFFFFFF0处执行。实际上，它是32位地址空间的最后16个字节。该存储器地址称为复位向量。 现在，芯片组的内存映射确保0xFFFFFFF0映射到BIOS的某个部分，而不是RAM。同时，BIOS将自身复制到RAM以便更快地访问，我们称之为shadowing。地址0xFFFFFFF0只包含一条跳转指令，指向BIOS复制自身的内存中的地址。 到这里，BIOS代码开始执行。BIOS首先按配置的引导设备顺序搜索可引导设备。它会检查某个幻数以确定设备是否可引导（第一扇区的字节 511 和 512 是否为0xAA55）。 一旦BIOS找到可引导设备，它就会从物理地址0x7c00开始将设备第一个扇区的内容复制到RAM中，然后跳转到地址并执行刚刚加载的代码，此代码称为引导加载程序。 然后，引导加载程序将内核加载到物理地址0x100000。地址0x100000用作x86计算机上所有大内核的起始地址。 所有x86处理器都以简单的16位模式开始，称为实模式。GRUB引导加载程序通过将CR0寄存器的最低位设置为1来切换到32位保护模式，因此，内核以32位保护模式加载。 请注意，在Linux内核的情况下，GRUB会检测Linux启动协议并以实模式加载Linux内核。Linux内核本身可以切换到保护模式。 我们需要什么 一台 x86 电脑 Linux NASM 汇编程序 gcc ld（GNU 链接器） grub 源代码 源代码可以在 Github 存储库中找到mkernel 使用程序集的入口点 我们喜欢用 C 语言编写所有内容，但我们无法避免一些组装。我们将用x86汇编语言编写一个小文件，以此来作为我们内核的起点。我们所有的汇编文件都会调用一个外部函数，我们将用 C 编写，然后暂停程序流程。 我们如何确保此汇编代码将作为内核的起点呢？ 我们将使用链接脚本来链接目标文件以生成最终的内核可执行文件（稍后将详细解释）。在此链接描述文件中，我们将明确指定我们希望将二进制文件加载到地址0x100000。正如我之前所说，这个地址是内核的预期。因此，引导加载程序将负责触发内核的入口点。 这是汇编代码： 12345678910111213141516171819202122232425;;kernel.asmbits 32 ;nasm directive - 32 bitsection .textglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: 第一条指令bits 32不是x86汇编指令，它是NASM汇编程序的一个指令，它指定它应该生成代码，以在32位模式下运行的处理器上运行。在我们的例子中，它并不是强制性的，但是这里包含了它，因为它确实是一个良好实践。 第二行开始文本部分（又名代码部分），这是我们放置所有代码的地方。 global是另一个将源代码中的符号设置为全局的NASM指令，通过这样做，链接器知道符号的start位置，这恰好是我们的切入点。 kmain是我们的函数，将在我们的kernel.c文件中定义。extern声明该函数在其他地方声明。 然后，我们有了start函数，它调用kmain函数并使用hlt指令暂停CPU。中断可以从hlt指令中唤醒CPU，所以我们事先使用cli指令禁用中断。cli是明显中断的缩写。 理想情况下，我们应该为堆栈留出一些内存并将堆栈指针（esp）指向它。但是，似乎GRUB这样做就已经设置了堆栈指针。但是，为了以防万一，我们将在BSS部分中分配一些空间，并将堆栈指针指向分配的内存的开头。我们使用resb以字节为单位保留内存的指令，在它之后，留下一个标签，指向保留的内存块的边缘。在kmain调用之前，堆栈指针（esp）使用mov指令使指向该空间。 C 中的内核 在kernel.asm，我们调用了该函数kmain()。所以我们的C代码将开始执行kmain()： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/* * kernel.c */void kmain(void) &#123; const char *str = &quot;my first kernel&quot;; char *vidptr = (char*)0xb8000; //video mem begins here. unsigned int i = 0; unsigned int j = 0; /* this loops clears the screen * there are 25 lines each of 80 columns; each element takes 2 bytes */ while(j &lt; 80 * 25 * 2) &#123; /* blank character */ vidptr[j] = &#x27; &#x27;; /* attribute-byte - light grey on black screen */ vidptr[j+1] = 0x07; j = j + 2; &#125; j = 0; /* this loop writes the string to video memory */ while(str[j] != &#x27;\\0&#x27;) &#123; /* the character&#x27;s ascii */ vidptr[i] = str[j]; /* attribute-byte: give character black bg and light grey fg */ vidptr[i+1] = 0x07; ++j; i = i + 2; &#125; return;&#125; 我们所有的内核都会清除屏幕并写入字符串“我的第一个内核”。 首先，我们创建一个指向vidptr地址0xb8000的指针，该地址是受保护模式下的视频内存的开始。屏幕的文本内存只是我们地址空间中的一块内存，屏幕的内存映射输入/输出从0xb8000开始，支持25行，每行包含80个ASCII字符。 该文本存储器中的每个字符元素由16位（2字节）表示，而不是我们习惯的8位（1字节）。第一个字节应该具有ASCII中的字符表示，第二个字节是attribute-byte。这描述了其特征属性，比如说颜色。 如果要s在黑色背景上打印绿色字符，我们只需要将字符s存储在视频存储器地址的第一个字节中，将值0x02存储在第二个字节中即可。0代表黑色背景，2代表绿色前景。 请查看下表中的不同颜色： 123456789101112131415160 - Black,1 - Blue,2 - Green,3 - Cyan,4 - Red,5 - Magenta,6 - Brown,7 - Light Grey,8 - Dark Grey,9 - Light Blue,10/a - Light Green,11/b - Light Cyan,12/c - Light Red,13/d - Light Magenta,14/e - Light Brown,15/f – White. 在我们的内核中，我们将在黑色背景上使用浅灰色字符，所以我们的属性字节必须具有值0x07。 在第一个while循环中，程序在 25 行的 80 列中写入具有0x07属性的空白字符，这样就可以清除屏幕。 在第二个while循环中，空终止字符串“my first kernel”的字符被写入视频内存块，每个字符保存一个0x07的属性字节。 这将会在屏幕上显示字符串。 链接部分 我们将kernel.asm与NASM组装成一个目标文件，然后使用GCC，将kernel.c编译成另一个目标文件。现在，我们的工作是将这些对象链接到可执行的可引导内核。 为此，我们使用显式链接脚本，它可以作为参数传递给ld（我们的链接器）。 123456789101112131415161718192021/* * link.ld */OUTPUT_FORMAT(elf32-i386)ENTRY(start)SECTIONS &#123; . = 0x100000; .text : &#123; *(.text) &#125; .data : &#123; *(.data) &#125; .bss : &#123; *(.bss) &#125;&#125; 首先，我们将输出可执行文件的输出格式设置为32位可执行文件和可链接格式（ELF）。ELF 是x86架构上类Unix系统的标准二进制文件格式。 ENTRY有一个论点，它指定应该是我们的可执行文件的入口点的符号名称。 SECTIONS是我们最重要的部分，在这里，我们定义可执行文件的布局。我们可以指定如何合并不同的部分以及每个部分的放置位置。 在SECTIONS语句后面的大括号内，句点字符（.）表示位置计数器。 在SECTIONS块的开头，位置计数器始终初始化为0x0，这可以通过为其分配新值来修改它。 记住前文中说过的，内核的代码应该从地址0x100000开始，所以我们将位置计数器设置为0x100000。 看看下一行.text：&#123;*（.text）&#125; 星号（*）是一个匹配任何文件名的通配符，因此，表达式*(.text)表示.text来自所有输入文件的所有输入节。 因此，链接器将目标文件的所有文本部分，合并到位置计数器中存储地址的可执行文件部分，所以我们的可执行文件的代码部分从0x100000开始。 链接器放置文本输出节之后，位置计数器的值将变为0x1000000 +文本输出节的大小。 类似的，数据和bss部分被合并并放置在location-counter的then值处。 Grub 和 Multiboot 现在，我们准备好构建内核的所有文件。但是，既然我们想用GRUB引导程序引导我们的内核，那么还有一步。 有一个使用引导加载程序加载各种x86内核的标准，称为Multiboot spec（多重引导规范）。 如果GRUB符合Multiboot规范，它将只加载我们的内核。 根据规范，内核必须在其前8个千字节内包含一个头，称为Multiboot header（多引导头）。 此外，此Multiboot标头必须包含3个字节，即 4 字节对齐，即： 一个魔术字段（magic field）：包含幻数0x1BADB002，以识别头部。 一个标志字段（flags field）：我们不关心这个字段，只需将其设置为零。 一个校验字段（checksum field）：添加“magic”和“flags”的校验字段必须为零。 所以我们的kernel.asm就会变成： 12345678910111213141516171819202122232425262728293031323334353637;;kernel.asm;nasm directive - 32 bitbits 32section .text ;multiboot spec align 4 dd 0x1BADB002 ;magic dd 0x00 ;flags dd - (0x1BADB002 + 0x00) ;checksum. m+f+c should be zeroglobal startextern kmain ;kmain is defined in the c filestart: cli ;block interrupts mov esp, stack_space ;set stack pointer call kmain hlt ;halt the CPUsection .bssresb 8192 ;8KB for stackstack_space: DD定义大小为 4 个字节的双字。 构建内核 现在，我们将创建从目标文件kernel.asm和kernel.c，然后使用我们的链接脚本链接。 1nasm -f elf32 kernel.asm -o kasm.o 将运行汇编程序以ELF-32位格式创建目标文件kasm.o。 1gcc -m32 -c kernel.c -o kc.o '-c'选项确保在编译之后，链接不会隐式发生。 1ld -m elf_i386 -T link.ld -o kernel kasm.o kc.o 将使用我们的链接描述文件运行链接器并生成名为kernel的可执行文件。 配置你的 grub 并运行你的内核 GRUB要求您的内核具有名称模式kernel-&lt;version&gt;，所以，我们需要重命名内核。我将内核可执行文件重命名为kernel-701。 现在将它放在/ boot目录中。（需要超级用户权限才能执行此操作。） 在GRUB配置文件中，grub.cfg应该添加一个条目，例如： 1title myKernelroot (hd0,0)kernel /boot/kernel-701 ro 不要忘记删除指令hiddenmenu（如果存在的话）。 重新启动计算机，你将获得列出内核名称的列表选择。 那就是你的内核!! PS 始终建议给自己设置一个虚拟机，用于各种内核黑客攻击。 要在grub2 上运行它，这是新发行版的默认引导加载程序，你的配置应如下所示： 1menuentry &#x27;kernel 701&#x27; &#123;set root=&#x27;hd0,msdos1&#x27;multiboot /boot/kernel-701 ro&#125; 此外，如果您想在 qemu 模拟器上运行内核而不是使用 GRUB 启动内核，你可以通过以下方式执行此操作： 1qemu-system-i386 -kernel kernel 参考和感谢 arjun024 的源码及思路 wiki.osdev.org osdever.net Multiboot spec","categories":[{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"}],"tags":[]},{"title":"如何判断员工持股计划是否靠谱","slug":"stocksCom","date":"2018-03-25T16:10:00.000Z","updated":"2021-08-03T02:09:36.662Z","comments":true,"path":"2018/03/26/stocksCom/","link":"","permalink":"http://debug.cool/2018/03/26/stocksCom/","excerpt":"公司的本意是希望公司发展好，员工多赚钱，但其中也不乏很多公司都是在发展不顺、股票大幅下跌等情况下，为了稳定人心、稳住股价，推出员工持股计划。","text":"公司的本意是希望公司发展好，员工多赚钱，但其中也不乏很多公司都是在发展不顺、股票大幅下跌等情况下，为了稳定人心、稳住股价，推出员工持股计划。 这样不确定因素太多，容易成为接盘侠。目前员工持股绝大部分是亏的（数据可以自己搜一下，从股市、工商信息这几个官方渠道去搜），不要只盯着那几家发展好的公司，用幸存者偏差去看待员工持股这件事，要看全盘数据案例。 首先，员工持股计划是通过二级市场买入，如果你看好公司未来前景，完全可以自己买，无需通过公司的员工持股计划买入。 当行情不好的时候你自主购买的股票可以随时卖出止损，员工持股是做不到的，员工持股一般是统一管理和操作。，当公司的员工持股计划亏50%以上，算上1:1的杠杆实际上本金早就没了。 公司为什么热衷于员工持股？ 给广大投资者以信心炒高股价； 股价高质押股票可以融到更多的钱； 稳定公司人员，股票赚了皆大欢喜你不会走，股票亏了你等着公司兜底更不会走（一般员工持股老板都会明示或暗示兜底） 那么，问题来了，绝大部分的员工持股都是亏的怎么办？ 通常的做法都是展期，有一年的，有两年的，反正就一个字，拖。其中有一部分公司在大幅亏损的情况下选择终止员工持股计划，这些公司都有一个共同的特点就是配资部分超过了1:1，这个在资管新规出来以后是不符合规定的，所以必须要卖出。 整个员工持股计划的周期一般在2年左右，也有3年的，加上展期3～5年很常见，试问职业生涯有几个3、5年？ 作为员工如何破局？ 要回归本质，要了解自己公司的前景如何，发展会不会比现在更好，创始人人品如何？投资人或投资团队操作过的案例（对资金流进行溯源）及风评怎样？ 核心思想，要做价值投资，以上只是价值投资的参考因素。 参与公司员工持股计划，实际上是一种以员工身份进行的投资行为。因此，重点在两方面： 其一，你是否愿意将自己与公司绑定一段时间？这个需要认真考虑。 其二，既然是投资行为，成本、收益、风险如何，值得认真衡量。 总结下来就是，公司是否值得你为之奋斗？投资的渠道非常广泛，投资公司是否是你所知道的最佳投资方式？ 同时，还要考虑以下几个问题： 员工持股的实施方式，一定程度决定了参与员工持股计划的成本。员工持股的实施方式通常是员工自己掏钱在二级市场或者通过公司进行非公开发行取得公司股份。不过有的上市公司员工持股的股份由控股的股东直接赠送给员工，显然相对来说后者更有诱惑力。 个人职业发展定位。员工持股计划对股份通常有一定时间的锁定的。比如一到三年。那么这段期间，公司通常不愿意看到员工离职的，如果离职，也往往不能继续持有通过员工持股计划取得的相应股份，可能需要自己在离职前进行转售。如果你有换工作的打算，见鬼去吧。 公司的的行业地位与发展前景。参与员工持股计划最终能否取得收益，完全取决于持股计划到期时公司股票在二级市场的交易价格与最初股票购买价格的差额。因此，而持股计划到期时公司股票的交易价格与公司的行业地位与发展前景具有一定的关联性。 员工持股计划实时性A股大盘行情。A股股市不同年份股指波动较大，如果员工持股计划在牛市时实施，若干年后大盘转熊的概率比较大，这个时候可能员工持股计划获得的收益将及其有限。 持股计划的结构化安排和个人的风险偏好。为了扩大员工在持股计划获得的收益额，可能会对员工持股计划进行结构化的安排，为员工在银行取得一定比例的配资额，进行杆杠化操作。如果进行1：3的杆杠化，如果员工持股计划股票买入价格10元，员工持股计划到期时，股票价格20元，不考虑员工持股计划的管理费用、银行配资的成本，那么员工可以获得4倍的收益（如果没有杆杠化，只能获得1倍的收益）。相反的，如果到时候亏损，同样会扩大个人的亏损额度。因此要进行权衡。如果公司控股股东能够对该亏损进行兜底，则员工个人风险会小很多。 归根结底，要做价值投资。投资需谨慎，谁的钱都不是大风刮来的。","categories":[{"name":"stocks","slug":"stocks","permalink":"http://debug.cool/categories/stocks/"}],"tags":[]},{"title":"利用多核CPU加速Linux命令","slug":"tipsLinuxCommand","date":"2015-08-13T23:22:03.000Z","updated":"2021-08-03T02:09:36.663Z","comments":true,"path":"2015/08/14/tipsLinuxCommand/","link":"","permalink":"http://debug.cool/2015/08/14/tipsLinuxCommand/","excerpt":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。","text":"要想让Linux命令使用所有的CPU内核，我们需要用到GNU Parallel命令，它让我们所有的CPU内核在单机内做神奇的map-reduce操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各CPU上。 你是否曾经有过要计算一个非常大的数据(几百 GB)的需求？或在里面搜索，或其它操作——一些无法并行的操作。数据专家们，我是在对你们说。你可能有一个 4 核或更多核的 CPU，但我们合适的工具，例如 grep, bzip2, wc, awk, sed等等，都是单线程的，只能使用一个 CPU 内核。 借用卡通人物 Cartman 的话，“如何我能使用这些内核”? 要想让 Linux 命令使用所有的 CPU 内核，我们需要用到GNU Parallel命令，它让我们所有的 CPU 内核在单机内做神奇的 map-reduce 操作，当然，这还要借助很少用到的–pipes 参数(也叫做–spreadstdin)。这样，你的负载就会平均分配到各 CPU 上，真的。 BZIP2 bzip2 是比 gzip 更好的压缩工具，但它很慢！别折腾了，我们有办法解决这问题。 以前的做法： 1cat bigfile.bin | bzip2 –best &gt; compressedfile.bz2 现在这样： 1cat bigfile.bin | parallel –pipe –recend ” -k bzip2 –best &gt; compressedfile.bz2 尤其是针对 bzip2，GNU parallel 在多核 CPU 上是超级的快。你一不留神，它就执行完成了。 GREP 如果你有一个非常大的文本文件，以前你可能会这样： 1grep pattern bigfile.txt 现在你可以这样： 1cat bigfile.txt | parallel –pipe grep ‘pattern’ 或者这样： 1cat bigfile.txt | parallel –block 10M –pipe grep ‘pattern’ 这第二种用法使用了 –block 10M 参数，这是说每个内核处理 1 千万行——你可以用这个参数来调整每个 CUP 内核处理多少行数据。 AWK 下面是一个用 awk 命令计算一个非常大的数据文件的例子。 常规用法： 1cat rands20M.txt | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 现在这样： 1cat rands20M.txt | parallel –pipe awk \\&#x27;&#123;s+=\\$1&#125; END &#123;print s&#125;\\’ | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 这个有点复杂：parallel命令中的–pipe参数将cat输出分成多个块分派给awk调用，形成了很多子计算操作。这些子计算经过第二个管道进入了同一个awk命令，从而输出最终结果。第一个awk有三个反斜杠，这是GNU parallel调用awk的需要。 WC 想要最快的速度计算一个文件的行数吗？ 传统做法： 1wc -l bigfile.txt 现在你应该这样： 1cat bigfile.txt | parallel –pipe wc -l | awk ‘&#123;s+=$1&#125; END &#123;print s&#125;’ 非常的巧妙，先使用parallel命令mapping出大量的wc -l调用，形成子计算，最后通过管道发送给awk进行汇总。 SED 想在一个巨大的文件里使用 sed 命令做大量的替换操作吗？ 常规做法： 1sed s^old^new^g bigfile.txt 现在你可以： 1cat bigfile.txt | parallel –pipe sed s^old^new^g 然后你可以使用管道把输出存储到指定的文件里。","categories":[{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"}],"tags":[]},{"title":"Plan Do Review","slug":"lifePersonPlan","date":"2015-03-20T10:44:00.000Z","updated":"2021-08-03T02:09:36.661Z","comments":true,"path":"2015/03/20/lifePersonPlan/","link":"","permalink":"http://debug.cool/2015/03/20/lifePersonPlan/","excerpt":"凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。","text":"凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。 个人成长 确立个人方向，结合工作内容，找出对应短板 该领域主要专家们的工作是否了解？ 相关网络协议，文件格式是否熟悉？ 相关的技术和主要工具是否都看过？用过？ 阅读只是学习过程的起点，不能止于阅读 工具的每个参数每个菜单都要看、要试； 学习网络协议要实际抓包分析，学习文件格式要读代码实现； 学习老漏洞一定要调试，搞懂别人代码每一个字节的意义，之后要完全自己重写一个Exploit； 细节、细节、细节，刨根问底； 建立学习参考目标 短期参考什么？比自己优秀的同龄人 阅读他们的文章和其他工作成果，从细节中观察他们的学习方式和工作方式。 中期参考什么？你的方向上的业内专家 了解他们的成长轨迹，跟踪他们关注的内容。 长期参考什么？业内老牌企业和先锋企业 把握行业发展、技术趋势，为未来做积累。 推荐的学习方式 以工具为线索 一个比较省事的学习目录：Kali Linux 学习思路，以Metasploit为例： 遍历每个子目录，除了 Exploit 里面还有什么？ 每个工具分别有什么功能？原理是什么？涉及哪些知识？ 能否改进优化？能否发展、组合出新的功能？ 以专家为线索 你的技术方向里有哪些专家？ 他们的邮箱、主页、社交网络账号是什么？ 他们在该方向上有哪些作品？发表过哪些演讲？ 跟踪关注，一个一个学。 处理好学习、工作和生活 学习、工作和生活是矛盾统一的 三者都需要时间，你一天只有 24 小时 调和矛盾的关键：提高效率。 如何提高效率 做好预研，收集相关前人成果，避免无谓的重复劳动 在可行性判断阶段，能找到工具就不写代码，能用脚本语言写就不要用编译语言，能把完美主义放在最终实现阶段 做好笔记并定期整理，遗忘会让所有的投入都白费 多和同事交流，别人说的一个工具的名字可能让你节约数小时 咖啡可以提高思维效率，而且合法 无论怎么提高效率，要成为专家，都需要大量的时间投入","categories":[{"name":"life","slug":"life","permalink":"http://debug.cool/categories/life/"}],"tags":[]}],"categories":[{"name":"dev","slug":"dev","permalink":"http://debug.cool/categories/dev/"},{"name":"tips","slug":"tips","permalink":"http://debug.cool/categories/tips/"},{"name":"notes","slug":"notes","permalink":"http://debug.cool/categories/notes/"},{"name":"stocks","slug":"stocks","permalink":"http://debug.cool/categories/stocks/"},{"name":"life","slug":"life","permalink":"http://debug.cool/categories/life/"}],"tags":[]}